<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · GeometryOps.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://asinghvi17.github.io/GeometryOps.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href><img src="assets/logo.png" alt="GeometryOps.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href>GeometryOps.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li><li><span class="tocitem">Source code</span><ul><li><a class="tocitem" href="source/GeometryOps/">GeometryOps.jl</a></li><li><a class="tocitem" href="source/primitives/">Primitive functions</a></li><li><a class="tocitem" href="source/utils/">Utility functions</a></li><li><a class="tocitem" href="source/methods/area/">Area and signed area</a></li><li><a class="tocitem" href="source/methods/barycentric/">Barycentric coordinates</a></li><li><a class="tocitem" href="source/methods/bools/">Boolean conditions</a></li><li><a class="tocitem" href="source/methods/centroid/">Centroid</a></li><li><a class="tocitem" href="source/methods/contains/">Containment</a></li><li><a class="tocitem" href="source/methods/crosses/">Crossing checks</a></li><li><a class="tocitem" href="source/methods/disjoint/">Disjointness checks</a></li><li><a class="tocitem" href="source/methods/distance/">Distance and signed distance</a></li><li><a class="tocitem" href="source/methods/equals/">Equals</a></li><li><a class="tocitem" href="source/methods/intersects/">Intersection checks</a></li><li><a class="tocitem" href="source/methods/overlaps/">Overlaps</a></li><li><a class="tocitem" href="source/methods/polygonize/">Polygonizing raster data</a></li><li><a class="tocitem" href="source/methods/within/">Containment/withinness</a></li><li><a class="tocitem" href="source/transformations/extent/">-</a></li><li><a class="tocitem" href="source/transformations/flip/">Coordinate flipping</a></li><li><a class="tocitem" href="source/transformations/reproject/">Geometry reprojection</a></li><li><a class="tocitem" href="source/transformations/simplify/">Geometry simplification</a></li><li><a class="tocitem" href="source/transformations/tuples/">Tuple conversion</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/asinghvi17/GeometryOps.jl/blob/main/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="GeometryOps"><a class="docs-heading-anchor" href="#GeometryOps">GeometryOps</a><a id="GeometryOps-1"></a><a class="docs-heading-anchor-permalink" href="#GeometryOps" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/asinghvi17/GeometryOps.jl">GeometryOps</a>.</p><ul><li><a href="#GeometryOps.AbstractBarycentricCoordinateMethod"><code>GeometryOps.AbstractBarycentricCoordinateMethod</code></a></li><li><a href="#GeometryOps.DouglasPeucker"><code>GeometryOps.DouglasPeucker</code></a></li><li><a href="#GeometryOps.MeanValue"><code>GeometryOps.MeanValue</code></a></li><li><a href="#GeometryOps.RadialDistance"><code>GeometryOps.RadialDistance</code></a></li><li><a href="#GeometryOps.SimplifyAlg"><code>GeometryOps.SimplifyAlg</code></a></li><li><a href="#GeometryOps.VisvalingamWhyatt"><code>GeometryOps.VisvalingamWhyatt</code></a></li><li><a href="#GeometryOps._det-Union{Tuple{T2}, Tuple{T1}, Tuple{Union{Tuple{T1, T1}, StaticArraysCore.StaticArray{Tuple{2}, T1, 1}}, Union{Tuple{T2, T2}, StaticArraysCore.StaticArray{Tuple{2}, T2, 1}}}} where {T1&lt;:Real, T2&lt;:Real}"><code>GeometryOps._det</code></a></li><li><a href="#GeometryOps._equals_curves-NTuple{4, Any}"><code>GeometryOps._equals_curves</code></a></li><li><a href="#GeometryOps._intersection_point-Tuple{Tuple, Tuple}"><code>GeometryOps._intersection_point</code></a></li><li><a href="#GeometryOps._line_intersects-Tuple{Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}, Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}"><code>GeometryOps._line_intersects</code></a></li><li><a href="#GeometryOps._line_intersects-Tuple{Vector{Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, Vector{Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}}"><code>GeometryOps._line_intersects</code></a></li><li><a href="#GeometryOps._overlaps-Tuple{Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}, Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}"><code>GeometryOps._overlaps</code></a></li><li><a href="#GeometryOps.apply-Union{Tuple{Target}, Tuple{Any, Type{Target}, Any}} where Target"><code>GeometryOps.apply</code></a></li><li><a href="#GeometryOps.area-Tuple{Any}"><code>GeometryOps.area</code></a></li><li><a href="#GeometryOps.centroid-Tuple{Any}"><code>GeometryOps.centroid</code></a></li><li><a href="#GeometryOps.centroid-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.LinearRingTrait}, Any}"><code>GeometryOps.centroid</code></a></li><li><a href="#GeometryOps.centroid-Tuple{Any, Any}"><code>GeometryOps.centroid</code></a></li><li><a href="#GeometryOps.centroid_and_area-Tuple{GeoInterface.MultiPolygonTrait, Any}"><code>GeometryOps.centroid_and_area</code></a></li><li><a href="#GeometryOps.centroid_and_area-Tuple{GeoInterface.PolygonTrait, Any}"><code>GeometryOps.centroid_and_area</code></a></li><li><a href="#GeometryOps.centroid_and_area-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.LinearRingTrait}, Any}"><code>GeometryOps.centroid_and_area</code></a></li><li><a href="#GeometryOps.centroid_and_area-Tuple{Any}"><code>GeometryOps.centroid_and_area</code></a></li><li><a href="#GeometryOps.centroid_and_length-Tuple{Any}"><code>GeometryOps.centroid_and_length</code></a></li><li><a href="#GeometryOps.centroid_and_length-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.LinearRingTrait}, Any}"><code>GeometryOps.centroid_and_length</code></a></li><li><a href="#GeometryOps.contains-Tuple{Any, Any}"><code>GeometryOps.contains</code></a></li><li><a href="#GeometryOps.crosses-Tuple{Any, Any}"><code>GeometryOps.crosses</code></a></li><li><a href="#GeometryOps.disjoint-Tuple{Any, Any}"><code>GeometryOps.disjoint</code></a></li><li><a href="#GeometryOps.distance-Tuple{Any, Any}"><code>GeometryOps.distance</code></a></li><li><a href="#GeometryOps.embed_extent-Tuple{Any}"><code>GeometryOps.embed_extent</code></a></li><li><a href="#GeometryOps.equals-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.LineTrait}, Any, GeoInterface.LinearRingTrait, Any}"><code>GeometryOps.equals</code></a></li><li><a href="#GeometryOps.equals-NTuple{4, Any}"><code>GeometryOps.equals</code></a></li><li><a href="#GeometryOps.equals-Tuple{GeoInterface.PolygonTrait, Any, GeoInterface.MultiPolygonTrait, Any}"><code>GeometryOps.equals</code></a></li><li><a href="#GeometryOps.equals-Tuple{Any, Any}"><code>GeometryOps.equals</code></a></li><li><a href="#GeometryOps.equals-Tuple{GeoInterface.LinearRingTrait, Any, Union{GeoInterface.LineStringTrait, GeoInterface.LineTrait}, Any}"><code>GeometryOps.equals</code></a></li><li><a href="#GeometryOps.equals-Union{Tuple{T}, Tuple{T, Any, T, Any}} where T"><code>GeometryOps.equals</code></a></li><li><a href="#GeometryOps.equals-Tuple{GeoInterface.MultiPointTrait, Any, GeoInterface.MultiPointTrait, Any}"><code>GeometryOps.equals</code></a></li><li><a href="#GeometryOps.equals-Tuple{GeoInterface.LinearRingTrait, Any, GeoInterface.LinearRingTrait, Any}"><code>GeometryOps.equals</code></a></li><li><a href="#GeometryOps.equals-Tuple{GeoInterface.MultiPolygonTrait, Any, GeoInterface.PolygonTrait, Any}"><code>GeometryOps.equals</code></a></li><li><a href="#GeometryOps.equals-Tuple{GeoInterface.PointTrait, Any, GeoInterface.MultiPointTrait, Any}"><code>GeometryOps.equals</code></a></li><li><a href="#GeometryOps.equals-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.LineTrait}, Any, Union{GeoInterface.LineStringTrait, GeoInterface.LineTrait}, Any}"><code>GeometryOps.equals</code></a></li><li><a href="#GeometryOps.equals-Tuple{GeoInterface.PolygonTrait, Any, GeoInterface.PolygonTrait, Any}"><code>GeometryOps.equals</code></a></li><li><a href="#GeometryOps.equals-Tuple{GeoInterface.PointTrait, Any, GeoInterface.PointTrait, Any}"><code>GeometryOps.equals</code></a></li><li><a href="#GeometryOps.equals-Tuple{GeoInterface.MultiPointTrait, Any, GeoInterface.PointTrait, Any}"><code>GeometryOps.equals</code></a></li><li><a href="#GeometryOps.equals-Tuple{GeoInterface.MultiPolygonTrait, Any, GeoInterface.MultiPolygonTrait, Any}"><code>GeometryOps.equals</code></a></li><li><a href="#GeometryOps.euclid_distance-Tuple{Any, Any}"><code>GeometryOps.euclid_distance</code></a></li><li><a href="#GeometryOps.flatten-Union{Tuple{Target}, Tuple{Type{Target}, Any}} where Target&lt;:GeoInterface.AbstractTrait"><code>GeometryOps.flatten</code></a></li><li><a href="#GeometryOps.flip-Tuple{Any}"><code>GeometryOps.flip</code></a></li><li><a href="#GeometryOps.get_contours-Tuple{AbstractMatrix}"><code>GeometryOps.get_contours</code></a></li><li><a href="#GeometryOps.intersection-Tuple{Any, Any}"><code>GeometryOps.intersection</code></a></li><li><a href="#GeometryOps.intersection-Tuple{GeoInterface.LineTrait, Any, GeoInterface.LineTrait, Any}"><code>GeometryOps.intersection</code></a></li><li><a href="#GeometryOps.intersection-Tuple{GeoInterface.PolygonTrait, Any, GeoInterface.PolygonTrait, Any}"><code>GeometryOps.intersection</code></a></li><li><a href="#GeometryOps.intersection-Tuple{GeoInterface.AbstractTrait, Any, GeoInterface.AbstractTrait, Any}"><code>GeometryOps.intersection</code></a></li><li><a href="#GeometryOps.intersection_points-Tuple{GeoInterface.AbstractTrait, Any, GeoInterface.AbstractTrait, Any}"><code>GeometryOps.intersection_points</code></a></li><li><a href="#GeometryOps.intersection_points-Tuple{Any, Any}"><code>GeometryOps.intersection_points</code></a></li><li><a href="#GeometryOps.intersects-Tuple{GeoInterface.AbstractTrait, Any, GeoInterface.AbstractTrait, Any}"><code>GeometryOps.intersects</code></a></li><li><a href="#GeometryOps.intersects-Tuple{Any, Any}"><code>GeometryOps.intersects</code></a></li><li><a href="#GeometryOps.intersects-Tuple{GeoInterface.LineTrait, Any, GeoInterface.LineTrait, Any}"><code>GeometryOps.intersects</code></a></li><li><a href="#GeometryOps.isclockwise-Tuple{Any}"><code>GeometryOps.isclockwise</code></a></li><li><a href="#GeometryOps.isconcave-Tuple{Any}"><code>GeometryOps.isconcave</code></a></li><li><a href="#GeometryOps.overlaps-Tuple{GeoInterface.LineTrait, Any, GeoInterface.LineTrait, Any}"><code>GeometryOps.overlaps</code></a></li><li><a href="#GeometryOps.overlaps-Tuple{GeoInterface.MultiPolygonTrait, Any, GeoInterface.PolygonTrait, Any}"><code>GeometryOps.overlaps</code></a></li><li><a href="#GeometryOps.overlaps-Tuple{Any, Any}"><code>GeometryOps.overlaps</code></a></li><li><a href="#GeometryOps.overlaps-Tuple{GeoInterface.AbstractTrait, Any, GeoInterface.AbstractTrait, Any}"><code>GeometryOps.overlaps</code></a></li><li><a href="#GeometryOps.overlaps-Tuple{GeoInterface.MultiPointTrait, Any, GeoInterface.MultiPointTrait, Any}"><code>GeometryOps.overlaps</code></a></li><li><a href="#GeometryOps.overlaps-Tuple{GeoInterface.PolygonTrait, Any, GeoInterface.MultiPolygonTrait, Any}"><code>GeometryOps.overlaps</code></a></li><li><a href="#GeometryOps.overlaps-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.Wrappers.LinearRing}, Any, Union{GeoInterface.LineStringTrait, GeoInterface.Wrappers.LinearRing}, Any}"><code>GeometryOps.overlaps</code></a></li><li><a href="#GeometryOps.overlaps-Tuple{GeoInterface.PolygonTrait, Any, GeoInterface.PolygonTrait, Any}"><code>GeometryOps.overlaps</code></a></li><li><a href="#GeometryOps.overlaps-Tuple{GeoInterface.MultiPolygonTrait, Any, GeoInterface.MultiPolygonTrait, Any}"><code>GeometryOps.overlaps</code></a></li><li><a href="#GeometryOps.point_in_polygon-Tuple{Any, Any}"><code>GeometryOps.point_in_polygon</code></a></li><li><a href="#GeometryOps.point_on_line-Tuple{Any, Any}"><code>GeometryOps.point_on_line</code></a></li><li><a href="#GeometryOps.polygon_to_line-Tuple{Any}"><code>GeometryOps.polygon_to_line</code></a></li><li><a href="#GeometryOps.polygonize-Tuple{AbstractMatrix}"><code>GeometryOps.polygonize</code></a></li><li><a href="#GeometryOps.rebuild-Tuple{Any, Any}"><code>GeometryOps.rebuild</code></a></li><li><a href="#GeometryOps.reconstruct-Tuple{Any, Any}"><code>GeometryOps.reconstruct</code></a></li><li><a href="#GeometryOps.reproject-Tuple{Any}"><code>GeometryOps.reproject</code></a></li><li><a href="#GeometryOps.signed_area-Tuple{Any}"><code>GeometryOps.signed_area</code></a></li><li><a href="#GeometryOps.signed_distance-Tuple{Any, Any}"><code>GeometryOps.signed_distance</code></a></li><li><a href="#GeometryOps.simplify-Tuple{Any}"><code>GeometryOps.simplify</code></a></li><li><a href="#GeometryOps.t_value-Union{Tuple{T2}, Tuple{T1}, Tuple{N}, Tuple{Union{Tuple{Vararg{T1, N}}, StaticArraysCore.StaticArray{Tuple{N}, T1, 1}}, Union{Tuple{Vararg{T1, N}}, StaticArraysCore.StaticArray{Tuple{N}, T1, 1}}, T2, T2}} where {N, T1&lt;:Real, T2&lt;:Real}"><code>GeometryOps.t_value</code></a></li><li><a href="#GeometryOps.to_edges-Tuple{Any}"><code>GeometryOps.to_edges</code></a></li><li><a href="#GeometryOps.tuples-Tuple{Any}"><code>GeometryOps.tuples</code></a></li><li><a href="#GeometryOps.unwrap"><code>GeometryOps.unwrap</code></a></li><li><a href="#GeometryOps.weighted_mean-Union{Tuple{WT}, Tuple{WT, Any, Any}} where WT&lt;:Real"><code>GeometryOps.weighted_mean</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.AbstractBarycentricCoordinateMethod" href="#GeometryOps.AbstractBarycentricCoordinateMethod"><code>GeometryOps.AbstractBarycentricCoordinateMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractBarycentricCoordinateMethod</code></pre><p>Abstract supertype for barycentric coordinate methods.   The subtypes may serve as dispatch types, or may cache  some information about the target polygon.  </p><p><strong>API</strong></p><p>The following methods must be implemented for all subtypes:</p><ul><li><code>barycentric_coordinates!(λs::Vector{&lt;: Real}, method::AbstractBarycentricCoordinateMethod, exterior::Vector{&lt;: Point{2, T1}}, point::Point{2, T2})</code></li><li><code>barycentric_interpolate(method::AbstractBarycentricCoordinateMethod, exterior::Vector{&lt;: Point{2, T1}}, values::Vector{V}, point::Point{2, T2})::V</code></li><li><code>barycentric_interpolate(method::AbstractBarycentricCoordinateMethod, exterior::Vector{&lt;: Point{2, T1}}, interiors::Vector{&lt;: Vector{&lt;: Point{2, T1}}} values::Vector{V}, point::Point{2, T2})::V</code></li></ul><p>The rest of the methods will be implemented in terms of these, and have efficient dispatches for broadcasting.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/barycentric.jl#L112-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.DouglasPeucker" href="#GeometryOps.DouglasPeucker"><code>GeometryOps.DouglasPeucker</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DouglasPeucker &lt;: SimplifyAlg

DouglasPeucker(; number, ratio, tol)</code></pre><p>Simplifies geometries by removing points below <code>tol</code> distance from the line between its neighboring points.</p><p><strong>Keywords</strong></p><ul><li><p><code>ratio</code>: the fraction of points that should remain after <code>simplify</code>.    Useful as it will generalise for large collections of objects.</p></li><li><p><code>number</code>: the number of points that should remain after <code>simplify</code>.   Less useful for large collections of mixed size objects.</p></li><li><p><code>tol</code>: the minimum distance a point will be from the line   joining its neighboring points.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/transformations/simplify.jl#L186-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.MeanValue" href="#GeometryOps.MeanValue"><code>GeometryOps.MeanValue</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MeanValue() &lt;: AbstractBarycentricCoordinateMethod</code></pre><p>This method calculates barycentric coordinates using the mean value method.</p><p><strong>References</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/barycentric.jl#L218-L225">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.RadialDistance" href="#GeometryOps.RadialDistance"><code>GeometryOps.RadialDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RadialDistance &lt;: SimplifyAlg</code></pre><p>Simplifies geometries by removing points less than <code>tol</code> distance from the line between its neighboring points.</p><p><strong>Keywords</strong></p><ul><li><p><code>ratio</code>: the fraction of points that should remain after <code>simplify</code>.    Useful as it will generalise for large collections of objects.</p></li><li><p><code>number</code>: the number of points that should remain after <code>simplify</code>.   Less useful for large collections of mixed size objects.</p></li><li><p><code>tol</code>: the minimum distance between points.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/transformations/simplify.jl#L142-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.SimplifyAlg" href="#GeometryOps.SimplifyAlg"><code>GeometryOps.SimplifyAlg</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type SimplifyAlg</code></pre><p>Abstract type for simplification algorithms.</p><p><strong>API</strong></p><p>For now, the algorithm must hold the <code>number</code>, <code>ratio</code> and <code>tol</code> properties.  </p><p>Simplification algorithm types can hook into the interface by implementing  the <code>_simplify(trait, alg, geom)</code> methods for whichever traits are necessary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/transformations/simplify.jl#L9-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.VisvalingamWhyatt" href="#GeometryOps.VisvalingamWhyatt"><code>GeometryOps.VisvalingamWhyatt</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VisvalingamWhyatt &lt;: SimplifyAlg

VisvalingamWhyatt(; kw...)</code></pre><p>Simplifies geometries by removing points below <code>tol</code> distance from the line between its neighboring points.</p><p><strong>Keywords</strong></p><ul><li><p><code>ratio</code>: the fraction of points that should remain after <code>simplify</code>.    Useful as it will generalise for large collections of objects.</p></li><li><p><code>number</code>: the number of points that should remain after <code>simplify</code>.   Less useful for large collections of mixed size objects.</p></li><li><p><code>tol</code>: the minimum area of a triangle made with a point and   its neighboring points.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/transformations/simplify.jl#L243-L254">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps._det-Union{Tuple{T2}, Tuple{T1}, Tuple{Union{Tuple{T1, T1}, StaticArraysCore.StaticArray{Tuple{2}, T1, 1}}, Union{Tuple{T2, T2}, StaticArraysCore.StaticArray{Tuple{2}, T2, 1}}}} where {T1&lt;:Real, T2&lt;:Real}" href="#GeometryOps._det-Union{Tuple{T2}, Tuple{T1}, Tuple{Union{Tuple{T1, T1}, StaticArraysCore.StaticArray{Tuple{2}, T1, 1}}, Union{Tuple{T2, T2}, StaticArraysCore.StaticArray{Tuple{2}, T2, 1}}}} where {T1&lt;:Real, T2&lt;:Real}"><code>GeometryOps._det</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_det(s1::Point2{T1}, s2::Point2{T2}) where {T1 &lt;: Real, T2 &lt;: Real}</code></pre><p>Returns the determinant of the matrix formed by <code>hcat</code>&#39;ing two points <code>s1</code> and <code>s2</code>.</p><p>Specifically, this is: </p><pre><code class="language-julia hljs">s1[1] * s2[2] - s1[2] * s2[1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/barycentric.jl#L232-L241">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps._equals_curves-NTuple{4, Any}" href="#GeometryOps._equals_curves-NTuple{4, Any}"><code>GeometryOps._equals_curves</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_equals_curves(c1, c2, closed_type1, closed_type2)::Bool</code></pre><p>Two curves are equal if they share the same set of point, representing the same geometry. Both curves must must be composed of the same set of points, however, they do not have to wind in the same direction, or start on the same point to be equivalent. Inputs:     c1 first geometry     c2 second geometry     closed<em>type1::Bool true if c1 is closed by definition (polygon, linear ring)     closed</em>type2::Bool true if c2 is closed by definition (polygon, linear ring)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/equals.jl#L143-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps._intersection_point-Tuple{Tuple, Tuple}" href="#GeometryOps._intersection_point-Tuple{Tuple, Tuple}"><code>GeometryOps._intersection_point</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_intersection_point(
    (a1, a2)::Tuple,
    (b1, b2)::Tuple,
)</code></pre><p>Calculates the intersection point between two lines if it exists, and as if the line extended to infinity, and the fractional component of each line from the initial end point to the intersection point. Inputs:     (a1, a2)::Tuple{Tuple{::Real, ::Real}, Tuple{::Real, ::Real}} first line     (b1, b2)::Tuple{Tuple{::Real, ::Real}, Tuple{::Real, ::Real}} second line Outputs:     (x, y)::Tuple{::Real, ::Real} intersection point     (t, u)::Tuple{::Real, ::Real} fractional length of lines to intersection     Both are ::Nothing if point doesn&#39;t exist!</p><p>Calculation derivation can be found here:     https://stackoverflow.com/questions/563198/</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/intersects.jl#L309-L328">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps._line_intersects-Tuple{Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}, Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}" href="#GeometryOps._line_intersects-Tuple{Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}, Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}"><code>GeometryOps._line_intersects</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_line_intersects(
    edge_a::Edge,
    edge_b::Edge,
)::Bool</code></pre><p>Returns true if there is at least one intersection between two edges.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/intersects.jl#L132-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps._line_intersects-Tuple{Vector{Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, Vector{Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}}" href="#GeometryOps._line_intersects-Tuple{Vector{Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, Vector{Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}}"><code>GeometryOps._line_intersects</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_line_intersects(
    edges_a::Vector{Edge},
    edges_b::Vector{Edge}
)::Bool</code></pre><p>Returns true if there is at least one intersection between edges within the two lists of edges.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/intersects.jl#L110-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps._overlaps-Tuple{Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}, Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}" href="#GeometryOps._overlaps-Tuple{Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}, Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}"><code>GeometryOps._overlaps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_overlaps(
    (a1, a2)::Edge,
    (b1, b2)::Edge
)::Bool</code></pre><p>If the edges overlap, meaning that they are colinear but each have one endpoint outside of the other edge, return true. Else false. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/overlaps.jl#L214-L222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.apply-Union{Tuple{Target}, Tuple{Any, Type{Target}, Any}} where Target" href="#GeometryOps.apply-Union{Tuple{Target}, Tuple{Any, Type{Target}, Any}} where Target"><code>GeometryOps.apply</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">apply(f, target::Type{&lt;:AbstractTrait}, obj; kw...)</code></pre><p>Reconstruct a geometry, feature, feature collection, or nested vectors of either using the function <code>f</code> on the <code>target</code> trait.</p><p><code>f(target_geom) =&gt; x</code> where <code>x</code> also has the <code>target</code> trait, or a trait that can  be substituted. For example, swapping <code>PolgonTrait</code> to <code>MultiPointTrait</code> will fail if the outer object has <code>MultiPolygonTrait</code>, but should work if it has <code>FeatureTrait</code>.</p><p>Objects &quot;shallower&quot; than the target trait are always completely rebuilt, like a <code>Vector</code> of <code>FeatureCollectionTrait</code> of <code>FeatureTrait</code> when the target has <code>PolygonTrait</code> and is held in the features. But &quot;deeper&quot; objects may remain  unchanged - such as points and linear rings if the target is the same <code>PolygonTrait</code>.</p><p>The result is a functionally similar geometry with values depending on <code>f</code></p><ul><li><code>threaded</code>: <code>true</code> or <code>false</code>. Whether to use multithreading. Defaults to <code>false</code>.</li><li><code>crs</code>: The CRS to attach to geometries. Defaults to <code>nothing</code>.</li><li><code>calc_extent</code>: <code>true</code> or <code>false</code>. Whether to calculate the extent. Defaults to <code>false</code>.</li></ul><p><strong>Example</strong></p><p>Flipped point the order in any feature or geometry, or iterables of either:</p><p>```juia import GeoInterface as GI import GeometryOps as GO geom = GI.Polygon([GI.LinearRing([(1, 2), (3, 4), (5, 6), (1, 2)]),                     GI.LinearRing([(3, 4), (5, 6), (6, 7), (3, 4)])])</p><p>flipped_geom = GO.apply(GI.PointTrait, geom) do p     (GI.y(p), GI.x(p)) end</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/primitives.jl#L59-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.area-Tuple{Any}" href="#GeometryOps.area-Tuple{Any}"><code>GeometryOps.area</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">area(geom)::Real</code></pre><p>Returns the area of the geometry. This is computed slighly differently for different geometries:     - The area of a point is always zero.     - The area of a curve is always zero.     - The area of a polygon is the absolute value of the signed area.     - The area multi-polygon is the sum of the areas of all of the sub-polygons.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/area.jl#L46-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.centroid-Tuple{Any, Any}" href="#GeometryOps.centroid-Tuple{Any, Any}"><code>GeometryOps.centroid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">centroid(trait, geom)::Tuple{T, T}</code></pre><p>Returns the centroid of a polygon or multipolygon, which is calculated by weighting edges by their <code>area component</code> by convention.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/centroid.jl#L76-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.centroid-Tuple{Any}" href="#GeometryOps.centroid-Tuple{Any}"><code>GeometryOps.centroid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">centroid(geom)::Tuple{T, T}</code></pre><p>Returns the centroid of a given line segment, linear ring, polygon, or mutlipolygon.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/centroid.jl#L54-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.centroid-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.LinearRingTrait}, Any}" href="#GeometryOps.centroid-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.LinearRingTrait}, Any}"><code>GeometryOps.centroid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">centroid(
    trait::Union{GI.LineStringTrait, GI.LinearRingTrait},
    geom,
)::Tuple{T, T}</code></pre><p>Returns the centroid of a line string or linear ring, which is calculated by weighting line segments by their length by convention.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/centroid.jl#L62-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.centroid_and_area-Tuple{Any}" href="#GeometryOps.centroid_and_area-Tuple{Any}"><code>GeometryOps.centroid_and_area</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">centroid_and_area(
    ::Union{GI.LineStringTrait, GI.LinearRingTrait}, 
    geom,
)::(::Tuple{T, T}, ::Real)</code></pre><p>Returns the centroid and area of a given geom.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/centroid.jl#L92-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.centroid_and_area-Tuple{GeoInterface.MultiPolygonTrait, Any}" href="#GeometryOps.centroid_and_area-Tuple{GeoInterface.MultiPolygonTrait, Any}"><code>GeometryOps.centroid_and_area</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">centroid_and_area(::GI.MultiPolygonTrait, geom)::(::Tuple{T, T}, ::Real)</code></pre><p>Returns the centroid and area of a given multipolygon.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/centroid.jl#L207-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.centroid_and_area-Tuple{GeoInterface.PolygonTrait, Any}" href="#GeometryOps.centroid_and_area-Tuple{GeoInterface.PolygonTrait, Any}"><code>GeometryOps.centroid_and_area</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">centroid_and_area(::GI.PolygonTrait, geom)::(::Tuple{T, T}, ::Real)</code></pre><p>Returns the centroid and area of a given polygon.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/centroid.jl#L181-L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.centroid_and_area-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.LinearRingTrait}, Any}" href="#GeometryOps.centroid_and_area-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.LinearRingTrait}, Any}"><code>GeometryOps.centroid_and_area</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">centroid_and_area(
    ::Union{GI.LineStringTrait, GI.LinearRingTrait},
    geom,
)::(::Tuple{T, T}, ::Real)</code></pre><p>Returns the centroid and area of a given a line string or a linear ring. Note that this is only valid if the line segment or linear ring is closed. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/centroid.jl#L139-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.centroid_and_length-Tuple{Any}" href="#GeometryOps.centroid_and_length-Tuple{Any}"><code>GeometryOps.centroid_and_length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">centroid_and_length(geom)::(::Tuple{T, T}, ::Real)</code></pre><p>Returns the centroid and length of a given line/ring. Note this is only valid for line strings and linear rings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/centroid.jl#L84-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.centroid_and_length-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.LinearRingTrait}, Any}" href="#GeometryOps.centroid_and_length-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.LinearRingTrait}, Any}"><code>GeometryOps.centroid_and_length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">centroid_and_length(geom)::(::Tuple{T, T}, ::Real)</code></pre><p>Returns the centroid and length of a given line/ring. Note this is only valid for line strings and linear rings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/centroid.jl#L102-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.contains-Tuple{Any, Any}" href="#GeometryOps.contains-Tuple{Any, Any}"><code>GeometryOps.contains</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">contains(ft1::AbstractGeometry, ft2::AbstractGeometry)::Bool</code></pre><p>Return true if the second geometry is completely contained by the first geometry. The interiors of both geometries must intersect and, the interior and boundary of the secondary (geometry b) must not intersect the exterior of the primary (geometry a). <code>contains</code> returns the exact opposite result of <code>within</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">import GeometryOps as GO, GeoInterface as GI
line = GI.LineString([(1, 1), (1, 2), (1, 3), (1, 4)])
point = (1, 2)

GO.contains(line, point)
# output
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/contains.jl#L5-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.crosses-Tuple{Any, Any}" href="#GeometryOps.crosses-Tuple{Any, Any}"><code>GeometryOps.crosses</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs"> crosses(geom1, geom2)::Bool</code></pre><p>Return <code>true</code> if the intersection results in a geometry whose dimension is one less than the maximum dimension of the two source geometries and the intersection set is interior to both source geometries.</p><p>TODO: broken</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">import GeoInterface as GI, GeometryOps as GO

line1 = GI.LineString([(1, 1), (1, 2), (1, 3), (1, 4)])
line2 = GI.LineString([(-2, 2), (4, 2)])

GO.crosses(line1, line2)
# output
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/crosses.jl#L3-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.disjoint-Tuple{Any, Any}" href="#GeometryOps.disjoint-Tuple{Any, Any}"><code>GeometryOps.disjoint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">disjoint(geom1, geom2)::Bool</code></pre><p>Return <code>true</code> if the intersection of the two geometries is an empty set.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">import GeometryOps as GO, GeoInterface as GI

poly = GI.Polygon([[(-1, 2), (3, 2), (3, 3), (-1, 3), (-1, 2)]])
point = (1, 1)
GO.disjoint(poly, point)

# output
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/disjoint.jl#L3-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.distance-Tuple{Any, Any}" href="#GeometryOps.distance-Tuple{Any, Any}"><code>GeometryOps.distance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">distance(point, geom)::Real</code></pre><p>Calculates the  ditance from the geometry <code>g1</code> to the <code>point</code>. The distance will always be positive or zero.</p><p>The method will differ based on the type of the geometry provided:     - The distance from a point to a point is just the Euclidean distance     between the points.     - The distance from a point to a multipolygon is the shortest distance from     a the given point to any point within the multipoint object.     - The distance from a point to a line is the minimum distance from the point     to the closest point on the given line.     - The distance from a point to a linestring is the minimum distance from the     point to the closest segment of the linestring.     - The distance from a point to a linear ring is the minimum distance from     the point to the closest segment of the linear ring.     - The distance from a point to a polygon is zero if the point is within the     polygon and otherwise is the minimum distance from the point to an edge of     the polygon. This includes edges created by holes.     - The distance from a point to a multipolygon is zero if the point is within     the multipolygon and otherwise is the minimum distance from the point to the     closest edge of any of the polygons within the multipolygon. This includes     edges created by holes of the polygons as well.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/distance.jl#L56-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.embed_extent-Tuple{Any}" href="#GeometryOps.embed_extent-Tuple{Any}"><code>GeometryOps.embed_extent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">embed_extent(obj)</code></pre><p>Recursively wrap the object with a GeoInterface.jl geometry, calculating and adding an <code>Extents.Extent</code> to all objects.</p><p>This can improve performance when extents need to be checked multiple times, such when needing to check if many points are in geometries, and using their extents as a quick filter for obviously exterior points.</p><p><strong>Keywords</strong></p><ul><li><code>threaded</code>: <code>true</code> or <code>false</code>. Whether to use multithreading. Defaults to <code>false</code>.</li><li><code>crs</code>: The CRS to attach to geometries. Defaults to <code>nothing</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/transformations/extent.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.equals-NTuple{4, Any}" href="#GeometryOps.equals-NTuple{4, Any}"><code>GeometryOps.equals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">equals(trait_a, geom_a, trait_b, geom_b)</code></pre><p>Two geometries which are not of the same type cannot be equal so they always return false.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/equals.jl#L80-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.equals-Tuple{Any, Any}" href="#GeometryOps.equals-Tuple{Any, Any}"><code>GeometryOps.equals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">equals(geom1, geom2)::Bool</code></pre><p>Compare two Geometries return true if they are the same geometry.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">import GeometryOps as GO, GeoInterface as GI
poly1 = GI.Polygon([[(0,0), (0,5), (5,5), (5,0), (0,0)]])
poly2 = GI.Polygon([[(0,0), (0,5), (5,5), (5,0), (0,0)]])

GO.equals(poly1, poly2)
# output
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/equals.jl#L51-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.equals-Tuple{GeoInterface.LinearRingTrait, Any, GeoInterface.LinearRingTrait, Any}" href="#GeometryOps.equals-Tuple{GeoInterface.LinearRingTrait, Any, GeoInterface.LinearRingTrait, Any}"><code>GeometryOps.equals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">equals(
    ::GI.LinearRingTrait, l1,
    ::GI.LinearRingTrait, l2,
)::Bool</code></pre><p>Two linear rings are equal if they share the same set of points going along the curve. Note that rings are closed by definition, so they can have, but don&#39;t need, a repeated last point to be equal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/equals.jl#L249-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.equals-Tuple{GeoInterface.LinearRingTrait, Any, Union{GeoInterface.LineStringTrait, GeoInterface.LineTrait}, Any}" href="#GeometryOps.equals-Tuple{GeoInterface.LinearRingTrait, Any, Union{GeoInterface.LineStringTrait, GeoInterface.LineTrait}, Any}"><code>GeometryOps.equals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">equals(
    ::GI.LinearRingTrait, l1,
    ::Union{GI.LineTrait, GI.LineStringTrait}, l2,
)::Bool</code></pre><p>A linear ring and a line/linestring are equal if they share the same set of points going along the curve. Note that lines aren&#39;t closed by defintion, but rings are, so the line must have a repeated last point to be equal</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/equals.jl#L234-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.equals-Tuple{GeoInterface.MultiPointTrait, Any, GeoInterface.MultiPointTrait, Any}" href="#GeometryOps.equals-Tuple{GeoInterface.MultiPointTrait, Any, GeoInterface.MultiPointTrait, Any}"><code>GeometryOps.equals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">equals(::GI.MultiPointTrait, mp1, ::GI.MultiPointTrait, mp2)::Bool</code></pre><p>Two multipoints are equal if they share the same set of points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/equals.jl#L123-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.equals-Tuple{GeoInterface.MultiPointTrait, Any, GeoInterface.PointTrait, Any}" href="#GeometryOps.equals-Tuple{GeoInterface.MultiPointTrait, Any, GeoInterface.PointTrait, Any}"><code>GeometryOps.equals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">equals(::GI.MultiPointTrait, mp1, ::GI.PointTrait, p2)::Bool</code></pre><p>A point and a multipoint are equal if the multipoint is composed of a single point that is equivalent to the given point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/equals.jl#L114-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.equals-Tuple{GeoInterface.MultiPolygonTrait, Any, GeoInterface.MultiPolygonTrait, Any}" href="#GeometryOps.equals-Tuple{GeoInterface.MultiPolygonTrait, Any, GeoInterface.MultiPolygonTrait, Any}"><code>GeometryOps.equals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">equals(::GI.PolygonTrait, geom_a, ::GI.PolygonTrait, geom_b)::Bool</code></pre><p>Two multipolygons are equal if they share the same set of polygons.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/equals.jl#L314-L318">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.equals-Tuple{GeoInterface.MultiPolygonTrait, Any, GeoInterface.PolygonTrait, Any}" href="#GeometryOps.equals-Tuple{GeoInterface.MultiPolygonTrait, Any, GeoInterface.PolygonTrait, Any}"><code>GeometryOps.equals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">equals(::GI.MultiPolygonTrait, geom_a, ::GI.PolygonTrait, geom_b)::Bool</code></pre><p>A polygon and a multipolygon are equal if the multipolygon is composed of a single polygon that is equivalent to the given polygon.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/equals.jl#L305-L310">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.equals-Tuple{GeoInterface.PointTrait, Any, GeoInterface.MultiPointTrait, Any}" href="#GeometryOps.equals-Tuple{GeoInterface.PointTrait, Any, GeoInterface.MultiPointTrait, Any}"><code>GeometryOps.equals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">equals(::GI.PointTrait, p1, ::GI.MultiPointTrait, mp2)::Bool</code></pre><p>A point and a multipoint are equal if the multipoint is composed of a single point that is equivalent to the given point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/equals.jl#L103-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.equals-Tuple{GeoInterface.PointTrait, Any, GeoInterface.PointTrait, Any}" href="#GeometryOps.equals-Tuple{GeoInterface.PointTrait, Any, GeoInterface.PointTrait, Any}"><code>GeometryOps.equals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">equals(::GI.PointTrait, p1, ::GI.PointTrait, p2)::Bool</code></pre><p>Two points are the same if they have the same x and y (and z if 3D) coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/equals.jl#L88-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.equals-Tuple{GeoInterface.PolygonTrait, Any, GeoInterface.MultiPolygonTrait, Any}" href="#GeometryOps.equals-Tuple{GeoInterface.PolygonTrait, Any, GeoInterface.MultiPolygonTrait, Any}"><code>GeometryOps.equals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">equals(::GI.PolygonTrait, geom_a, ::GI.MultiPolygonTrait, geom_b)::Bool</code></pre><p>A polygon and a multipolygon are equal if the multipolygon is composed of a single polygon that is equivalent to the given polygon.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/equals.jl#L294-L299">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.equals-Tuple{GeoInterface.PolygonTrait, Any, GeoInterface.PolygonTrait, Any}" href="#GeometryOps.equals-Tuple{GeoInterface.PolygonTrait, Any, GeoInterface.PolygonTrait, Any}"><code>GeometryOps.equals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">equals(::GI.PolygonTrait, geom_a, ::GI.PolygonTrait, geom_b)::Bool</code></pre><p>Two polygons are equal if they share the same exterior edge and holes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/equals.jl#L264-L268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.equals-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.LineTrait}, Any, GeoInterface.LinearRingTrait, Any}" href="#GeometryOps.equals-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.LineTrait}, Any, GeoInterface.LinearRingTrait, Any}"><code>GeometryOps.equals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">equals(
    ::Union{GI.LineTrait, GI.LineStringTrait}, l1,
    ::GI.LinearRingTrait, l2,
)::Bool</code></pre><p>A line/linestring and a linear ring are equal if they share the same set of points going along the curve. Note that lines aren&#39;t closed by defintion, but rings are, so the line must have a repeated last point to be equal</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/equals.jl#L219-L228">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.equals-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.LineTrait}, Any, Union{GeoInterface.LineStringTrait, GeoInterface.LineTrait}, Any}" href="#GeometryOps.equals-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.LineTrait}, Any, Union{GeoInterface.LineStringTrait, GeoInterface.LineTrait}, Any}"><code>GeometryOps.equals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">equals(
    ::Union{GI.LineTrait, GI.LineStringTrait}, l1,
    ::Union{GI.LineTrait, GI.LineStringTrait}, l2,
)::Bool</code></pre><p>Two lines/linestrings are equal if they share the same set of points going along the curve. Note that lines/linestrings aren&#39;t closed by defintion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/equals.jl#L205-L213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.equals-Union{Tuple{T}, Tuple{T, Any, T, Any}} where T" href="#GeometryOps.equals-Union{Tuple{T}, Tuple{T, Any, T, Any}} where T"><code>GeometryOps.equals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">equals(::T, geom_a, ::T, geom_b)::Bool</code></pre><p>Two geometries of the same type, which don&#39;t have a equals function to dispatch off of should throw an error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/equals.jl#L72-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.euclid_distance-Tuple{Any, Any}" href="#GeometryOps.euclid_distance-Tuple{Any, Any}"><code>GeometryOps.euclid_distance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">euclid_distance(p1::Point, p2::Point)::Real</code></pre><p>Returns the Euclidean distance between two points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/distance.jl#L188-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.flatten-Union{Tuple{Target}, Tuple{Type{Target}, Any}} where Target&lt;:GeoInterface.AbstractTrait" href="#GeometryOps.flatten-Union{Tuple{Target}, Tuple{Type{Target}, Any}} where Target&lt;:GeoInterface.AbstractTrait"><code>GeometryOps.flatten</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flatten(target::Type{&lt;:GI.AbstractTrait}, obj)
flatten(f, target::Type{&lt;:GI.AbstractTrait}, obj)</code></pre><p>Lazily flatten any <code>AbstractArray</code>, iterator, <code>FeatureCollectionTrait</code>,  <code>FeatureTrait</code> or <code>AbstractGeometryTrait</code> object <code>obj</code>, so that objects  with the <code>target</code> trait are returned by the iterator.</p><p>If <code>f</code> is passed in it will be applied to the target geometries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/primitives.jl#L215-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.flip-Tuple{Any}" href="#GeometryOps.flip-Tuple{Any}"><code>GeometryOps.flip</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flip(obj)</code></pre><p>Swap all of the x and y coordinates in obj, otherwise keeping the original structure (but not necessarily the original type).</p><p><strong>Keywords</strong></p><ul><li><code>threaded</code>: <code>true</code> or <code>false</code>. Whether to use multithreading. Defaults to <code>false</code>.</li><li><code>crs</code>: The CRS to attach to geometries. Defaults to <code>nothing</code>.</li><li><code>calc_extent</code>: <code>true</code> or <code>false</code>. Whether to calculate the extent. Defaults to <code>false</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/transformations/flip.jl#L6-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.get_contours-Tuple{AbstractMatrix}" href="#GeometryOps.get_contours-Tuple{AbstractMatrix}"><code>GeometryOps.get_contours</code></a> — <span class="docstring-category">Method</span></header><section><div><p>get_contours(A::AbstractMatrix)</p><p>Returns contours as vectors of <code>CartesianIndex</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/polygonize.jl#L158-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.intersection-Tuple{Any, Any}" href="#GeometryOps.intersection-Tuple{Any, Any}"><code>GeometryOps.intersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intersection(geom_a, geom_b)::Union{Tuple{::Real, ::Real}, ::Nothing}</code></pre><p>Return an intersection point between two geometries. Return nothing if none are found. Else, the return type depends on the input. It will be a union between: a point, a line, a linear ring, a polygon, or a multipolygon</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">import GeoInterface as GI, GeometryOps as GO

line1 = GI.Line([(124.584961,-12.768946), (126.738281,-17.224758)])
line2 = GI.Line([(123.354492,-15.961329), (127.22168,-14.008696)])
GO.intersection(line1, line2)

# output
(125.58375366067547, -14.83572303404496)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/intersects.jl#L145-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.intersection-Tuple{GeoInterface.AbstractTrait, Any, GeoInterface.AbstractTrait, Any}" href="#GeometryOps.intersection-Tuple{GeoInterface.AbstractTrait, Any, GeoInterface.AbstractTrait, Any}"><code>GeometryOps.intersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intersection(
    ::GI.AbstractTrait, geom_a,
    ::GI.AbstractTrait, geom_b,
)::Union{
    ::Vector{Vector{Tuple{::Real, ::Real}}}, # is this a good return type?
    ::Nothing
}</code></pre><p>Calculates the intersection between two line segments. Return nothing if there isn&#39;t one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/intersects.jl#L219-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.intersection-Tuple{GeoInterface.LineTrait, Any, GeoInterface.LineTrait, Any}" href="#GeometryOps.intersection-Tuple{GeoInterface.LineTrait, Any, GeoInterface.LineTrait, Any}"><code>GeometryOps.intersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intersection(
    ::GI.LineTrait, line_a,
    ::GI.LineTrait, line_b,
)::Union{
    ::Tuple{::Real, ::Real},
    ::Nothing
}</code></pre><p>Calculates the intersection between two line segments. Return nothing if there isn&#39;t one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/intersects.jl#L168-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.intersection-Tuple{GeoInterface.PolygonTrait, Any, GeoInterface.PolygonTrait, Any}" href="#GeometryOps.intersection-Tuple{GeoInterface.PolygonTrait, Any, GeoInterface.PolygonTrait, Any}"><code>GeometryOps.intersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intersection(
    ::GI.PolygonTrait, poly_a,
    ::GI.PolygonTrait, poly_b,
)::Union{
    ::Vector{Vector{Tuple{::Real, ::Real}}}, # is this a good return type?
    ::Nothing
}</code></pre><p>Calculates the intersection between two line segments. Return nothing if there isn&#39;t one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/intersects.jl#L202-L213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.intersection_points-Tuple{Any, Any}" href="#GeometryOps.intersection_points-Tuple{Any, Any}"><code>GeometryOps.intersection_points</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intersection_points(
    geom_a,
    geom_b,
)::Union{
    ::Vector{::Tuple{::Real, ::Real}},
    ::Nothing,
}</code></pre><p>Return a list of intersection points between two geometries. If no intersection point was possible given geometry extents, return nothing. If none are found, return an empty list.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/intersects.jl#L242-L254">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.intersection_points-Tuple{GeoInterface.AbstractTrait, Any, GeoInterface.AbstractTrait, Any}" href="#GeometryOps.intersection_points-Tuple{GeoInterface.AbstractTrait, Any, GeoInterface.AbstractTrait, Any}"><code>GeometryOps.intersection_points</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intersection_points(
    ::GI.AbstractTrait, geom_a,
    ::GI.AbstractTrait, geom_b,
)::Union{
    ::Vector{::Tuple{::Real, ::Real}},
    ::Nothing,
}</code></pre><p>Calculates the list of intersection points between two geometries, inlcuding line segments, line strings, linear rings, polygons, and multipolygons. If no intersection points were possible given geometry extents, return nothing. If none are found, return an empty list.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/intersects.jl#L258-L271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.intersects-Tuple{Any, Any}" href="#GeometryOps.intersects-Tuple{Any, Any}"><code>GeometryOps.intersects</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intersects(geom1, geom2)::Bool</code></pre><p>Check if two geometries intersect, returning true if so and false otherwise.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">import GeoInterface as GI, GeometryOps as GO

line1 = GI.Line([(124.584961,-12.768946), (126.738281,-17.224758)])
line2 = GI.Line([(123.354492,-15.961329), (127.22168,-14.008696)])
GO.intersects(line1, line2)

# output
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/intersects.jl#L55-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.intersects-Tuple{GeoInterface.AbstractTrait, Any, GeoInterface.AbstractTrait, Any}" href="#GeometryOps.intersects-Tuple{GeoInterface.AbstractTrait, Any, GeoInterface.AbstractTrait, Any}"><code>GeometryOps.intersects</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intersects(::GI.AbstractTrait, a, ::GI.AbstractTrait, b)::Bool</code></pre><p>Returns true if two geometries intersect with one another and false otherwise. For all geometries but lines, convert the geometry to a list of edges and cross compare the edges for intersections.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/intersects.jl#L94-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.intersects-Tuple{GeoInterface.LineTrait, Any, GeoInterface.LineTrait, Any}" href="#GeometryOps.intersects-Tuple{GeoInterface.LineTrait, Any, GeoInterface.LineTrait, Any}"><code>GeometryOps.intersects</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intersects(::GI.LineTrait, a, ::GI.LineTrait, b)::Bool</code></pre><p>Returns true if two line segments intersect and false otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/intersects.jl#L80-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.isclockwise-Tuple{Any}" href="#GeometryOps.isclockwise-Tuple{Any}"><code>GeometryOps.isclockwise</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isclockwise(line::Union{LineString, Vector{Position}})::Bool</code></pre><p>Take a ring and return true or false whether or not the ring is clockwise or counter-clockwise.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">import GeoInterface as GI, GeometryOps as GO

ring = GI.LinearRing([(0, 0), (1, 1), (1, 0), (0, 0)])
GO.isclockwise(ring)

# output
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/bools.jl#L11-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.isconcave-Tuple{Any}" href="#GeometryOps.isconcave-Tuple{Any}"><code>GeometryOps.isconcave</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isconcave(poly::Polygon)::Bool</code></pre><p>Take a polygon and return true or false as to whether it is concave or not.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">import GeoInterface as GI, GeometryOps as GO

poly = GI.Polygon([[(0, 0), (0, 1), (1, 1), (1, 0), (0, 0)]])
GO.isconcave(poly)

# output
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/bools.jl#L43-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.overlaps-Tuple{Any, Any}" href="#GeometryOps.overlaps-Tuple{Any, Any}"><code>GeometryOps.overlaps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">overlaps(geom1, geom2)::Bool</code></pre><p>Compare two Geometries of the same dimension and return true if their intersection set results in a geometry different from both but of the same dimension. This means one geometry cannot be within or contain the other and they cannot be equal</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">import GeometryOps as GO, GeoInterface as GI
poly1 = GI.Polygon([[(0,0), (0,5), (5,5), (5,0), (0,0)]])
poly2 = GI.Polygon([[(1,1), (1,6), (6,6), (6,1), (1,1)]])

GO.overlaps(poly1, poly2)
# output
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/overlaps.jl#L52-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.overlaps-Tuple{GeoInterface.AbstractTrait, Any, GeoInterface.AbstractTrait, Any}" href="#GeometryOps.overlaps-Tuple{GeoInterface.AbstractTrait, Any, GeoInterface.AbstractTrait, Any}"><code>GeometryOps.overlaps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">overlaps(::GI.AbstractTrait, geom1, ::GI.AbstractTrait, geom2)::Bool</code></pre><p>For any non-specified pair, all have non-matching dimensions, return false.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/overlaps.jl#L78-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.overlaps-Tuple{GeoInterface.LineTrait, Any, GeoInterface.LineTrait, Any}" href="#GeometryOps.overlaps-Tuple{GeoInterface.LineTrait, Any, GeoInterface.LineTrait, Any}"><code>GeometryOps.overlaps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">overlaps(::GI.LineTrait, line1, ::GI.LineTrait, line)::Bool</code></pre><p>If the lines overlap, meaning that they are colinear but each have one endpoint outside of the other line, return true. Else false.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/overlaps.jl#L115-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.overlaps-Tuple{GeoInterface.MultiPointTrait, Any, GeoInterface.MultiPointTrait, Any}" href="#GeometryOps.overlaps-Tuple{GeoInterface.MultiPointTrait, Any, GeoInterface.MultiPointTrait, Any}"><code>GeometryOps.overlaps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">overlaps(
    ::GI.MultiPointTrait, points1,
    ::GI.MultiPointTrait, points2,
)::Bool</code></pre><p>If the multipoints overlap, meaning some, but not all, of the points within the multipoints are shared, return true.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/overlaps.jl#L85-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.overlaps-Tuple{GeoInterface.MultiPolygonTrait, Any, GeoInterface.MultiPolygonTrait, Any}" href="#GeometryOps.overlaps-Tuple{GeoInterface.MultiPolygonTrait, Any, GeoInterface.MultiPolygonTrait, Any}"><code>GeometryOps.overlaps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">overlaps(
    ::GI.MultiPolygonTrait, polys1,
    ::GI.MultiPolygonTrait, polys2,
)::Bool</code></pre><p>Return true if at least one pair of polygons from multipolygons overlap. Else false.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/overlaps.jl#L195-L203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.overlaps-Tuple{GeoInterface.MultiPolygonTrait, Any, GeoInterface.PolygonTrait, Any}" href="#GeometryOps.overlaps-Tuple{GeoInterface.MultiPolygonTrait, Any, GeoInterface.PolygonTrait, Any}"><code>GeometryOps.overlaps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">overlaps(
    ::GI.MultiPolygonTrait, polys1,
    ::GI.PolygonTrait, poly2,
)::Bool</code></pre><p>Return true if polygon overlaps with at least one of the polygons within the multipolygon. Else false.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/overlaps.jl#L183-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.overlaps-Tuple{GeoInterface.PolygonTrait, Any, GeoInterface.MultiPolygonTrait, Any}" href="#GeometryOps.overlaps-Tuple{GeoInterface.PolygonTrait, Any, GeoInterface.MultiPolygonTrait, Any}"><code>GeometryOps.overlaps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">overlaps(
    ::GI.PolygonTrait, poly1,
    ::GI.MultiPolygonTrait, polys2,
)::Bool</code></pre><p>Return true if polygon overlaps with at least one of the polygons within the multipolygon. Else false.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/overlaps.jl#L164-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.overlaps-Tuple{GeoInterface.PolygonTrait, Any, GeoInterface.PolygonTrait, Any}" href="#GeometryOps.overlaps-Tuple{GeoInterface.PolygonTrait, Any, GeoInterface.PolygonTrait, Any}"><code>GeometryOps.overlaps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">overlaps(
    trait_a::GI.PolygonTrait, poly_a,
    trait_b::GI.PolygonTrait, poly_b,
)::Bool</code></pre><p>If the two polygons intersect with one another, but are not equal, return true. Else false.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/overlaps.jl#L146-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.overlaps-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.Wrappers.LinearRing}, Any, Union{GeoInterface.LineStringTrait, GeoInterface.Wrappers.LinearRing}, Any}" href="#GeometryOps.overlaps-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.Wrappers.LinearRing}, Any, Union{GeoInterface.LineStringTrait, GeoInterface.Wrappers.LinearRing}, Any}"><code>GeometryOps.overlaps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">overlaps(
    ::Union{GI.LineStringTrait, GI.LinearRing}, line1,
    ::Union{GI.LineStringTrait, GI.LinearRing}, line2,
)::Bool</code></pre><p>If the curves overlap, meaning that at least one edge of each curve overlaps, return true. Else false.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/overlaps.jl#L124-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.point_in_polygon-Tuple{Any, Any}" href="#GeometryOps.point_in_polygon-Tuple{Any, Any}"><code>GeometryOps.point_in_polygon</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">point_in_polygon(point::Point, polygon::Union{Polygon, MultiPolygon}, ignore_boundary::Bool=false)::Bool</code></pre><p>Take a Point and a Polygon and determine if the point resides inside the polygon. The polygon can be convex or concave. The function accounts for holes.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">import GeoInterface as GI, GeometryOps as GO

point = (-77.0, 44.0)
poly = GI.Polygon([[(-81, 41), (-81, 47), (-72, 47), (-72, 41), (-81, 41)]])
GO.point_in_polygon(point, poly)

# output
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/bools.jl#L233-L251">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.point_on_line-Tuple{Any, Any}" href="#GeometryOps.point_on_line-Tuple{Any, Any}"><code>GeometryOps.point_on_line</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">point_on_line(point::Point, line::LineString; ignore_end_vertices::Bool=false)::Bool</code></pre><p>Return true if a point is on a line. Accept a optional parameter to ignore the start and end vertices of the linestring.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">import GeoInterface as GI, GeometryOps as GO

point = (1, 1)
line = GI.LineString([(0, 0), (3, 3), (4, 4)])
GO.point_on_line(point, line)

# output
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/bools.jl#L133-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.polygon_to_line-Tuple{Any}" href="#GeometryOps.polygon_to_line-Tuple{Any}"><code>GeometryOps.polygon_to_line</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">polygon_to_line(poly::Polygon)</code></pre><p>Converts a Polygon to LineString or MultiLineString</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">import GeometryOps as GO, GeoInterface as GI

poly = GI.Polygon([[(-2.275543, 53.464547), (-2.275543, 53.489271), (-2.215118, 53.489271), (-2.215118, 53.464547), (-2.275543, 53.464547)]])
GO.polygon_to_line(poly)
# output
GeoInterface.Wrappers.LineString{false, false, Vector{Tuple{Float64, Float64}}, Nothing, Nothing}([(-2.275543, 53.464547), (-2.275543, 53.489271), (-2.215118, 53.489271), (-2.215118, 53.464547), (-2.275543, 53.464547)], nothing, nothing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/utils.jl#L30-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.polygonize-Tuple{AbstractMatrix}" href="#GeometryOps.polygonize-Tuple{AbstractMatrix}"><code>GeometryOps.polygonize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">polygonize(A; minpoints=10)
polygonize(xs, ys, A; minpoints=10)</code></pre><p>Convert matrix <code>A</code> to polygons.</p><p>If <code>xs</code> and <code>ys</code> are passed in they are used as the pixel center points.</p><p><strong>Keywords</strong></p><ul><li><code>minpoints</code>: ignore polygons with less than <code>minpoints</code> points. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/polygonize.jl#L54-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.rebuild-Tuple{Any, Any}" href="#GeometryOps.rebuild-Tuple{Any, Any}"><code>GeometryOps.rebuild</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rebuild(geom, child_geoms)</code></pre><p>Rebuild a geometry from child geometries.</p><p>By default geometries will be rebuilt as a <code>GeoInterface.Wrappers</code> geometry, but <code>rebuild</code> can have methods added to it to dispatch on geometries from other packages and specify how to rebuild them.</p><p>(Maybe it should go into GeoInterface.jl)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/primitives.jl#L316-L326">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.reconstruct-Tuple{Any, Any}" href="#GeometryOps.reconstruct-Tuple{Any, Any}"><code>GeometryOps.reconstruct</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reconstruct(geom, components)</code></pre><p>Reconstruct <code>geom</code> from an iterable of component objects that match its structure.</p><p>All objects in <code>components</code> must have the same <code>GeoInterface.trait</code>.</p><p>Ususally used in combination with <code>flatten</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/primitives.jl#L253-L261">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.reproject-Tuple{Any}" href="#GeometryOps.reproject-Tuple{Any}"><code>GeometryOps.reproject</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reproject(geometry; source_crs, target_crs, transform, always_xy, time)
reproject(geometry, source_crs, target_crs; always_xy, time)
reproject(geometry, transform; always_xy, time)</code></pre><p>Reproject any GeoInterface.jl compatible <code>geometry</code> from <code>source_crs</code> to <code>target_crs</code>.</p><p>The returned object will be constructed from <code>GeoInterface.WrapperGeometry</code> geometries, wrapping views of a <code>Vector{Proj.Point{D}}</code>, where <code>D</code> is the dimension.</p><p><strong>Arguments</strong></p><ul><li><code>geometry</code>: Any GeoInterface.jl compatible geometries.</li><li><code>source_crs</code>: the source coordinate referece system, as a GeoFormatTypes.jl object or a string.</li><li><code>target_crs</code>: the target coordinate referece system, as a GeoFormatTypes.jl object or a string.</li></ul><p>If these a passed as keywords, <code>transform</code> will take priority. Without it <code>target_crs</code> is always needed, and <code>source_crs</code> is needed if it is not retreivable from the geometry with <code>GeoInterface.crs(geometry)</code>.</p><p><strong>Keywords</strong></p><ul><li><code>always_xy</code>: force x, y coordinate order, <code>true</code> by default.   <code>false</code> will expect and return points in the crs coordinate order.</li><li><code>time</code>: the time for the coordinates. <code>Inf</code> by default.</li><li><code>threaded</code>: <code>true</code> or <code>false</code>. Whether to use multithreading. Defaults to <code>false</code>.</li><li><code>crs</code>: The CRS to attach to geometries. Defaults to <code>nothing</code>.</li><li><code>calc_extent</code>: <code>true</code> or <code>false</code>. Whether to calculate the extent. Defaults to <code>false</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/transformations/reproject.jl#L11-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.signed_area-Tuple{Any}" href="#GeometryOps.signed_area-Tuple{Any}"><code>GeometryOps.signed_area</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">signed_area(geom)::Real</code></pre><p>Returns the signed area of the geometry, based on winding order. This is computed slighly differently for different geometries:     - The signed area of a point is always zero.     - The signed area of a curve is always zero.     - The signed area of a polygon is computed with the shoelace formula and is     positive if the polygon coordinates wind clockwise and negative if     counterclockwise.     - You cannot compute the signed area of a multipolygon as it doesn&#39;t have a     meaning as each sub-polygon could have a different winding order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/area.jl#L58-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.signed_distance-Tuple{Any, Any}" href="#GeometryOps.signed_distance-Tuple{Any, Any}"><code>GeometryOps.signed_distance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">signed_distance(point, geom)::Real</code></pre><p>Calculates the signed distance from the geometry <code>geom</code> to the given point. Points within <code>geom</code> have a negative signed distance, and points outside of <code>geom</code> have a positive signed distance.     - The signed distance from a point to a point, line, linestring, or linear     ring is equal to the distance between the two.     - The signed distance from a point to a polygon is negative if the point is     within the polygon and is positive otherwise. The value of the distance is     the minimum distance from the point to an edge of the polygon. This includes     edges created by holes.     - The signed distance from a point to a mulitpolygon is negative if the     point is within one of the polygons that make up the multipolygon and is     positive otherwise. The value of the distance is the minimum distance from     the point to an edge of the multipolygon. This includes edges created by     holes of the polygons as well.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/distance.jl#L86-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.simplify-Tuple{Any}" href="#GeometryOps.simplify-Tuple{Any}"><code>GeometryOps.simplify</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">simplify(obj; kw...)
simplify(::SimplifyAlg, obj; kw...)</code></pre><p>Simplify a geometry, feature, feature collection,  or nested vectors or a table of these.</p><p><a href="#GeometryOps.RadialDistance"><code>RadialDistance</code></a>, <a href="#GeometryOps.DouglasPeucker"><code>DouglasPeucker</code></a>, or  <a href="#GeometryOps.VisvalingamWhyatt"><code>VisvalingamWhyatt</code></a> algorithms are available,  listed in order of increasing quality but decreaseing performance.</p><p><code>PoinTrait</code> and <code>MultiPointTrait</code> are returned unchanged.</p><p>The default behaviour is <code>simplify(DouglasPeucker(; kw...), obj)</code>. Pass in other <a href="#GeometryOps.SimplifyAlg"><code>SimplifyAlg</code></a> to use other algorithms.</p><p><strong>Keywords</strong></p><ul><li><code>threaded</code>: <code>true</code> or <code>false</code>. Whether to use multithreading. Defaults to <code>false</code>.</li><li><code>crs</code>: The CRS to attach to geometries. Defaults to <code>nothing</code>.</li><li><code>calc_extent</code>: <code>true</code> or <code>false</code>. Whether to calculate the extent. Defaults to <code>false</code>.</li></ul><p>Keywords for DouglasPeucker are allowed when no algorithm is specified:</p><p><strong>Keywords</strong></p><ul><li><code>ratio</code>: the fraction of points that should remain after <code>simplify</code>.    Useful as it will generalise for large collections of objects.</li><li><code>number</code>: the number of points that should remain after <code>simplify</code>.   Less useful for large collections of mixed size objects.</li></ul><p><strong>Example</strong></p><p>Simplify a polygon to have six points:</p><pre><code class="language-julia hljs">import GeoInterface as GI
import GeometryOps as GO

poly = GI.Polygon([[
    [-70.603637, -33.399918],
    [-70.614624, -33.395332],
    [-70.639343, -33.392466],
    [-70.659942, -33.394759],
    [-70.683975, -33.404504],
    [-70.697021, -33.419406],
    [-70.701141, -33.434306],
    [-70.700454, -33.446339],
    [-70.694274, -33.458369],
    [-70.682601, -33.465816],
    [-70.668869, -33.472117],
    [-70.646209, -33.473835],
    [-70.624923, -33.472117],
    [-70.609817, -33.468107],
    [-70.595397, -33.458369],
    [-70.587158, -33.442901],
    [-70.587158, -33.426283],
    [-70.590591, -33.414248],
    [-70.594711, -33.406224],
    [-70.603637, -33.399918]]])

simple = GO.simplify(poly; number=6)
GI.npoint(simple)

# output
6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/transformations/simplify.jl#L50-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.t_value-Union{Tuple{T2}, Tuple{T1}, Tuple{N}, Tuple{Union{Tuple{Vararg{T1, N}}, StaticArraysCore.StaticArray{Tuple{N}, T1, 1}}, Union{Tuple{Vararg{T1, N}}, StaticArraysCore.StaticArray{Tuple{N}, T1, 1}}, T2, T2}} where {N, T1&lt;:Real, T2&lt;:Real}" href="#GeometryOps.t_value-Union{Tuple{T2}, Tuple{T1}, Tuple{N}, Tuple{Union{Tuple{Vararg{T1, N}}, StaticArraysCore.StaticArray{Tuple{N}, T1, 1}}, Union{Tuple{Vararg{T1, N}}, StaticArraysCore.StaticArray{Tuple{N}, T1, 1}}, T2, T2}} where {N, T1&lt;:Real, T2&lt;:Real}"><code>GeometryOps.t_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">t_value(sᵢ, sᵢ₊₁, rᵢ, rᵢ₊₁)</code></pre><p>Returns the &quot;T-value&quot; as described in Hormann&#39;s presentation <sup class="footnote-reference"><a id="citeref-HormannPresentation" href="#footnote-HormannPresentation">[HormannPresentation]</a></sup> on how to calculate the mean-value coordinate.  </p><p>Here, <code>sᵢ</code> is the vector from vertex <code>vᵢ</code> to the point, and <code>rᵢ</code> is the norm (length) of <code>sᵢ</code>. <code>s</code> must be <code>Point</code> and <code>r</code> must be real numbers.</p><p class="math-container">\[tᵢ = \frac{\mathrm{det}\left(sᵢ, sᵢ₊₁\right)}{rᵢ * rᵢ₊₁ + sᵢ ⋅ sᵢ₊₁}\]</p><p>```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/barycentric.jl#L246-L262">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.to_edges-Tuple{Any}" href="#GeometryOps.to_edges-Tuple{Any}"><code>GeometryOps.to_edges</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to_edges()</code></pre><p>Convert any geometry or collection of geometries into a flat  vector of <code>Tuple{Tuple{Float64,Float64},Tuple{Float64,Float64}}</code> edges.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/utils.jl#L53-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.tuples-Tuple{Any}" href="#GeometryOps.tuples-Tuple{Any}"><code>GeometryOps.tuples</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tuples(obj)</code></pre><p>Convert all points in <code>obj</code> to <code>Tuple</code>s, wherever the are nested.</p><p>Returns a similar object or collection of objects using GeoInterface.jl geometries wrapping <code>Tuple</code> points.</p><p><strong>Keywords</strong></p><ul><li><code>threaded</code>: <code>true</code> or <code>false</code>. Whether to use multithreading. Defaults to <code>false</code>.</li><li><code>crs</code>: The CRS to attach to geometries. Defaults to <code>nothing</code>.</li><li><code>calc_extent</code>: <code>true</code> or <code>false</code>. Whether to calculate the extent. Defaults to <code>false</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/transformations/tuples.jl#L3-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.unwrap" href="#GeometryOps.unwrap"><code>GeometryOps.unwrap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unwrap(target::Type{&lt;:AbstractTrait}, obj)
unwrap(f, target::Type{&lt;:AbstractTrait}, obj)</code></pre><p>Unwrap the object newst to vectors, down to the target trait.</p><p>If <code>f</code> is passed in it will be applied to the target geometries as they are found.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/primitives.jl#L184-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.weighted_mean-Union{Tuple{WT}, Tuple{WT, Any, Any}} where WT&lt;:Real" href="#GeometryOps.weighted_mean-Union{Tuple{WT}, Tuple{WT, Any, Any}} where WT&lt;:Real"><code>GeometryOps.weighted_mean</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">weighted_mean(weight::Real, x1, x2)</code></pre><p>Returns the weighted mean of <code>x1</code> and <code>x2</code>, where <code>weight</code> is the weight of <code>x1</code>.</p><p>Specifically, calculates <code>x1 * weight + x2 * (1 - weight)</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The idea for this method is that you can override this for custom types, like Color types, in extension modules.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/f8eebf1cb9616e359678e791dd4989bc60878716/src/methods/barycentric.jl#L203-L212">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-HormannPresentation"><a class="tag is-link" href="#citeref-HormannPresentation">HormannPresentation</a>K. Hormann and N. Sukumar. Generalized Barycentric Coordinates in Computer Graphics and Computational Mechanics. Taylor &amp; Fancis, CRC Press, 2017.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="source/GeometryOps/">GeometryOps.jl »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 28 December 2023 14:02">Thursday 28 December 2023</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
