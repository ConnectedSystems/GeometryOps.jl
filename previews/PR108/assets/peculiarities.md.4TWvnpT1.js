import{_ as e,c as a,o as t,a7 as o}from"./chunks/framework.q4yaR_RB.js";const _=JSON.parse('{"title":"Peculiarities","description":"","frontmatter":{},"headers":[],"relativePath":"peculiarities.md","filePath":"peculiarities.md","lastUpdated":null}'),r={name:"peculiarities.md"},i=o('<h1 id="Peculiarities" tabindex="-1">Peculiarities <a class="header-anchor" href="#Peculiarities" aria-label="Permalink to &quot;Peculiarities {#Peculiarities}&quot;">​</a></h1><h2 id="_True-and-_False-(or-BoolsAsTypes)" tabindex="-1"><code>_True</code> and <code>_False</code> (or <code>BoolsAsTypes</code>) <a class="header-anchor" href="#_True-and-_False-(or-BoolsAsTypes)" aria-label="Permalink to &quot;`_True` and `_False` (or `BoolsAsTypes`) {#_True-and-_False-(or-BoolsAsTypes)}&quot;">​</a></h2><p>When dispatch can be controlled by the value of a boolean variable, this introduces type instability. Instead of introducing type instability, we chose to encode our boolean decision variables, like <code>threaded</code> and <code>calc_extent</code> in <code>apply</code>, as types. This allows the compiler to reason about what will happen, and call the correct compiled method, in a stable way without worrying about</p><h2 id="What-does-apply-return-and-why?" tabindex="-1">What does <code>apply</code> return and why? <a class="header-anchor" href="#What-does-apply-return-and-why?" aria-label="Permalink to &quot;What does `apply` return and why? {#What-does-apply-return-and-why?}&quot;">​</a></h2><p><code>apply</code> returns the target geometries returned by <code>f</code>, whatever type/package they are from, but geometries, features or feature collections that wrapped the target are replaced with GeoInterace.jl wrappers with matching <code>GeoInterface.trait</code> to the originals. All non-geointerface iterables become <code>Array</code>s. Tables.jl compatible tables are converted either back to the original type if a <code>Tables.materializer</code> is defined, and if not then returned as generic <code>NamedTuple</code> column tables (i.e., a NamedTuple of vectors).</p><p>It is recommended for consistency that <code>f</code> returns GeoInterface geometries unless there is a performance/conversion overhead to doing that.</p><h2 id="Why-do-you-want-me-to-provide-a-target-in-set-operations?" tabindex="-1">Why do you want me to provide a <code>target</code> in set operations? <a class="header-anchor" href="#Why-do-you-want-me-to-provide-a-target-in-set-operations?" aria-label="Permalink to &quot;Why do you want me to provide a `target` in set operations? {#Why-do-you-want-me-to-provide-a-target-in-set-operations?}&quot;">​</a></h2><p>@skygering</p><p>Mainly type stability reasons.</p>',9),s=[i];function n(d,c,l,p,h,u){return t(),a("div",null,s)}const m=e(r,[["render",n]]);export{_ as __pageData,m as default};
