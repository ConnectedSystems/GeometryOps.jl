<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Barycentric coordinates · GeometryOps.jl</title><script data-outdated-warner src="../../../assets/warner.js"></script><link rel="canonical" href="https://asinghvi17.github.io/GeometryOps.jl/source/methods/barycentric/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">GeometryOps.jl</a></span></div><form class="docs-search" action="../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">Source code</span><ul><li><a class="tocitem" href="../../GeometryOps/">-</a></li><li><a class="tocitem" href="../../GeometryOps.jl.2669/">-</a></li><li><a class="tocitem" href="../../primitives/">-</a></li><li class="is-active"><a class="tocitem" href>Barycentric coordinates</a><ul class="internal"><li><a class="tocitem" href="#Barycentric-coordinate-API"><span>Barycentric-coordinate API</span></a></li><li><a class="tocitem" href="#Example"><span>Example</span></a></li></ul></li><li><a class="tocitem" href="../centroid/">-</a></li><li><a class="tocitem" href="../contains/">-</a></li><li><a class="tocitem" href="../signed_area/">Signed area</a></li><li><a class="tocitem" href="../signed_distance/">Signed distance</a></li><li><a class="tocitem" href="../../transformations/flip/">-</a></li><li><a class="tocitem" href="../../transformations/reproject/">-</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Source code</a></li><li class="is-active"><a href>Barycentric coordinates</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Barycentric coordinates</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/asinghvi17/GeometryOps.jl/blob/main/docs/src/source/methods/barycentric.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Barycentric-coordinates"><a class="docs-heading-anchor" href="#Barycentric-coordinates">Barycentric coordinates</a><a id="Barycentric-coordinates-1"></a><a class="docs-heading-anchor-permalink" href="#Barycentric-coordinates" title="Permalink"></a></h1><p>Generalized barycentric coordinates are a generalization of barycentric coordinates, which are typically used in triangles, to arbitrary polygons.</p><p>They provide a way to express a point within a polygon as a weighted average of the polygon&#39;s vertices.</p><p>In the case of a triangle, barycentric coordinates are a set of three numbers <span>$(λ_1, λ_2, λ_3)$</span>, each associated with a vertex of the triangle. Any point within the triangle can be expressed as a weighted average of the vertices, where the weights are the barycentric coordinates. The weights sum to 1, and each is non-negative.</p><p>For a polygon with <span>$n$</span> vertices, generalized barycentric coordinates are a set of <span>$n$</span> numbers <span>$(λ_1, λ_2, ..., λ_n)$</span>, each associated with a vertex of the polygon. Any point within the polygon can be expressed as a weighted average of the vertices, where the weights are the generalized barycentric coordinates.</p><p>As with the triangle case, the weights sum to 1, and each is non-negative.</p><h2 id="Barycentric-coordinate-API"><a class="docs-heading-anchor" href="#Barycentric-coordinate-API">Barycentric-coordinate API</a><a id="Barycentric-coordinate-API-1"></a><a class="docs-heading-anchor-permalink" href="#Barycentric-coordinate-API" title="Permalink"></a></h2><p>In most cases, we actually want barycentric interpolation and have no interest in the coordinates themselves.  However, the coordinates can be useful for debugging, and so we provide an API for computing them as well.</p><pre><code class="language-julia hljs">&quot;&quot;&quot;
    abstract type AbstractBarycentricCoordinateMethod

Abstract supertype for barycentric coordinate methods.
The subtypes may serve as dispatch types, or may cache
some information about the target polygon.

# API
The following methods must be implemented for all subtypes:
- `barycentric_coordinates!(λs::Vector{&lt;: Real}, method::AbstractBarycentricCoordinateMethod, polypoints::Vector{&lt;: Point{N1, T1}}, point::Point{N2, T2})`
&quot;&quot;&quot;
abstract type AbstractBarycentricCoordinateMethod end


Base.@propagate_inbounds function barycentric_coordinates!(λs::Vector{&lt;: Real}, method::AbstractBarycentricCoordinateMethod, polypoints::AbstractVector{&lt;: Point{N1, T1}}, point::Point{N2, T2}) where {N1, N2, T1 &lt;: Real, T2 &lt;: Real}
    @boundscheck @assert length(λs) == length(polypoints)
    @boundscheck @assert length(polypoints) &gt;= 3

    @error(&quot;Not implemented yet for method $(method).&quot;)
end

Base.@propagate_inbounds function barycentric_coordinates(method::AbstractBarycentricCoordinateMethod, polypoints::AbstractVector{&lt;: Point{N1, T1}}, point::Point{N2, T2}) where {N1, N2, T1 &lt;: Real, T2 &lt;: Real}
    λs = zeros(promote_type(T1, T2), length(polypoints))
    barycentric_coordinates!(λs, method, polypoints, point)
    return λs
end

Base.@propagate_inbounds function barycentric_interpolate(method::AbstractBarycentricCoordinateMethod, polypoints::AbstractVector{&lt;: Point{N, T1}}, values::AbstractVector{V}, point::Point{N, T2}) where {N, T1 &lt;: Real, T2 &lt;: Real, V}
    @boundscheck @assert length(values) == length(polypoints)
    @boundscheck @assert length(polypoints) &gt;= 3
    λs = barycentric_coordinates(method, polypoints, point)
    return sum(λs .* values)
end



struct MeanValue &lt;: AbstractBarycentricCoordinateMethod
end

struct Wachspress &lt;: AbstractBarycentricCoordinateMethod
end</code></pre><p>function mean<em>value</em>barycentric_coordinates(::PolygonTrait, ::PointTrait, )</p><h2 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h2><p>This example was taken from <a href="https://doc.cgal.org/latest/Barycentric_coordinates_2/index.html">this page of CGAL&#39;s documentation</a>.</p><pre><code class="language- hljs">
````julia
using GeometryBasics, GeometryOps, Makie
polygon_points = Point3f[
(0.03, 0.05, 0.00), (0.07, 0.04, 0.02), (0.10, 0.04, 0.04),
(0.14, 0.04, 0.06), (0.17, 0.07, 0.08), (0.20, 0.09, 0.10),
(0.22, 0.11, 0.12), (0.25, 0.11, 0.14), (0.27, 0.10, 0.16),
(0.30, 0.07, 0.18), (0.31, 0.04, 0.20), (0.34, 0.03, 0.22),
(0.37, 0.02, 0.24), (0.40, 0.03, 0.26), (0.42, 0.04, 0.28),
(0.44, 0.07, 0.30), (0.45, 0.10, 0.32), (0.46, 0.13, 0.34),
(0.46, 0.19, 0.36), (0.47, 0.26, 0.38), (0.47, 0.31, 0.40),
(0.47, 0.35, 0.42), (0.45, 0.37, 0.44), (0.41, 0.38, 0.46),
(0.38, 0.37, 0.48), (0.35, 0.36, 0.50), (0.32, 0.35, 0.52),
(0.30, 0.37, 0.54), (0.28, 0.39, 0.56), (0.25, 0.40, 0.58),
(0.23, 0.39, 0.60), (0.21, 0.37, 0.62), (0.21, 0.34, 0.64),
(0.23, 0.32, 0.66), (0.24, 0.29, 0.68), (0.27, 0.24, 0.70),
(0.29, 0.21, 0.72), (0.29, 0.18, 0.74), (0.26, 0.16, 0.76),
(0.24, 0.17, 0.78), (0.23, 0.19, 0.80), (0.24, 0.22, 0.82),
(0.24, 0.25, 0.84), (0.21, 0.26, 0.86), (0.17, 0.26, 0.88),
(0.12, 0.24, 0.90), (0.07, 0.20, 0.92), (0.03, 0.15, 0.94),
(0.01, 0.10, 0.97), (0.02, 0.07, 1.00)]
using MakieThemes
Makie.set_theme!(MakieThemes.bbc())
f, a, p = poly(polygon_points; color = last.(polygon_points), colormap = cgrad(:jet, 18; categorical = true), shading = false, axis = (; aspect = DataAspect(), title = &quot;Makie mesh based polygon rendering&quot;, subtitle = &quot;Makie&quot;))
cb = Colorbar(f[1, 2], p.plots[1])
hidedecorations!(a)
f
ax_bbox = a.finallimits[]
ext = GeoInterface.Extent(NamedTuple{(:X, :Y)}(zip(minimum(ax_bbox), maximum(ax_bbox))))
poly_rast = Rasters.rasterize(GeometryBasics.Polygon(Point2f.(polygon_points)); ext = ext, size = tuple(round.(Int, widths(a.scene.px_area[]))...), fill = RGBAf(0,0,0,0))
@time mean_value_coordinate_field = hormann_mean_value_coordinates.(
    (Point2f.(polygon_points),),
    Point2f.(collect(poly_rast.dims[1]), collect(poly_rast.dims[2])&#39;)
)
zs = last.(polygon_points)
mean_values = map(mean_value_coordinate_field) do λs
    sum(λs .* zs)
end

@time mean_values = hormann_mean_value_interpolation.(
    (Point2f.(polygon_points),),
    (zs,),
    Point2f.(collect(poly_rast.dims[1]), collect(poly_rast.dims[2])&#39;)
)
fig, ax, mvplt = heatmap(collect(poly_rast.dims[1]), collect(poly_rast.dims[2]), mean_values; colormap = cgrad(:jet, 18; categorical = true), axis = (; aspect = DataAspect(), title = &quot;Barycentric coordinate based rendering&quot;, subtitle = &quot;Mean value method&quot;), colorrange = Makie.distinct_extrema_nan(zs))
hidedecorations!(ax)
cb = Colorbar(fig[1, 2], mvplt)
poly!(ax, GeometryBasics.Polygon(Point2f[(ext.X[1], ext.Y[1]), (ext.X[2], ext.Y[1]), (ext.X[2], ext.Y[2]), (ext.X[1], ext.Y[2]), (ext.X[1], ext.Y[1])], [reverse(Point2f.(polygon_points))]); color = :white, xautolimits = false, yautolimits = false)
fig
````
</code></pre><p>You can see that the polygon triangulation doesn&#39;t do any justice to the actual structure.  Let&#39;s visualize it using mean value coordinates:</p><pre><code class="language- hljs">polygon_zs = last.(polygon_points)
xrange = LinRange(0, 0.5, 1000)
yrange = LinRange(0, 0.5, 1000)
@benchmark mean_value_coordinate_field = mean_value_barycentric_coordinates.(
    (GeometryBasics.Polygon(Point2f.(polygon_points)),),
    Point2f.(xrange, yrange&#39;)
)
# @time mean_value_coordinate_field_threadsx = ThreadsX.map(Point2{Float64}.(xrange, yrange&#39;)) do p
#     mean_value_barycentric_coordinates(polygon_points, p)
# end # 7s v/s 2s for serial processing...why?</code></pre><p>This returned a list of vectors of weights, one for each point in the grid.</p><p>We can use these vectors to extrapolate and interpolate from the z values of the polygon to some z value at each point in the grid:</p><pre><code class="language- hljs">mean_values = map(mean_value_coordinate_field) do λs
    sum(λs .* polygon_zs)
end</code></pre><p>Now, we can visualize this!</p><pre><code class="language- hljs">f, a, p = heatmap(xrange, yrange, mean_values; colormap = cgrad(:jet, 18; categorical = true), axis = (; aspect = DataAspect()))
poly!(Point2f.(polygon_points); color = :transparent, strokecolor = :black, strokewidth = 1.3)
Colorbar(f[1, 2], p)
f</code></pre><pre><code class="language- hljs">
````julia
n = 200
angles = range(0, 2pi, length = n)[1:end-1]
x_ext = 2 .* cos.(angles .+ pi/n)
y_ext = 2 .* sin.(angles .+ pi/n)
x_int = cos.(angles)
y_int = sin.(angles)
z_ext = (x_ext .- 0.5).^2 + (y_ext .- 0.5).^2 .+ 0.05.*randn.()
z_int = (x_int .- 0.5).^2 + (y_int .- 0.5).^2 .+ 0.05.*randn.()
z = vcat(z_ext, z_int)
circ_poly = Polygon(Point2f.(x_ext, y_ext), [Point2f.(x_int, y_int)])
circ_poly = Polygon(Point{3, Float64}.(polygon_points))
ext = GeoInterface.extent(circ_poly)
xrange = LinRange(ext.X..., 1000) .|&gt; Float64
yrange = LinRange(ext.Y..., 1000) .|&gt; Float64
@time mean_value_coordinate_field = hormann_mean_value_interpolation.(
    (circ_poly,),
    (z,),
    Point2f.(xrange, yrange&#39;)
)
itp_xs = [xrange[i] for i in 1:length(xrange), j in 1:length(yrange)]
itp_ys = [yrange[j] for i in 1:length(xrange), j in 1:length(yrange)]
vals = itp(vec(itp_xs), vec(itp_ys); method = NaturalNeighbours.Sibson(1))
heatmap(xrange, yrange, reshape(vals, (length(xrange), length(yrange))); colormap = cgrad(:jet, 18; categorical = true), axis = (; aspect = DataAspect(), title = &quot;NaturalNeighbours.jl Laplace interpolation&quot;))
poly!(Point2f.(polygon_points); color = :transparent, strokecolor = :black, strokewidth = 1.3)
Colorbar(Makie.current_figure()[1, 2], Makie.current_axis().scene.plots[1])
Makie.current_figure()
itp = NaturalNeighbours.interpolate(vcat(x_ext, x_int), vcat(y_ext, y_int), z; derivatives = true)
itp_xs = [xrange[i] for i in 1:length(xrange), j in 1:length(yrange)]
itp_ys = [yrange[j] for i in 1:length(xrange), j in 1:length(yrange)]
vals = itp(vec(itp_xs), vec(itp_ys); method = NaturalNeighbours.Laplace())
heatmap(xrange, yrange, reshape(vals, (length(xrange), length(yrange))); axis = (; aspect = DataAspect(), title = &quot;NaturalNeighbours.jl Laplace interpolation&quot;))
mean_values = ThreadsX.map(mean_value_coordinate_field) do λs
    sum(λs .* z)
end

function NaturalNeighbours.interpolate(points::AbstractVector{&lt;: Point{2, T1}}, zs::AbstractVector{T2}; kwargs...) where {T1 &lt;: Real, T2 &lt;: Real}
    return NaturalNeighbours.interpolate(getindex.(points, 1), getindex.(points, 2), zs; kwargs...)
end

function NaturalNeighbours.interpolate(points::AbstractVector{&lt;: Point{3, T}}; kwargs...) where {T &lt;: Real}
    return NaturalNeighbours.interpolate(getindex.(points, 1), getindex.(points, 2), getindex.(points, 3); kwargs...)
end

function NaturalNeighbours.interpolate(poly::Polygon{3, T}; kwargs...) where {T &lt;: Real}
````

Decompose the exterior and interiors of the polygon into a list of points

````julia
    poly_ext_points = decompose(Point{3, T}, poly.exterior)
    poly_int_points = decompose.((Point{3, T},), poly.interiors)
    final_point_list = Point{3, T}[]
````

If the exterior or interior points are closed, we need to remove the last point,
to avoid degeneracy and duplicate points.

````julia
    if poly_ext_points[end] == poly_ext_points[begin]
        append!(final_point_list, @view(poly_ext_points[begin:end-1]))
    else
        append!(final_point_list, poly_ext_points)
    end
    for hole in poly_int_points
        if hole[end] == hole[begin]
            append!(final_point_list, @view(hole[begin:end-1]))
        else
            append!(final_point_list, hole)
        end
    end
    return NaturalNeighbours.interpolate(final_point_list; kwargs...)
end
````

f, a, p = heatmap(xrange, yrange, mean_values; colormap = :viridis, axis = (; aspect = DataAspect()))
poly!(a, circ_poly; color = :transparent, strokecolor = :black, strokewidth = 1.3)
f</code></pre><pre><code class="nohighlight hljs">x = randn(50)
y = randn(50)
z = -sqrt.(x .^ 2 .+ y .^ 2) .+ 0.1 .* randn.()

xrange = LinRange(ext.X..., 1000)
yrange = LinRange(ext.Y..., 1000)
@time mean_value_coordinate_field = mean_value_barycentric_coordinates.(
    (Point2f.(x, y),),
    Point2f.(xrange, yrange&#39;)
)

mean_values = ThreadsX.map(mean_value_coordinate_field) do λs
    sum(λs .* z)
end

contour(getindex.(λs, 2))
heatmap(mean_values)</code></pre><pre><code class="language-julia hljs">xs = randn(100)
ys = randn(100)
zs = sin.(xs) .* cos.(ys)

itp = NaturalNeighbours.interpolate(xs, ys, zs; derivatives = true)
xrange = LinRange(-3, 3, 1000) .|&gt; Float32
yrange = LinRange(-3, 3, 1000) .|&gt; Float32
itp_xs = [xrange[i] for i in 1:length(xrange), j in 1:length(yrange)]
itp_ys = [yrange[j] for i in 1:length(xrange), j in 1:length(yrange)]
vals = itp(vec(itp_xs), vec(itp_ys); method = NaturalNeighbours.Sibson(1))
heatmap(xrange, yrange, reshape(vals, (length(xrange), length(yrange))))
scatter!(xs, ys)
Makie.current_figure()

&quot;&quot;&quot;
    _det(s1::Point2{T1}, s2::Point2{T2}) where {T1 &lt;: Real, T2 &lt;: Real}

Returns the determinant of the matrix formed by the two points `s1` and `s2`.
Specifically, this is:
```julia
s1[1] * s2[2] - s1[2] * s2[1]
```
&quot;&quot;&quot;
function _det(s1::Point2{T1}, s2::Point2{T2}) where {T1 &lt;: Real, T2 &lt;: Real}
    return s1[1] * s2[2] - s1[2] * s2[1]
end

&quot;&quot;&quot;
    t_value(sᵢ, sᵢ₊₁, rᵢ, rᵢ₊₁)

Returns the &quot;T-value&quot; as described in Hormann&#39;s presentation on how to calculate
the mean-value coordinate.

See `hormann_mean_value_interpolation` for more details.
&quot;&quot;&quot;
function t_value(sᵢ, sᵢ₊₁, rᵢ, rᵢ₊₁)
    return _det(sᵢ, sᵢ₊₁) / muladd(rᵢ, rᵢ₊₁, dot(sᵢ, sᵢ₊₁))
end

&quot;&quot;&quot;
    hormann_mean_value_coordinates(points::AbstractVector{&lt;: Point2}, point::Point2)::Vector

Returns a vector of the length of `points`, containing the mean value coordinates of `point` with respect to `points`.</code></pre><p>Arguments</p><pre><code class="language-julia hljs">- `points::AbstractVector{&lt;: Point{2, T1}}`: A vector of points defining a polygon.  The end point should not repeat.
- `point::Point{2, T2}`: The point to compute the mean value coordinates for.

&quot;&quot;&quot;
function hormann_mean_value_coordinates(points::AbstractVector{&lt;: Point{2, T1}}, point::Point{2, T2}) where {T1 &lt;: Real, T2 &lt;: Real}</code></pre><p>First, allocate the output array.</p><pre><code class="language-julia hljs">    n_points = length(points)
    NumType = promote_type(T1, T2)
    λs = zeros(NumType, n_points)
    sᵢ₋₁ = points[end] - point
    sᵢ   = points[begin] - point
    sᵢ₊₁ = points[begin+1] - point
    rᵢ₋₁ = norm(sᵢ₋₁) # radius / Euclidean distance between points.
    rᵢ   = norm(sᵢ  ) # radius / Euclidean distance between points.
    rᵢ₊₁ = norm(sᵢ₊₁) # radius / Euclidean distance between points.

    λs[1] = (t_value(sᵢ₋₁, sᵢ, rᵢ₋₁, rᵢ) + t_value(sᵢ, sᵢ₊₁, rᵢ, rᵢ₊₁)) / rᵢ

    for i in 2:n_points</code></pre><p>Increment counters + set variables</p><pre><code class="language-julia hljs">        sᵢ₋₁ = sᵢ
        sᵢ   = sᵢ₊₁
        sᵢ₊₁ = points[mod1(i+1, n_points)] - point
        rᵢ₋₁ = rᵢ
        rᵢ   = rᵢ₊₁
        rᵢ₊₁ = norm(sᵢ₊₁) # radius / Euclidean distance between points.
        λs[i] = (t_value(sᵢ₋₁, sᵢ, rᵢ₋₁, rᵢ) + t_value(sᵢ, sᵢ₊₁, rᵢ, rᵢ₊₁)) / rᵢ
    end
    λs ./= sum(λs)
    return λs
end

function hormann_mean_value_interpolation(points::AbstractVector{&lt;: Point{2, T1}}, values::AbstractVector{T2}, point::Point{2, T3}) where {T1 &lt;: Real, T2, T3 &lt;: Real}
    n_points = length(points)
    sᵢ₋₁ = points[end] - point
    sᵢ   = points[begin] - point
    sᵢ₊₁ = points[begin+1] - point
    rᵢ₋₁ = norm(sᵢ₋₁) # radius / Euclidean distance between points.
    rᵢ   = norm(sᵢ  ) # radius / Euclidean distance between points.
    rᵢ₊₁ = norm(sᵢ₊₁) # radius / Euclidean distance between points.</code></pre><p>Now, we set the interpolated value to the first point&#39;s value, multiplied by the weight computed relative to the first point in the polygon.</p><pre><code class="language-julia hljs">    wᵢ = (t_value(sᵢ₋₁, sᵢ, rᵢ₋₁, rᵢ) + t_value(sᵢ, sᵢ₊₁, rᵢ, rᵢ₊₁)) / rᵢ
    wₜₒₜ = wᵢ
    interpolated_value = values[begin] * wᵢ
    for i in 2:n_points</code></pre><p>Increment counters + set variables</p><pre><code class="language-julia hljs">        sᵢ₋₁ = sᵢ
        sᵢ   = sᵢ₊₁
        sᵢ₊₁ = points[mod1(i+1, n_points)] - point
        rᵢ₋₁ = rᵢ
        rᵢ   = rᵢ₊₁
        rᵢ₊₁ = norm(sᵢ₊₁) # radius / Euclidean distance between points.
        wᵢ = (t_value(sᵢ₋₁, sᵢ, rᵢ₋₁, rᵢ) + t_value(sᵢ, sᵢ₊₁, rᵢ, rᵢ₊₁)) / rᵢ
        wₜₒₜ += wᵢ
        interpolated_value += values[i] * wᵢ
    end
    interpolated_value /= wₜₒₜ
    return interpolated_value
end

function hormann_mean_value_interpolation(poly::GeometryBasics.Polygon{2, T1}, values::AbstractVector{T2}, point::Point{2, T3}) where {T1 &lt;: Real, T2, T3 &lt;: Real}
    ext = decompose(Point{2, T2}, poly.exterior)
    ints = decompose.((Point{2, T2},), poly.interiors)
    current_index = 1
    l_ext = length(ext)

    sᵢ₋₁ = ext[end] - point
    sᵢ   = ext[begin] - point
    sᵢ₊₁ = ext[begin+1] - point
    rᵢ₋₁ = norm(sᵢ₋₁) # radius / Euclidean distance between points.
    rᵢ   = norm(sᵢ  ) # radius / Euclidean distance between points.
    rᵢ₊₁ = norm(sᵢ₊₁) # radius / Euclidean distance between points.</code></pre><p>Now, we set the interpolated value to the first point&#39;s value, multiplied by the weight computed relative to the first point in the polygon.</p><pre><code class="language-julia hljs">    wᵢ = (t_value(sᵢ₋₁, sᵢ, rᵢ₋₁, rᵢ) + t_value(sᵢ, sᵢ₊₁, rᵢ, rᵢ₊₁)) / rᵢ
    wₜₒₜ = wᵢ
    interpolated_value = values[begin] * wᵢ

    for i in 2:l_ext</code></pre><p>Increment counters + set variables</p><pre><code class="language-julia hljs">        sᵢ₋₁ = sᵢ
        sᵢ   = sᵢ₊₁
        sᵢ₊₁ = ext[mod1(i+1, l_ext)] - point
        rᵢ₋₁ = rᵢ
        rᵢ   = rᵢ₊₁
        rᵢ₊₁ = norm(sᵢ₊₁) # radius / Euclidean distance between points.
        wᵢ = (t_value(sᵢ₋₁, sᵢ, rᵢ₋₁, rᵢ) + t_value(sᵢ, sᵢ₊₁, rᵢ, rᵢ₊₁)) / rᵢ</code></pre><p>Updates - first the interpolated value,</p><pre><code class="language-julia hljs">        interpolated_value += values[current_index] * wᵢ</code></pre><p>then the accumulators for total weight and current index.</p><pre><code class="language-julia hljs">        wₜₒₜ += wᵢ
        current_index += 1

    end
    for hole in ints
        l_hole = length(hole)
        sᵢ₋₁ = hole[end] - point
        sᵢ   = hole[begin] - point
        sᵢ₊₁ = hole[begin+1] - point
        rᵢ₋₁ = norm(sᵢ₋₁) # radius / Euclidean distance between points.
        rᵢ   = norm(sᵢ  ) # radius / Euclidean distance between points.
        rᵢ₊₁ = norm(sᵢ₊₁) # radius / Euclidean distance between points.</code></pre><p>Now, we set the interpolated value to the first point&#39;s value, multiplied by the weight computed relative to the first point in the polygon.</p><pre><code class="language-julia hljs">        wᵢ = (t_value(sᵢ₋₁, sᵢ, rᵢ₋₁, rᵢ) + t_value(sᵢ, sᵢ₊₁, rᵢ, rᵢ₊₁)) / rᵢ

        interpolated_value += values[current_index] * wᵢ

        wₜₒₜ += wᵢ
        current_index += 1

        for i in 2:l_hole</code></pre><p>Increment counters + set variables</p><pre><code class="language-julia hljs">            sᵢ₋₁ = sᵢ
            sᵢ   = sᵢ₊₁
            sᵢ₊₁ = hole[mod1(i+1, l_hole)] - point
            rᵢ₋₁ = rᵢ
            rᵢ   = rᵢ₊₁
            rᵢ₊₁ = norm(sᵢ₊₁) # radius / Euclidean distance between points.
            wᵢ = (t_value(sᵢ₋₁, sᵢ, rᵢ₋₁, rᵢ) + t_value(sᵢ, sᵢ₊₁, rᵢ, rᵢ₊₁)) / rᵢ
            interpolated_value += values[current_index] * wᵢ
            wₜₒₜ += wᵢ
            current_index += 1
        end
    end
    return interpolated_value / wₜₒₜ

end</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../primitives/">« -</a><a class="docs-footer-nextpage" href="../centroid/">- »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 25 May 2023 18:49">Thursday 25 May 2023</span>. Using Julia version 1.9.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
