<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Barycentric coordinates · GeometryOps.jl</title><script data-outdated-warner src="../../../assets/warner.js"></script><link rel="canonical" href="https://asinghvi17.github.io/GeometryOps.jl/source/methods/barycentric/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img src="../../../assets/logo.png" alt="GeometryOps.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">GeometryOps.jl</a></span></div><form class="docs-search" action="../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">Source code</span><ul><li><a class="tocitem" href="../../GeometryOps/">-</a></li><li><a class="tocitem" href="../../GeometryOps.jl.2650/">-</a></li><li><a class="tocitem" href="../../primitives/">-</a></li><li><a class="tocitem" href="../../utils/">-</a></li><li class="is-active"><a class="tocitem" href>Barycentric coordinates</a><ul class="internal"><li><a class="tocitem" href="#Example"><span>Example</span></a></li><li><a class="tocitem" href="#Barycentric-coordinate-API"><span>Barycentric-coordinate API</span></a></li></ul></li><li><a class="tocitem" href="../centroid/">-</a></li><li><a class="tocitem" href="../contains/">-</a></li><li><a class="tocitem" href="../signed_area/">Signed area</a></li><li><a class="tocitem" href="../signed_distance/">Signed distance</a></li><li><a class="tocitem" href="../../transformations/flip/">-</a></li><li><a class="tocitem" href="../../transformations/reproject/">-</a></li><li><a class="tocitem" href="../../transformations/simplify/">-</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Source code</a></li><li class="is-active"><a href>Barycentric coordinates</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Barycentric coordinates</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/asinghvi17/GeometryOps.jl/blob/main/docs/src/source/methods/barycentric.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Barycentric-coordinates"><a class="docs-heading-anchor" href="#Barycentric-coordinates">Barycentric coordinates</a><a id="Barycentric-coordinates-1"></a><a class="docs-heading-anchor-permalink" href="#Barycentric-coordinates" title="Permalink"></a></h1><pre><code class="language-julia hljs">export barycentric_coordinates, barycentric_coordinates!, barycentric_interpolate
export MeanValue</code></pre><p>Generalized barycentric coordinates are a generalization of barycentric coordinates, which are typically used in triangles, to arbitrary polygons.</p><p>They provide a way to express a point within a polygon as a weighted average of the polygon&#39;s vertices.</p><p>In the case of a triangle, barycentric coordinates are a set of three numbers <span>$(λ_1, λ_2, λ_3)$</span>, each associated with a vertex of the triangle. Any point within the triangle can be expressed as a weighted average of the vertices, where the weights are the barycentric coordinates. The weights sum to 1, and each is non-negative.</p><p>For a polygon with <span>$n$</span> vertices, generalized barycentric coordinates are a set of <span>$n$</span> numbers <span>$(λ_1, λ_2, ..., λ_n)$</span>, each associated with a vertex of the polygon. Any point within the polygon can be expressed as a weighted average of the vertices, where the weights are the generalized barycentric coordinates.</p><p>As with the triangle case, the weights sum to 1, and each is non-negative.</p><h2 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h2><p>This example was taken from <a href="https://doc.cgal.org/latest/Barycentric_coordinates_2/index.html">this page of CGAL&#39;s documentation</a>.</p><pre><code class="language-julia hljs">using GeometryOps, Makie
using GeometryOps.GeometryBasics
# Define a polygon
polygon_points = Point3f[
(0.03, 0.05, 0.00), (0.07, 0.04, 0.02), (0.10, 0.04, 0.04),
(0.14, 0.04, 0.06), (0.17, 0.07, 0.08), (0.20, 0.09, 0.10),
(0.22, 0.11, 0.12), (0.25, 0.11, 0.14), (0.27, 0.10, 0.16),
(0.30, 0.07, 0.18), (0.31, 0.04, 0.20), (0.34, 0.03, 0.22),
(0.37, 0.02, 0.24), (0.40, 0.03, 0.26), (0.42, 0.04, 0.28),
(0.44, 0.07, 0.30), (0.45, 0.10, 0.32), (0.46, 0.13, 0.34),
(0.46, 0.19, 0.36), (0.47, 0.26, 0.38), (0.47, 0.31, 0.40),
(0.47, 0.35, 0.42), (0.45, 0.37, 0.44), (0.41, 0.38, 0.46),
(0.38, 0.37, 0.48), (0.35, 0.36, 0.50), (0.32, 0.35, 0.52),
(0.30, 0.37, 0.54), (0.28, 0.39, 0.56), (0.25, 0.40, 0.58),
(0.23, 0.39, 0.60), (0.21, 0.37, 0.62), (0.21, 0.34, 0.64),
(0.23, 0.32, 0.66), (0.24, 0.29, 0.68), (0.27, 0.24, 0.70),
(0.29, 0.21, 0.72), (0.29, 0.18, 0.74), (0.26, 0.16, 0.76),
(0.24, 0.17, 0.78), (0.23, 0.19, 0.80), (0.24, 0.22, 0.82),
(0.24, 0.25, 0.84), (0.21, 0.26, 0.86), (0.17, 0.26, 0.88),
(0.12, 0.24, 0.90), (0.07, 0.20, 0.92), (0.03, 0.15, 0.94),
(0.01, 0.10, 0.97), (0.02, 0.07, 1.00)]
# Plot it generally
f, a, p = poly(polygon_points; color = last.(polygon_points), colormap = cgrad(:jet, 18; categorical = true), shading = false, axis = (; aspect = DataAspect(), title = &quot;Makie mesh based polygon rendering&quot;, subtitle = &quot;Makie&quot;))
cb = Colorbar(f[1, 2], p.plots[1])
hidedecorations!(a)
display(f)
ax_bbox = a.finallimits[]
ext = GeometryOps.GI.Extent(NamedTuple{(:X, :Y)}(zip(minimum(ax_bbox), maximum(ax_bbox))))
xrange = LinRange(ext.X..., widths(a.scene.px_area[])[1])
yrange = LinRange(ext.Y..., widths(a.scene.px_area[])[2])
@time mean_values = barycentric_interpolate.(
    (MeanValue(),),
    (Point2f.(polygon_points),),
    (last.(polygon_points,),),
    Point2f.(xrange, yrange&#39;)
)

fig, ax, mvplt = heatmap(
    xrange, yrange, mean_values;
    colormap = cgrad(:jet, 18; categorical = true),
    axis = (; aspect = DataAspect(), title = &quot;Barycentric coordinate based rendering&quot;, subtitle = &quot;Mean value method&quot;),
    colorrange = Makie.distinct_extrema_nan(last.(polygon_points)),
)
hidedecorations!(ax)
cb = Colorbar(fig[1, 2], mvplt)
# Crop out everything outside the polygon
poly!(ax, GeometryOps.GeometryBasics.Polygon(Point2f[(ext.X[1], ext.Y[1]), (ext.X[2], ext.Y[1]), (ext.X[2], ext.Y[2]), (ext.X[1], ext.Y[2]), (ext.X[1], ext.Y[1])], [reverse(Point2f.(polygon_points))]); color = :white, xautolimits = false, yautolimits = false)
fig</code></pre><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABkAAAASwCAIAAAAsYxHAAAAABmJLR0QA/wD/AP+gvaeTAAAgAElEQVR4nOzdd6AU1d0//nMp0kE6UqULiICiRkCNYomKPkZU1GjQWCJiHhRNjBpj7DHGBsb6mFhiLyhYsBMCgmgQEQFp0vEKSscL3Hv398f83Ox3b+Gytw3yev01O3PO2c/MnV3dN2dmshKJRAAAAACAuKpS2QUAAAAAQHEEWAAAAADEmgALAAAAgFgTYAEAAAAQawIsAAAAAGJNgAUAAABArAmwAAAAAIg1ARYAAAAAsSbAAgAAACDWBFgAAAAAxJoACwAAAIBYE2ABAAAAEGsCLAAAAABiTYAFAAAAQKwJsAAAAACINQEWAAAAALEmwAIAAAAg1gRYAAAAAMSaAAsAAACAWBNgAQAAABBrAiwAAAAAYk2ABQAAAECsCbAAAAAAiDUBFgAAAACxJsACAAAAINYEWAAAAADEmgALAAAAgFgTYAEAAAAQawIsAAAAAGJNgAUAAABArAmwAAAAAIg1ARYAAAAAsSbAAgAAACDWBFgAAAAAxJoACwAAAIBYE2ABAAAAEGsCLAAAAABirVplFwBQmZYsWfLpp58W06BJkyZdu3Zt2rRphZVEyZ1xxhmzZs2KlgcOHHjvvfdWbj0/Gnl5eePGjUu+7NmzZ8eOHZMvd8/DvmXLlrfffjv5sm/fvq1bt67EeipS8efDj0ll7enu+ZkCgJ0lwAJ2a++8886FF164w2YNGzY8+uijb7311h/rz7Zd1IIFC7744otouVOnTpVbzI/J999///Of/zz58u67777sssuSL3fPw/7NN9+kHpMnn3zy7LPPrsR6KlLx58OPSWXt6e75mQKAnSXAAtixtWvXPv/886+88srvf//7G264obLL+TH4z3/+8+STTyZf/vGPf2zUqFEl1sOuyFkEALD7EGABlNS2bdtuvPHG9u3bn3vuuZVdyy5vzpw5qZfJXHbZZaIHdpazCABg9yHAAviv/fbbr3379smX+fn5q1atmjVrVk5OTnLl8OHDBw4c2KZNm8ookP/Hsccem7zc5sADD6zcYnYfDjuULZ8pACgJARbAf1144YWXXnpp2srs7Owzzzzzgw8+iF5u2bLlpZde+rHeAmbXcsstt1R2Cbsjhx3Kls8UAJSEAAtgB5o3b37//fd369YtuWb+/PmFtly8ePGsWbOWLFmyfPnyBg0atG7deu+99+7Xr1+VKlUKNn7//ffz8/Oj5U6dOu29994hhLlz577zzjvbtm075phjsrOzk4379u275557po2wdOnSefPmJV/269evdu3aaW1mz57973//e9WqVXl5eV27dt1nn3169uxZo0aNYvZ369atEyZM+Pzzz1evXl2vXr22bdsec8wxLVq0KLRxoXsxY8aMCRMmZGdnt2zZsnv37occckjBwnao+ONzxRVXhBA+/PDDLVu2RG1atWqV+jcq5UEoXmYDrlmz5oMPPli0aNG3335bt27dli1b9u/fv6iaS9OxJIcuaevWrePHj581a9bmzZvbtGkzaNCgHc4uLOawl/582KkPUcnt1Fldcps3bx43btyXX36Zm5vbvn37E044oXnz5sV3yWwHV69ePWPGjIULFy5durRJkybt27fv1KlTz549i+mS2S5ncD4UY2dPxYr85inNnpa+1JJ/lZXJd2xeXt4777zz6aefbtq0qWPHjoMHD27QoEEIYcKECbm5uVGb3r17N2nSpIRHAAAqRwJgN/bII4+kfiWOHj260GabN29Obfa73/0urcHs2bPPOOOMQn+CdujQYfTo0Xl5eWldqlatmmxz00035efnjxw5MlrZo0ePv/71r6mD3HvvvQWrGjp0aLJB06ZNt2/fnrr1zTff7NWrV8F62rVr98ILLxS6m1u3br311lujHzapsrKyBg8evHjx4oJd0vZi5cqVAwcOLPiOb775ZrLLtdde27hx47p166a2adiwYePGjS+99NISHp+oTepDIc8///yC5WVwEIqX2YBz5swZPHhwVlZWwY49evQo844lOXSRxx9/PO0na5UqVX7729+uW7cudeXdd9+d2quYw57B+ZC0Ux+iEp5FiYzO6kJ99dVXqd2ffPLJl156qWHDhqkrq1Wrdskll2zevLnQETL4lkgkEt98883ll19es2bNgr0OPvjg1157rWCXjHc5s/OhGCU8FSvmm6dM9rT0pe7sV1kp9zSRSLz++utp2VzdunWffvrpRCJRp06d5Mpx48YVNQIAxIQAC9itlTDAeu2111Kbvfrqq6lbZ8+enfozoFC///3v08ZM+1mSOhmhR48eK1asSP2hO3DgwLTu+fn5qXM9hg0blrr19ttvLzT1SPrlL3+ZNuCmTZuOOuqoYro0btz4k08+KWYvRo4cWcwD4CdMmBB1GTFiRFFthg4dWsLjE7UpPsDK4CAUL7MBX3311R2eHsOGDSsYXmTcsSSHLpFIXH311UUN+6tf/Sr1ZWYBVgnPh8jOfohKeBZldlYXKi3AOuecc4qaM3XwwQdv2rQprXtm3xJr1qxp27Zt8b2uu+661C4Z73LG50MxSnIqVtg3T+n3tPSlZvBVVpo9TSQSjzzySFHfWk8//bQAC4BdiwAL2K2lBVh33nnnxhTr16+fN2/eAw88kPpv9Yccckh+fn5yhC1btpTkKrAQwsSJE1PfOvVnyWmnnZb6Yzj6VZP6S6l69err1q1L7f7JJ58UNfirr75aknr+8Y9/pA5Y8NGKzZs3Ty0yWrNmzZqi9qJ69erFvF2PHj1yc3MTGQVYhR6fRLG/+jI7CMXIbMDp06cXOnemoJtuuqlMOpbw0L355pslGTySWYBVwvMhkdGHqIRnUWZndaHSAqziXXDBBal9M/6WOOaYY9IaFDyqWVlZL730Uil3uTTnQzFKcipW2DdP6fe09KVm8FWW8Z4mEokvv/wyrbxUderUqVbtv/cSEWABEH8CLGC3lhZg7dD++++/evXq1BHSfg796le/+vTTT7/++uuFCxfeddddqT8ebrzxxtSOqZuS/0JepUqVJk2a9O7dO5FI/OMf/0gd+dlnn03tfvPNNyc3tW7dOpmp5ebmpk3ZuOqqqyZPnrx06dIXXnihVatWyfV169bduHFj1OvDDz9M7XLyySd//fXXiUQiJyfnL3/5S2qpF154YVF7EUKoWrXqr3/966eeemrMmDGXXnpp2tbPP/88kUhs2bJl7dq1Dz30UOqmzz77bO3atanXXu3w+CSK/tWX2UEoRsYD9u3bN7XXAQcc8NJLLy1evHjChAkXXXRR2qH76quvSt+xJIcuPz+/d+/eqYMcf/zxTz/99Ntvv3311Vfvscce4f+VWYAVSnY+JDL6EJXkLMr4rC5UoQHWKaec8uyzz44fP/7yyy9PDSaqV6+e+kfJ7Fti8eLFqb3OPffcpUuXJhKJjRs3vvzyy6kTMJM5SGa7XMrzoRg7PBUr8punlHtaJqXu7FdZxnsaGTJkSOrWQw899Iknnoh2tuA9+wRYAMSfAAvYre1UgNWvX7+cnJy0Ea699tpkg+7du6dOzkokEkcffXRy6ymnnJK6Ke2HR9euXcePH//9998nG6xfvz51Ds5ZZ52V2r1///7JTVdeeWVy/SuvvJI67K233praa9KkSalb33rrrWj9WWedlVzZoUOHtN288sork1tr1ar17bffFroXWVlZ48ePT+2YmrKFEF588cXkpieffDJ1U1oEU5Ljkyj6V19mB6EYmQ04YcKE1PWHH374li1bUjvefvvtqQ1GjhxZyo4lPHRPPfVUaoMLLrgg9bx977330i6OyyzAKvn5kPGHqPizKOOzulAFA6wrrrgitcHLL7+cuvWiiy5KbspsB1988cXUAdOi8yeeeCJ1azRDM7NdLuX5UIwdnooV/M1Tmj0tk1ILPQiJcvhMJRKJzz77LPXiwZ/97Gdbt25Nbp04cWJahiXAAiD+BFjAbm1nZ2Cde+65aXe3ef3110f/4O23307dlJeXl3rdUNp9rFJ/ltSqVWvRokUFyzv99NOTbRo2bJi8TfvatWtTu6fedWX48OGpw27YsCFtzP322y/Z4Nprr41Wpl4jWfCStEWLFqUehKeeeqrQvTj++OPTOi5cuDC14x133JHctFMBVlHHp6hffZkdhGJkNuBVV12Vuo/Tpk1L67V9+/Z27dolGyTn0WTcsYSH7qSTTko2qFOnTsHs5tRTT00tILMAq+TnQ8YfouLPoozP6kKlBVhNmjQpeLP21CiqXr16yfWZ7eA999yT+o6//vWvU+8Rvm7dunEpomIy2+VSng/F2OGpWMHfPKXZ0zIpdWe/yjLe00SBW33NnDkzre+wYcNSGwiwAIi/agGAH+yxxx5pNxnJycnJy8tLvnzsscdWrlz52muvJZsdf/zxqe3z8/MXLFgwd+7c2bNnjx07ds6cOSV53+OOO659+/YF1//iF794/vnno+W1a9f++9//PuKII0II77zzTrKqzp07H3DAAcku06dPTy7379+/Xr16aWOOGzfuu+++i5ajZ6gtWrRozZo1yQbLly+/77770nrVrFkzJycnWv7oo49SJyMkpV2bE0Jo3bp16svk89p3VlHHpygZHITyGHDatGnJBvvss8+BBx6Y1qtatWpnnHFGcjrV7NmzN23aVLdu3Yw7Fqy80EM3ZcqU5PKgQYMaNWqU1uCXv/xl2vSfDJT8fCiTD1GasjqrizJ48ODatWunrTz33HPfeeedaHnjxo3Z2dnRhX6Z7WDaVasPPfTQQw89tO+++x533HHHH398//79Bw0alNog412umPOh4KlY8d88Ge9pWZW6s19laXbqO3bq1KnJ5V69evXs2TOt78UXX/zAAw9kXAwAVDwBFsB/3XnnnZdeemnqmtzc3EWLFt15550PP/xwtObtt9+++eabb7jhhtRmS5cufe6558aPHz916tQtW7bs7Pt27ty50PXHHXdc48aNv/322+jluHHjogDrjTfeSLY588wzU7usXr06uZx6l5yktm3bpv0wzs7OTn2Zdl+hgtJuzZNUq1attDVFPaZtZxV1fIqSwUEojwG/+eab5HLqDItUqb9mE4nE6tWr69atm3HHgs0KHrrc3NzUn+KFjt+hQ4dC33Sn7Oz5UMoPUZqyOquLUuhxS3tC3Pz581PPlp3dwUGDBnXq1GnBggWpK2fNmjVr1qw77rijfv36Rx111GmnnTZ48OAoT89slyvsfCh4KlbwN09p9rSsSt3Zr7I0O/WZWrFiRXK50P3q0qVLVlZWIpEoTUkAUJHK5qcFwI9VtWrVunTp8tBDD5144onJlaNGjfr++++TL++9995u3br97ne/e//999N+lxa8UW6hCo0eQgjVq1dPvYpw7NixIYREIvHWW28lV55xxhmpXTZu3Jhcrl+/fknefcOGDSVplrR27dqdal96RR2fomRwEMpjwM2bNyeXU68/SpUWh0V/i4w7FlTw0EX37km+bNq06Q4HrwCl/xClKe+zutCJe2kHc8mSJcnlDHawevXqkyZNGjRoUOqdjJI2bNjw8ssvn3nmmZ07d54xY0bIdJcr7HwoeCpW8DdPafa0rErd2a+y0kitudD9qlmzZknmnwJAfJiBBVAigwYNGjduXLS8bt26efPm9erVK4QwduzYyy67LNmsatWqffr0Ofjgg/fff/9DDjnk+uuvf+GFF0rzvr/4xS+SV3ksXLhwzpw5OTk5q1atitb07t079QY6IYR69eolJwukTuQpRp06dVJfnn322cX/Xk29+1I8ZXAQymPABg0aJJeXLVtWaJu09VGXjDuWRN26dRs1apS84DF1mkZSoSvLT3l8iMr7rC7075K2MnmNYcY72Lx583Hjxi1cuPCxxx4bM2bMF198UbDNkiVLBg4cuHDhwsx2uRLPhwr+5inNnu6KX5KpNX/99dcFG3z//fcV/68RAFAaAiyAEkm7ziJ5Kcof//jH5Mpu3bq99tprqRdrFJU+lFy/fv3at2+fvIH02LFj8/Pzk1vTrh8MITRv3jx5zVEJr4pq1qxZ6svBgweffPLJGRccBxkchPIYsFWrVp999lm0/OWXXyYSiYJTaVLvf1S1atXoV3HGHUuoU6dOydtszZ49u2CDzG47lbHy+BCV91ld6HFLC5j22muvaKGUO9ixY8ebbrrppptuWrBgwZgxY1555ZWpU6emfg989913Tz755LHHHpvaq+S7XFnnQ8V/82S8p7vil2Tz5s2Tt3ifN29ewQZz5sxx/SAAuxaXEAKUSHL6VaRFixYhhPz8/Llz5yZXXnzxxam/Szdu3Fjob6SdkpWVlXoz4LFjx7755pvJTUOGDElrn3rD7+nTp6eWF+nXr1/NH1xzzTUhhM6dO6deSDJr1qxS1lzpMjgI5THggAEDkg1WrFjx0ksvpfX67rvv/vnPfyZfHnDAAdE9bjLuWEJdunRJLo8fP37+/PlpDQreoLr8lNOHqLzP6ldffTVttk4ikUg9bjVr1tx///1DpjuYl5d3++23//kHn3/+eQihU6dOv/3tbydPnrxixYo//OEPqe3nzJmT8S5X1vlQ8d88Ge/prvglmfpwj9mzZ0+aNCmtwV133VWxFQFAaQmwAIqTk5Mza9as88477/XXX0+ubNasWffu3UMIGzdu3Lp1a3J92kyKP/zhDzt755RC/eIXv0guT506NfkgrX79+hW8UOW4445LLicSiSuuuCL5YKwQwrPPPjtlypStP4imbGRlZaXO3bjvvvs2bdqUOuY333yz7777dvrByy+/XPqdSrNt27YyHC2Dg1AeA55yyimpM6d+97vfpf5g/v777y+66KLUu2udeuqppexYQkOHDk0u5+fnDx06NPmggBDCrbfeOnny5J0asDTK8EOUehaV91m9ffv2oUOHJmuLzorUKOq0007bY489QqY7WLVq1UcfffTqH6TFVS1atLjhhhtSrxtt0aJFxrtcWedDxX/zZLyncfiS3Fk///nPU18OHz489ULChx9++JlnnqnwogCgVFxCCPBfI0aMSL1VTQghLy+vYLPLLrssyhcaNGjQsmXLlStXRuvvueeevLy8Aw888Jtvvhk7duz7779fJlV169atT58+n376aQghPz8/eelQwesHQwhHH330vvvum5wg8MYbb/Tv3//0009v1arVlClTHnnkkWTLNm3a9O/fP7lHzz77bLScnZ19yCGH/OlPf9pnn32ys7M/++yz++67b9GiRclegwYNKv1OJW8PFHnppZeGDx+eSCRKfi+nYmR2EMp8wK5duw4ePPjFF1+MXn711VcHH3zwL3/5yz59+ixevPjFF19MncfRpEmTiy++uJQdS+ioo44aMGBAckbGlClT9ttvv+OOO65Jkyb/+te/pk6dulOjlVJpPkTFn0XlfVa/9957PXv2/NnPftagQYN33303+oRGatasefPNN5dyBwcMGJAMLseOHXvKKaeceeaZLVq0yM3NXbp06ZNPPrl+/fpk44MPPjjjXa7E86GCv3lKs6cV/yVZSkccccSRRx6ZPMFmzpzZp0+fQYMGNW7ceNKkSRUZUgNAmUkA7MZSo4cSOuKII7Zu3ZocIfX6voKqVfvvvxP069cv9a2rVq2a3HTTTTcVX+edd96ZNnLVqlWzs7MLbTxt2rTq1asXvxc1atT46KOPUnv95je/2eG+V69efcyYMSXfi+3bt6d2v+2225KbZs6cWXD8oUOH7tTx6dixY7LN+eefX/qDUIzMBvzmm29at25dfK8QQpUqVd56660y6VjCQzdhwoQqVUo6C/vuu+8u4WHP7HzI+EO0w7Mos7O6UMn70JXE1Vdfndo3sx2cO3duo0aNSvJ2PXv23Lx5c2l2uTTnQzFKcipW8DdPafa0PEqNlPlnKpKcrlsS48aNK7Q2AIgPlxAClFRWVtZFF100bty46MqgyF133VXU/bPPP//81KkxM2fOzPiJeGeeeWbaj64jjzwy7b7CSQceeOCYMWOKeV57gwYNHn/88YMOOih15V133XXeeecVU0PdunVff/31srp1cY8ePUoy9SljmR2EMh+wadOm//rXv3r06FHMyPXr13/llVeOOeaYMulYQocffvhDDz2U+ts41eWXX57BmBnL+EO0w7Oo/M7qCy+8sGbNmoVuGjJkyI033phWRgY72LVr11deeaWYUy7SsmXL119/PTkZLbNdrsTzoYK/eUqzpxVcaun95Cc/GTVqVMFHQESuueaatKcrAkDMCbAAirPHHns0b958wIAB11xzzZdffvnQQw+l/R9/8+bNJ0+ePHjw4NSVvXr1GjNmzP/93/8dccQRyZWbNm265JJLMitjr732OvLII1PXFHr9YNIJJ5wwe/bsYcOGNWnSJHV9o0aNhg0bNn/+/IJ3f69Wrdrf//73cePGDRgwIO3XXZs2baInoB199NGZ1V9QlSpVXnjhhaFDhxaVApReBgehPAbs0KHDf/7zn/vuu69Xr15pvyRbt249cuTIefPmnXjiiWXYsYQuuOCCKVOmDBw4MDUb7dChwz//+c+0/KW8Zfwh2uFZVH5n9WGHHTZ16tTDDjss9U+zzz77PP74488++2zqpKrS7OChhx66bNmyv/71r506dSpYQ9euXe+777558+a1adOm9LtcWedDBX/zhFLsacWXWnq/+c1v/vWvf/Xv3z/1RO3Spcsrr7xyyy23VGJhAJCBrIQH6AKUhQ0bNsybN2/jxo3t27ffe++9y3z8v//97+eff360XKNGjezs7JLcLiqRSMybN+/rr7/OysraZ599ipq0lWbdunXz589fu3Zts2bN2rZtW8LrmDK2evXqnJycevXq1a9fv+RX95RcZgehPAZcs2bNV199tXbt2jp16rRs2bJ9+/bl3bEkVq9evWDBgi1btrRq1WqfffYpw5F3Vmk+RDs8i8rprF61atWCBQtyc3Pbtm2beiFYoUqzg1u3bl25cuWKFStyc3NbtWrVunXrHT56MrNdrsTzoeK/eTLe0woutfSys7Pnz5+fk5PTpk2brl27Ritr1aqVfB7FG2+8kfq0CgCIIQEWwK7hwQcfHDZsWLR88sknjxkzpnLrAWDXtXDhwtSZfR9//HHfvn0rsR4A2CGXEALsArZt2/bAAw8kX55xxhmVWAwAMXfnnXe2SFHweZd33313crl27drdu3ev2AIBYKdV23ETACrJ8uXLP/roo7Vr195///3JB641b978pJNOqtzCAIizvn37ZmdnJ18OHTr0scceO/LII7OyspYvX37bbbfdf//9ya2/+MUvks8BAIDYcgkhQHxNmDAh9QbPkTvuuOPKK6+slHoA2FWMGDFi1KhRqWtq1qy5xx57bNiwIXVl586dp0yZ0rhx44qtDgB2mksIAXYlAwcOHD58eGVXAUDc3Xvvvddee23qk3NzcnJS06vq1aufd955EydOlF4BsEswAwsgvqZMmXL00Udv2bKlfv367du3P/3000eOHFmjRo3KrguAXcO6dev+/ve/T5w4cenSpcuWLcvLy2vXrl27du26det28cUXt2vXrrILBICSEmABAAAAEGsuIQQAAAAg1gRYAAAAAMSaAAsAAACAWBNgAQAAABBrAiwAAAAAYq1aZRcAAOVrxowZixcvjpY7duzYs2fPkvR6//33N2zYEC0feOCBrVq1KqfyfnyiQ1e/fv0jjzyysmvZxfz73//+9ttva9Wqdeyxx1Z2Lf6OAEC8ZCUSicquAQDK0QUXXPDoo49GywcddNBHH320wy7fffdd8+bNc3Nzo5fPPPPMGWecUY4l/rjsu+++X3zxRY8ePWbNmlXZtexiBgwYMHny5FatWi1fvryya/F3BADixQwsAHYj06ZN++qrr9q3b198s5dffjmZXkHZWrVq1XvvvRdC6NevX4cOHSq7HACAXYN7YAGwe3n++ed32OaFF16ogErYPX322WfnnHPOOeecM3HixMquBQBglyHAAmB3Ubdu3RDCs88+W3yzb7/99v333w8h1KtXryLKAgAAdkSABcDu4sQTTwwhzJgxY968ecU0GzNmTHT9YNQeAACodO6BBcDu4vTTT3/22WcTicRzzz133XXXFdUsun5wn332KeHzClevXr1ixYqaNWu2b9++Ro0aJemSSCRWr169fPny2rVrt27dOpoaVkI5OTlLly7dsmVLx44dK3KOWGlqLisZHOqSjLl8+fIaNWrsvffetWvXTt2Um5u7ePHidevWtW3btlmzZpVS3qZNm5YtW7Z169YS/rnz8/OXLVu2evXq6M9Uv379krzLunXrli5dGkJo06ZNw4YNS1s0AEA5MAMLgN1F69at+/XrF4q9ijB5/eDpp59e/Gjbt2+/5557evbs2axZsz59+nTr1q1WrVqHHHLICy+8kJ+fX1SvadOmnXrqqTVr1mzevPkBBxzQrVu3evXqtWzZ8k9/+tPq1asLtr/kkksGDBhw1VVXhRCys7PPO++8Ro0ade3atU+fPvXr1+/WrVtJbukVQhg9evSAAQMGDBhQzO29/vKXv0Rtxo4dW5qaCzVo0KABAwZcfvnlhW79/PPPo7d++eWXC27N7FAX6vLLL08ezw8//HDAgAHNmjXbf//9e/To0aRJk1//+tdbtmwJIWzduvXaa6/da6+9OnfufOCBBzZv3rxVq1aPPfZYoc9uLnl5o0aNGjBgwJVXXhm9vPXWW6O9/vrrrwsOu2TJklNPPbVJkybdu3eP/txdu3Z95plninp+9MqVK4cNG9aiRYu99977wAMP7NGjR6NGjYo6pElvvvnmoYce2rhx4169evXq1atx48aHH374Bx98ULLDCQBQgRIA8KN2/vnnR//J+/jjj0eNGhUtf/7554U2fuSRR6IGs2bNuu2226LlKDVItWrVqj59+hT139YTTzxxy5YtBQd/8MEHi/kvcrt27b755pu0Lv379w8hnHDCCRKdrucAACAASURBVHPnzm3dunWhHW+44YYdHoQJEyZEjY8++uhCG+Tl5e21114hhOrVq6eWkUHNPXr0CCH06NEjdWXjxo1DCAMHDiz03f/9739HA44ePTptU2aHuigDBw6MjudTTz1VrVoh89APO+ywtWvXHnzwwYW+3d/+9rfSlDdixIhCm3311VdRg+jP3apVq48++qhBgwaFNi70z/3uu+8WMz/rjDPO2LZtW8Fel112WaHts7KyRo0aVejfEQCgspiBBcBu5NRTT61SpUooehJWNKGpe/fu0a/3QuXn559wwgmffvppCGGvvfb605/+NHbs2GeffXbEiBG1atUKIYwbN+7kk09O6/XJJ5/87//+bwihSpUqp59++lNPPfXBBx+8+uqrN910U5RMLVmy5JJLLin0Hbds2TJ48ODly5f/8pe/fPXVV+fPn//OO+8kb9F14403zp49u/gdP+yww6J3+eCDD7777ruCDSZMmLBq1aoQwkknndS0adPS11wmMjvUOzR79uxf/epX9erVGzVq1MyZM6dNm3bllVdGJ8bEiRO7du360Ucf9e7d+7nnnvvyyy/ffffdI488Mup4zTXXbNu2LePyTj311NGjRyeP2Nlnnz169OjRo0dH6V7Shg0bTjjhhPXr119wwQXjxo1bsGDB22+//bOf/SzaeuONN3755ZdpuzNo0KCNGzeGEPbdd98bb7zxjTfeePTRR88777zk2R79HVM9+OCD99xzT7R86KGH3nbbba+88sqf/vSnXr16JRKJyy67bPHixTt7YAEAylFlJ2gAUL5SZ2AlEonDDz88hNCpU6eCLdesWRPNyrn++usTiURRM7Aee+yxaP1RRx21Zs2a1E1ffPFFx44do63R/baSRo4cGa2/995709531apVLVq0CCE0adIkbVM0JSfyyCOPpG095ZRTok0PPPDADo/DFVdcETV+9NFHC2694IILoq2vv/56KWsuwxlYmR3qYkQzsEIIjRs3Ts57iqRe3njMMcfk5OQkN23fvn2fffaJNn3xxRelLO/NN9+M1v/jH/9IKy/1z/3EE0+kbT3++OML/Qseeuih0fpTTz118+bNqZtee+215MysqVOnJtdv3rw5mnAXQrj22mvz8/OTm3JycoYMGZIswwwsACAmzMACYPcS/ThfsGDB9OnT0zYlnz9YzA2wcnJyohvAN2zY8J///Gfa3Jnu3bs//vjjWVlZIYTbb789ddPUqVNDCA0aNBg+fHjamC1atIjm16xZs2bNmjWFvu9xxx2XzJiSkpeAzZ07t6iCk84666xooeBtsLZv3/7SSy+FEFq2bHnssceWVc2llPGhLolbbrll7733Tl0zdOjQaKFGjRoPPfRQ6l3Yq1WrdvbZZ0fLixYtqoDyTjrppHPOOSdt5W9+85toIXUG1owZM6L4b6+99vrnP/+Zdh/6E0444ZprromW//a3vyXXjxo1Kppw9z//8z8333xzVGdy95966qkOHTrsbM0AAOVKgAXA7mXw4MFVq1YNITz33HNpm6LrB3v06NG9e/eiur/11lvLli0LIVxyySXNmzcv2KB///5HHHFECOGzzz5bv359cv0DDzzw8ccfT5kyJXr3NMm4JErQCoruO56mS5cuxfdKtf/++0fTiN577721a9embho/fny0ZujQoanllbLmUsr4UJfESSedlLYmmWf16tUrLdtK3Zrc2XIt77e//W3Bld26dYsW8vLykitfe+21aGHkyJGFPvpw2LBh0SSsN954I7kyee//P/7xjwW7VK1aNTlfDwAgJgRYAOxemjVrFsUKaQHWt99+Gz18rfjnD06ZMiVaSL3aK83+++8fQsjPz0+d5LXffvv17ds3mUGkmjFjRtqD/wrq2bNnwZWF5krFOPPMM0MI27dvf/XVV1PXP/PMM9HCr371q9T1pay5lDI+1DtUv3795AV0ScmDmbxasNCtFVBeCGHfffctSQ0hhI8//jhaOOaYYwodqkGDBgcddFAI4dtvv/3qq69CCFu3bp05c2YIoXXr1lGFBWVwZzEAgHJVyPN3AODHbciQIe++++6SJUumTp36k5/8JFpZkusHQwhLliyJFq6++uobbrih0DbRxVkhhOzs7IJb16xZ8+mnn86dO3fhwoULFy6cPXt28qq0ojRs2LBRo0bFtymJs8466/rrrw8hvPjii+eee260csuWLVEUddhhh3Xq1KnQjhnUXHqlP9RFqV69esZbK6C8Ro0a7bnnniVsnHyLdu3aFdUmuWnVqlXt27dfs2ZNNIermOsE99prrxo1amzdurWkRQMAlDMBFgC7nVNOOWXYsGG5ubnPPfdcMsCKLqrq2bNnoRNwktatWxctfPbZZzt8oy1btqS+/OCDD/7whz98+OGHac322GOPhg0bFpNxpN3YKGOdOnU6+OCDP/roo3feeWf9+vUNGjQIIYwdO3bz5s2hwPSrUtZceqU51BWg/MqLnmBYQtHDB+vUqRP9NQsVPTIy/FBz1CWE0KZNm6K6ZGVltWrVqgJiSgCAEhJgAbDbadSo0VFHHTV+/PgXXnjhrrvuysrKWrNmTUmuHwwh1KxZM1r4y1/+0rBhw+Ib9+vXL7l8zz33JJ9zV6NGjd69e/fu3btz587dunXr37//9ddff++992a+SyV25plnfvTRR9u2bRs3blx0Y/Lo+sF69eqddtppaY0rrOZC76KV8aGuGDEpL0q7tmzZkpOTkywpTfKWZ1GDunXrRi9Xr15dzMjfffddWRYKAFA6AiwAdkdDhgwZP378ihUrJk2adOihh5bw+sEQQpMmTaKFn/zkJ4ceemgJ327evHnRXbFr1659xx13nHfeeTs1y6YMDRkyZOTIkfn5+S+++OLZZ5+9du3a8ePHhxDOOOOMtHleFVnz4sWLC67M7FBXmJiUF5WRSCSWLl2avKl/mujWVyGE6FGJjRs3rlKlSn5+fnJ9QevXr09OMQMAiAM3cQdgd3TyySfvscce4YdbuUfXD/bq1auoCCCpT58+0cLs2bOLarNp06Y1a9asWbMmuebpp5/Oz88PIdx5552XXHJJwSQotXG5atGixZFHHhlCeOuttzZu3PjSSy9t27YtFHb9YEXWPH/+/IIrMzvUFSYm5fXu3Tta+M9//lNog7y8vOgixxo1akSXx9aqVSta+Oqrr1auXFlor2nTppVLuQAAmRJgAbA72nPPPaOntr344ovZ2dklvH4whDBw4MBo4cEHH4zynTTbtm3r3r1706ZNU2flLF26NFoYMGBAwS75+fkTJkzY6X3IVPQswpycnNdeey26frBbt27Je4EllW3NWVlZIYTly5cX3LR169Ynn3yy4PrMDnWFiUl50SM1Qwh//etfC23w7LPPLlu2LITQr1+/GjVqRCuPOuqoEEJubu7tt99eaK+i1gMAVBYBFgC7qSFDhoQQsrOz//d//zd6KFtJAqyuXbtGM5hmzJhxxx13FGxwww03RHlB8jF/IYS2bdtGCwsXLizYZcSIEStWrIiWC70bVNkaPHhwFGT87W9/i0Ko888/v2Czsq05ul/4/PnzP//887RNd9xxR3TE0mR2qCtM6csrk7/1scceu/fee4cQpk+fPmrUqLStS5Ys+eMf/xgtDxs2LLn+ggsuiBYefvjhN998M63Xo48++t5775W+NgCAMiTAAmA39T//8z/RPa2j6wf79OnTqVOnknS8++67owDo97///eDBgz/88MMNGzbk5OR8+umnQ4cOvfXWW0MIHTp0SGYEIYSDDjooWhg5cmTy4qzt27dPmjTpZz/72X333Zdsef/9969duzaRSJTNThamQYMGxx9/fAhh8uTJ+fn51atXP+eccwo2K9uao9Hy8/MHDx48ceLEaOWSJUuGDx9+3XXXdejQoUqVQv6fJINDXZEyK6969erRwtixY+fPn//FF19s3bo14xqqVKlyzz33RMsjRoy46KKLJk+e/P333y9atOjxxx8/8MADoycJHn744YMHD0726tmzZ5Ra5uTkDBo06Oqrr540adJ33303ceLESy+9NCq4WbNmGVcFAFD2EgDwo5acXvTxxx+nbTr55JOT/0G87bbb0rbedttt0aZnnnkmbdNzzz0X3UKrUI0aNZo7d25alxNPPDHZYM8992zXrl21av//o1S6dOnywAMPpI6wbNmyqFf//v1DCK1atSp015JPkRs+fPhOHZMos4v8/Oc/L6pZZjX36NEjhNCjR4/UoZYvXx7dQTxSt27dpk2bRssNGzacPXt21apVQwijR48u/aEuRnTdX+PGjQtu2rhxYzTm+eefX3BrdK1lCGHMmDGlLG/FihXRziZ99dVX0abi/9zJeWpXXHFF2qYbb7wxdcDogs2kfffdd+XKlQX3t5hrG4cMGfK73/2u4N8RAKCymIEFwO4ruoowctppp5W84+mnnz5p0qSCN4eqXr36xRdfPGvWrK5du6ZteuKJJ4YNGxYFQOvWrVuyZElubm7dunWvuuqqjz/++OKLL77mmmuSuUah05HK0Iknnli/fv1oueDt28uj5latWr311lvJO21t2rQpSt8GDBjwySefdOvWraiO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JYQwbdq0jN+lJARYAAAAACUyduzY8ePH1wrhp2U35hEh1A7hvffeGzduXNmNWjbmzZsXLeyzT+GXS9arVy+6lfvChQvz8/PLrxIBFgAAAMCObdu27be//W0I4fAQyvB25bVCOCyEEMLll1++devWshu4DCxdujRaaN26dVFt2rRpE0LYunXr119/XX6VVCu/oQEAAAB+NO6555558+Y1CeHAsh75wBCmh7Bw4cJRo0b16NFjh+2PP/74si6hcJs2bYoWGjRoUFSb+vXrpzUuDwIsAAAAgB275ZZbQghnduzYsl69Mh98yMaNoxcuvPnmmzds2LDDxolEoswLKNTmzZujhZo1axbVplatWmmNy4MACwAAAGDHomip0cKF5XGlXKMf3uK4444rh+EzFN2gPRQbmeXl5e2wTekJsAAAAADi4o033qjsEv6rTp060UJOTk5RbZKb6tatW36VuIk7AAAAAIWo98PFkuvXry+qTXJTvXK4sjJJgAUAAABAITp06BAtLFu2rKg20aZatWq1aNGi/CoRYAEAAABQiK5du0YLX3zxRaEN1q5d+/XXX0cts7Kyyq8SARYAAAAAhejdu3ft2rVDCJMmTSq0wZQpU6J7t/fr169cKxFgAQAAAFCImjVrHnXUUSGExYsXf/jhhwUbPP3009HCSSedVK6VCLAAAAAAdmtr16595QdpDxy85JJLooWrr746mmyVNH369Oeeey6E0KVLlyjnKj8CLAAAAIDd2pdffvnzH6xZsyZ107HHHnvEEUeEECZOnHjGGWdEd7wKIbz55pvHH398bm5uCOG2226rWrVquVYowAIAAACgSM8880y7du1CCM8//3zr1q3btm275557Hn/88dnZ2SGEq6666pRTTinvGgRYAAAAABSpefPmn3zyyWmnnVa1atW8vLxly5atX78+hNCsWbNHH330z3/+cwXUkJV2+SKUlejxmU4wAACgNPyyID6is/H6chv/hhBCvM/2lStXTpw4ccWKFbVr1+7cufNPf/rTatWqVcxbC7AoL/4zAwAAlJ5fFsSHAKsSuYQQAAAAgFgTYAEAAAAQawIsAAAAAGJNgAUAAABArAmwAAAAAIg1ARYAAAAAsSbAAgAAACDWBFgAAAAAxJoACwAAAIBYE2ABAAAAEGsCLAAAAABiTYAFAAAAQKwJsAAAAACINQEWAAAA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cst99903evTo6o/Hjh276667Fi9e3N7e/uCDD371q1+99tpr+7X7HglYAAAAACm6u7qqN6oPaO95SEdHR+/faM+ePTfeeGMp5ZOf/OQPfvCDE18aPnz4D3/4w8bGxkWLFpVSvvOd76xfv77PO39fAhYAAADAUHD88qgjR450t+b4S+edd977Dpw4ceLPf/7zHhYsXLjwJz/5SVtb24YNG9atW9fdw+P7z7cQAgAAAAwFzc3N1YO9e/d2t+b4S8cX98fIkSOvvPLK6vHatWv7P7A7AhYAAADAUPCxj32senD8wVWnqr40atSoiRMnDsibHr/qas+ePQMy8LQELAAAAIChYMaMGdWD3//+96ddsGfPnp07d1ZX9ubrDnvj0KFD1YPzzz9/QAaeloAFAAAAMBRcfvnlTU1NpZRnn332tAteeOGF6rPbr7766t4M/MY3vnH55ZdfccUV7733Xndr1q1bVz2YNm3aGe+41wQsAAAAgKFg5MiRc+bMKaVs2bLl+eefP3XBo48+Wj244YYbejPw0ksvfe2111avXv3QQw+ddsGWLVuqsWzSpEmXXnppH/fdCwIWAAAAwBDx7W9/u3pwxx13VC+2Ou63v/3t448/XkqZPn16tXMdt2fPnv/6kxO/wfArX/lKQ0NDKWXRokWn3pZ4+PDhb37zm4cPHy6lLF68uAb/NH8mYAEAAAAMEV/4wheuueaaUsqqVatuvvnm6hOvSinLly+/7rrr2tvbSymLFy8eNmzYiX+1fv36G//kD3/4w/Hft7S03HbbbaWUffv2tba23n333WvXrt2/f/+bb775yCOPfOITn/jVr35VSrn22msXLFhQ03+uykk1DgZK9WlwTjAAAKA/fLIgR/Vs/HrXAzWav6xySxmIs33Xrl2f/vSn33nnnVLKsGHDWlpa9u3bt3fv3uqrt99++49+9KOT/uTFF1+cNWtW9Xjbtm2TJk06/lJnZ+f111+/YsWK7t6utbX1scceu+CCC/q57Z65AgsAAABg6JgwYcIrr7wyb968YcOGdXR0bNu2rVqvxo8f/8ADD5xar3rW0NDwy1/+csmSJRMnTjzppebm5vvuu+/Xv/51retVcQUWteP/kwAAAP3nkwU5BssVWMe1tbWtWrVqx44dTU1N06ZN+9znPtfY2NjnaYcPH3799dfffvvt7du3jx49etq0aa2t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" /><h2 id="Barycentric-coordinate-API"><a class="docs-heading-anchor" href="#Barycentric-coordinate-API">Barycentric-coordinate API</a><a id="Barycentric-coordinate-API-1"></a><a class="docs-heading-anchor-permalink" href="#Barycentric-coordinate-API" title="Permalink"></a></h2><p>In some cases, we actually want barycentric interpolation, and have no interest in the coordinates themselves.</p><p>However, the coordinates can be useful for debugging, and when performing 3D rendering, multiple barycentric values (depth, uv) are needed for depth buffering.</p><pre><code class="language-julia hljs">const _VecTypes = Union{Tuple{Vararg{T, N}}, GeometryBasics.StaticArraysCore.StaticArray{Tuple{N}, T, 1}} where {N, T}

&quot;&quot;&quot;
    abstract type AbstractBarycentricCoordinateMethod

Abstract supertype for barycentric coordinate methods.
The subtypes may serve as dispatch types, or may cache
some information about the target polygon.

# API
The following methods must be implemented for all subtypes:
- `barycentric_coordinates!(λs::Vector{&lt;: Real}, method::AbstractBarycentricCoordinateMethod, exterior::Vector{&lt;: Point{2, T1}}, point::Point{2, T2})`
- `barycentric_interpolate(method::AbstractBarycentricCoordinateMethod, exterior::Vector{&lt;: Point{2, T1}}, values::Vector{V}, point::Point{2, T2})::V`
- `barycentric_interpolate(method::AbstractBarycentricCoordinateMethod, exterior::Vector{&lt;: Point{2, T1}}, interiors::Vector{&lt;: Vector{&lt;: Point{2, T1}}} values::Vector{V}, point::Point{2, T2})::V`
The rest of the methods will be implemented in terms of these, and have efficient dispatches for broadcasting.
&quot;&quot;&quot;
abstract type AbstractBarycentricCoordinateMethod end


Base.@propagate_inbounds function barycentric_coordinates!(λs::Vector{&lt;: Real}, method::AbstractBarycentricCoordinateMethod, polypoints::AbstractVector{&lt;: Point{N1, T1}}, point::Point{N2, T2}) where {N1, N2, T1 &lt;: Real, T2 &lt;: Real}
    @boundscheck @assert length(λs) == length(polypoints)
    @boundscheck @assert length(polypoints) &gt;= 3

    @error(&quot;Not implemented yet for method $(method).&quot;)
end

Base.@propagate_inbounds function barycentric_coordinates(method::AbstractBarycentricCoordinateMethod, polypoints::AbstractVector{&lt;: Point{N1, T1}}, point::Point{N2, T2}) where {N1, N2, T1 &lt;: Real, T2 &lt;: Real}
    λs = zeros(promote_type(T1, T2), length(polypoints))
    barycentric_coordinates!(λs, method, polypoints, point)
    return λs
end

Base.@propagate_inbounds function barycentric_interpolate(method::AbstractBarycentricCoordinateMethod, polypoints::AbstractVector{&lt;: Point{N, T1}}, values::AbstractVector{V}, point::Point{N, T2}) where {N, T1 &lt;: Real, T2 &lt;: Real, V}
    @boundscheck @assert length(values) == length(polypoints)
    @boundscheck @assert length(polypoints) &gt;= 3
    λs = barycentric_coordinates(method, polypoints, point)
    return sum(λs .* values)
end

Base.@propagate_inbounds function barycentric_interpolate(method::AbstractBarycentricCoordinateMethod, exterior::AbstractVector{&lt;: Point{N, T1}}, interiors::AbstractVector{&lt;: Point{N, T1}}, values::AbstractVector{V}, point::Point{N, T2}) where {N, T1 &lt;: Real, T2 &lt;: Real, V}
    @boundscheck @assert length(values) == length(exterior) + isempty(interiors) ? 0 : sum(length.(interiors))
    @boundscheck @assert length(exterior) &gt;= 3
    λs = barycentric_coordinates(method, exterior, interiors, point)
    return sum(λs .* values)
end

Base.@propagate_inbounds function barycentric_interpolate(method::AbstractBarycentricCoordinateMethod, polygon::Polygon{2, T1}, values::AbstractVector{V}, point::Point{2, T2}) where {T1 &lt;: Real, T2 &lt;: Real, V}
    exterior = decompose(Point{2, promote_type(T1, T2)}, polygon.exterior)
    if isempty(polygon.interiors)
        @boundscheck @assert length(values) == length(exterior)
        return barycentric_interpolate(method, exterior, values, point)
    else # the poly has interiors
        interiors = reverse.(decompose.((Point{2, promote_type(T1, T2)},), polygon.interiors))
        @boundscheck @assert length(values) == length(exterior) + sum(length.(interiors))
        return barycentric_interpolate(method, exterior, interiors, values, point)
    end
end</code></pre><p>3D polygons are considered to have their vertices in the XY plane, and the Z coordinate must represent some value.  This is to say that the Z coordinate is interpreted as an M coordinate.</p><pre><code class="language-julia hljs">Base.@propagate_inbounds function barycentric_interpolate(method::AbstractBarycentricCoordinateMethod, polygon::Polygon{3, T1}, point::Point{2, T2}) where {T1 &lt;: Real, T2 &lt;: Real, V}
    exterior_point3s = decompose(Point{3, promote_type(T1, T2)}, polygon.exterior)
    exterior_values = getindex.(exterior_point3s, 3)
    exterior_points = Point2f.(exterior_point3s)
    if isempty(polygon.interiors)
        return barycentric_interpolate(method, exterior_points, exterior_values, point)
    else # the poly has interiors
        interior_point3s = decompose.((Point{3, promote_type(T1, T2)},), polygon.interiors)
        interior_values = collect(Iterators.flatten((getindex.(point3s, 3) for point3s in interior_point3s)))
        interior_points = map(point3s -&gt; Point2f.(point3s), interior_point3s)
        return barycentric_interpolate(method, exterior_points, interior_points, vcat(exterior_values, interior_values), point)
    end
end</code></pre><p>This method is the one which supports GeoInterface.</p><pre><code class="language-julia hljs">Base.@propagate_inbounds function barycentric_interpolate(method::AbstractBarycentricCoordinateMethod, polygon, values::AbstractVector{V}, point) where V
    @assert GeoInterface.trait(polygon) isa GeoInterface.PolygonTrait
    @assert GeoInterface.trait(point) isa GeoInterface.PointTrait
    passable_polygon = GeoInterface.convert(GeometryBasics, polygon)
    @assert passable_polygon isa GeometryBasics.Polygon &quot;The polygon was converted to a $(typeof(passable_polygon)), which is not a `GeometryBasics.Polygon`.&quot;
    # first_poly_point = GeoInterface.getpoint(GeoInterface.getexterior(polygon))
    passable_point = GeoInterface.convert(GeometryBasics, point)
    return barycentric_interpolate(method, passable_polygon, Point2(passable_point))
end


&quot;&quot;&quot;
    weighted_mean(weight::Real, x1, x2)

Returns the weighted mean of `x1` and `x2`, where `weight` is the weight of `x1`.

Specifically, calculates `x1 * weight + x2 * (1 - weight)`.

!!! note
    The idea for this method is that you can override this for custom types, like Color types, in extension modules.
&quot;&quot;&quot;
function weighted_mean(weight::WT, x1, x2) where {WT &lt;: Real}
    return muladd(x1, weight, x2 * (oneunit(WT) - weight))
end


&quot;&quot;&quot;
    MeanValue() &lt;: AbstractBarycentricCoordinateMethod

This method calculates barycentric coordinates using the mean value method.

# References

&quot;&quot;&quot;
struct MeanValue &lt;: AbstractBarycentricCoordinateMethod
end</code></pre><p>Before we go to the actual implementation, there are some quick and simple utility functions that we need to implement.  These are mainly for convenience and code brevity.</p><pre><code class="language-julia hljs">&quot;&quot;&quot;
    _det(s1::Point2{T1}, s2::Point2{T2}) where {T1 &lt;: Real, T2 &lt;: Real}

Returns the determinant of the matrix formed by `hcat`&#39;ing two points `s1` and `s2`.

Specifically, this is:
```julia
s1[1] * s2[2] - s1[2] * s2[1]
```
&quot;&quot;&quot;
function _det(s1::_VecTypes{2, T1}, s2::_VecTypes{2, T2}) where {T1 &lt;: Real, T2 &lt;: Real}
    return s1[1] * s2[2] - s1[2] * s2[1]
end

&quot;&quot;&quot;
    t_value(sᵢ, sᵢ₊₁, rᵢ, rᵢ₊₁)

Returns the &quot;T-value&quot; as described in Hormann&#39;s presentation [^HormannPresentation] on how to calculate
the mean-value coordinate.

Here, `sᵢ` is the vector from vertex `vᵢ` to the point, and `rᵢ` is the norm (length) of `sᵢ`.
`s` must be `Point` and `r` must be real numbers.

```math
tᵢ = \\frac{\\mathrm{det}\\left(sᵢ, sᵢ₊₁\\right)}{rᵢ * rᵢ₊₁ + sᵢ ⋅ sᵢ₊₁}
```

[^HormannPresentation]: K. Hormann and N. Sukumar. Generalized Barycentric Coordinates in Computer Graphics and Computational Mechanics. Taylor &amp; Fancis, CRC Press, 2017.
```

&quot;&quot;&quot;
function t_value(sᵢ::_VecTypes{N, T1}, sᵢ₊₁::_VecTypes{N, T1}, rᵢ::T2, rᵢ₊₁::T2) where {N, T1 &lt;: Real, T2 &lt;: Real}
    return _det(sᵢ, sᵢ₊₁) / muladd(rᵢ, rᵢ₊₁, dot(sᵢ, sᵢ₊₁))
end


function barycentric_coordinates!(λs::Vector{&lt;: Real}, ::MeanValue, polypoints::AbstractVector{&lt;: Point{2, T1}}, point::Point{2, T2}) where {T1 &lt;: Real, T2 &lt;: Real}
    @boundscheck @assert length(λs) == length(polypoints)
    @boundscheck @assert length(polypoints) &gt;= 3
    n_points = length(polypoints)
    # Initialize counters and register variables
    # Points - these are actually vectors from point to vertices
    #  polypoints[i-1], polypoints[i], polypoints[i+1]
    sᵢ₋₁ = polypoints[end] - point
    sᵢ   = polypoints[begin] - point
    sᵢ₊₁ = polypoints[begin+1] - point
    # radius / Euclidean distance between points.
    rᵢ₋₁ = norm(sᵢ₋₁)
    rᵢ   = norm(sᵢ  )
    rᵢ₊₁ = norm(sᵢ₊₁)
    # Perform the first computation explicitly, so we can cut down on
    # a mod in the loop.
    λs[1] = (t_value(sᵢ₋₁, sᵢ, rᵢ₋₁, rᵢ) + t_value(sᵢ, sᵢ₊₁, rᵢ, rᵢ₊₁)) / rᵢ
    # Loop through the rest of the vertices, compute, store in λs
    for i in 2:n_points
        # Increment counters + set variables
        sᵢ₋₁ = sᵢ
        sᵢ   = sᵢ₊₁
        sᵢ₊₁ = polypoints[mod1(i+1, n_points)] - point
        rᵢ₋₁ = rᵢ
        rᵢ   = rᵢ₊₁
        rᵢ₊₁ = norm(sᵢ₊₁) # radius / Euclidean distance between points.
        λs[i] = (t_value(sᵢ₋₁, sᵢ, rᵢ₋₁, rᵢ) + t_value(sᵢ, sᵢ₊₁, rᵢ, rᵢ₊₁)) / rᵢ
    end
    # Normalize λs to the 1-norm (sum=1)
    λs ./= sum(λs)
    return λs
end</code></pre><pre><code class="language-julia hljs">function barycentric_coordinates(::MeanValue, polypoints::NTuple{N, Point{2, T2}}, point::Point{2, T1},) where {N, T1, T2}
    ## Initialize counters and register variables
    ## Points - these are actually vectors from point to vertices
    ##  polypoints[i-1], polypoints[i], polypoints[i+1]
    sᵢ₋₁ = polypoints[end] - point
    sᵢ   = polypoints[begin] - point
    sᵢ₊₁ = polypoints[begin+1] - point
    ## radius / Euclidean distance between points.
    rᵢ₋₁ = norm(sᵢ₋₁)
    rᵢ   = norm(sᵢ  )
    rᵢ₊₁ = norm(sᵢ₊₁)
    λ₁ = (t_value(sᵢ₋₁, sᵢ, rᵢ₋₁, rᵢ) + t_value(sᵢ, sᵢ₊₁, rᵢ, rᵢ₊₁)) / rᵢ
    λs = ntuple(N) do i
        if i == 1
            return λ₁
        end
        ## Increment counters + set variables
        sᵢ₋₁ = sᵢ
        sᵢ   = sᵢ₊₁
        sᵢ₊₁ = polypoints[mod1(i+1, N)] - point
        rᵢ₋₁ = rᵢ
        rᵢ   = rᵢ₊₁
        rᵢ₊₁ = norm(sᵢ₊₁) # radius / Euclidean distance between points.
        return (t_value(sᵢ₋₁, sᵢ, rᵢ₋₁, rᵢ) + t_value(sᵢ, sᵢ₊₁, rᵢ, rᵢ₊₁)) / rᵢ
    end

    ∑λ = sum(λs)

    return ntuple(N) do i
        λs[i] / ∑λ
    end
end</code></pre><p>This performs an inplace accumulation, using less memory and is faster. That&#39;s particularly good if you are using a polygon with a large number of points...</p><pre><code class="language-julia hljs">function barycentric_interpolate(::MeanValue, polypoints::AbstractVector{&lt;: Point{2, T1}}, values::AbstractVector{V}, point::Point{2, T2}) where {T1 &lt;: Real, T2 &lt;: Real, V}
    @boundscheck @assert length(values) == length(polypoints)
    @boundscheck @assert length(polypoints) &gt;= 3

    n_points = length(polypoints)
    # Initialize counters and register variables
    # Points - these are actually vectors from point to vertices
    #  polypoints[i-1], polypoints[i], polypoints[i+1]
    sᵢ₋₁ = polypoints[end] - point
    sᵢ   = polypoints[begin] - point
    sᵢ₊₁ = polypoints[begin+1] - point
    # radius / Euclidean distance between points.
    rᵢ₋₁ = norm(sᵢ₋₁)
    rᵢ   = norm(sᵢ  )
    rᵢ₊₁ = norm(sᵢ₊₁)
    # Now, we set the interpolated value to the first point&#39;s value, multiplied
    # by the weight computed relative to the first point in the polygon.
    wᵢ = (t_value(sᵢ₋₁, sᵢ, rᵢ₋₁, rᵢ) + t_value(sᵢ, sᵢ₊₁, rᵢ, rᵢ₊₁)) / rᵢ
    wₜₒₜ = wᵢ
    interpolated_value = values[begin] * wᵢ
    for i in 2:n_points
        # Increment counters + set variables
        sᵢ₋₁ = sᵢ
        sᵢ   = sᵢ₊₁
        sᵢ₊₁ = polypoints[mod1(i+1, n_points)] - point
        rᵢ₋₁ = rᵢ
        rᵢ   = rᵢ₊₁
        rᵢ₊₁ = norm(sᵢ₊₁)
        # Now, we calculate the weight:
        wᵢ = (t_value(sᵢ₋₁, sᵢ, rᵢ₋₁, rᵢ) + t_value(sᵢ, sᵢ₊₁, rᵢ, rᵢ₊₁)) / rᵢ
        # perform a weighted sum with the interpolated value:
        interpolated_value += values[i] * wᵢ
        # and add the weight to the total weight accumulator.
        wₜₒₜ += wᵢ
    end
    # Return the normalized interpolated value.
    return interpolated_value / wₜₒₜ
end</code></pre><p>When you have holes, then you have to be careful about the order you iterate around points.</p><p>Specifically, you have to iterate around each linear ring separately and ensure there are no degenerate/repeated points at the start and end!</p><pre><code class="language-julia hljs">function barycentric_interpolate(::MeanValue, exterior::AbstractVector{&lt;: Point{N, T1}}, interiors::AbstractVector{&lt;: AbstractVector{&lt;: Point{N, T1}}}, values::AbstractVector{V}, point::Point{N, T2}) where {N, T1 &lt;: Real, T2 &lt;: Real, V}
    # @boundscheck @assert length(values) == (length(exterior) + isempty(interiors) ? 0 : sum(length.(interiors)))
    # @boundscheck @assert length(exterior) &gt;= 3

    current_index = 1
    l_exterior = length(exterior)

    sᵢ₋₁ = exterior[end] - point
    sᵢ   = exterior[begin] - point
    sᵢ₊₁ = exterior[begin+1] - point
    rᵢ₋₁ = norm(sᵢ₋₁) # radius / Euclidean distance between points.
    rᵢ   = norm(sᵢ  ) # radius / Euclidean distance between points.
    rᵢ₊₁ = norm(sᵢ₊₁) # radius / Euclidean distance between points.</code></pre><p>Now, we set the interpolated value to the first point&#39;s value, multiplied by the weight computed relative to the first point in the polygon.</p><pre><code class="language-julia hljs">    wᵢ = (t_value(sᵢ₋₁, sᵢ, rᵢ₋₁, rᵢ) + t_value(sᵢ, sᵢ₊₁, rᵢ, rᵢ₊₁)) / rᵢ
    wₜₒₜ = wᵢ
    interpolated_value = values[begin] * wᵢ

    for i in 2:l_exterior</code></pre><p>Increment counters + set variables</p><pre><code class="language-julia hljs">        sᵢ₋₁ = sᵢ
        sᵢ   = sᵢ₊₁
        sᵢ₊₁ = exterior[mod1(i+1, l_exterior)] - point
        rᵢ₋₁ = rᵢ
        rᵢ   = rᵢ₊₁
        rᵢ₊₁ = norm(sᵢ₊₁) # radius / Euclidean distance between points.
        wᵢ = (t_value(sᵢ₋₁, sᵢ, rᵢ₋₁, rᵢ) + t_value(sᵢ, sᵢ₊₁, rᵢ, rᵢ₊₁)) / rᵢ</code></pre><p>Updates - first the interpolated value,</p><pre><code class="language-julia hljs">        interpolated_value += values[current_index] * wᵢ</code></pre><p>then the accumulators for total weight and current index.</p><pre><code class="language-julia hljs">        wₜₒₜ += wᵢ
        current_index += 1

    end
    for hole in interiors
        l_hole = length(hole)
        sᵢ₋₁ = hole[end] - point
        sᵢ   = hole[begin] - point
        sᵢ₊₁ = hole[begin+1] - point
        rᵢ₋₁ = norm(sᵢ₋₁) # radius / Euclidean distance between points.
        rᵢ   = norm(sᵢ  ) # radius / Euclidean distance between points.
        rᵢ₊₁ = norm(sᵢ₊₁) # radius / Euclidean distance between points.
        # Now, we set the interpolated value to the first point&#39;s value, multiplied
        # by the weight computed relative to the first point in the polygon.
        wᵢ = (t_value(sᵢ₋₁, sᵢ, rᵢ₋₁, rᵢ) + t_value(sᵢ, sᵢ₊₁, rᵢ, rᵢ₊₁)) / rᵢ

        interpolated_value += values[current_index] * wᵢ

        wₜₒₜ += wᵢ
        current_index += 1

        for i in 2:l_hole
            # Increment counters + set variables
            sᵢ₋₁ = sᵢ
            sᵢ   = sᵢ₊₁
            sᵢ₊₁ = hole[mod1(i+1, l_hole)] - point
            rᵢ₋₁ = rᵢ
            rᵢ   = rᵢ₊₁
            rᵢ₊₁ = norm(sᵢ₊₁) ## radius / Euclidean distance between points.
            wᵢ = (t_value(sᵢ₋₁, sᵢ, rᵢ₋₁, rᵢ) + t_value(sᵢ, sᵢ₊₁, rᵢ, rᵢ₊₁)) / rᵢ
            interpolated_value += values[current_index] * wᵢ
            wₜₒₜ += wᵢ
            current_index += 1
        end
    end
    return interpolated_value / wₜₒₜ

end

struct Wachspress &lt;: AbstractBarycentricCoordinateMethod
end</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../utils/">« -</a><a class="docs-footer-nextpage" href="../centroid/">- »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Wednesday 31 May 2023 02:59">Wednesday 31 May 2023</span>. Using Julia version 1.9.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
