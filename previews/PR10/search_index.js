var documenterSearchIndex = {"docs":
[{"location":"source/GeometryOps/","page":"-","title":"-","text":"module GeometryOps\n\nusing GeoInterface\nusing GeometryBasics\nimport Proj\nusing LinearAlgebra\n\nconst GI = GeoInterface\nconst GB = GeometryBasics\n\ninclude(\"primitives.jl\")\ninclude(\"methods/signed_distance.jl\")\ninclude(\"methods/signed_area.jl\")\ninclude(\"methods/centroid.jl\")\ninclude(\"methods/contains.jl\")\ninclude(\"methods/barycentric.jl\")\ninclude(\"transformations/reproject.jl\")\ninclude(\"transformations/flip.jl\")\n\nend","category":"page"},{"location":"source/GeometryOps/","page":"-","title":"-","text":"","category":"page"},{"location":"source/GeometryOps/","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"\"\"\"\n    apply(f, target::Type{<:AbstractTrait}, obj; crs)\n\nReconstruct a geometry or feature using the function `f` on the `target` trait.\n\n`f(target_geom) => x` where `x` also has the `target` trait, or an equivalent.\n\nThe result is an functionally similar geometry with values depending on `f`","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"Flipped point the order in any feature or geometry, or iterables of either:","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"```juia\nimport GeoInterface as GI\nimport GeometryOps as GO\ngeom = GI.Polygon([GI.LinearRing([(1, 2), (3, 4), (5, 6), (1, 2)]),\n                   GI.LinearRing([(3, 4), (5, 6), (6, 7), (3, 4)])])\n\nflipped_geom = GO.apply(GI.PointTrait, geom) do p\n    (GI.y(p), GI.x(p))\nend\n\"\"\"\napply(f, ::Type{Target}, geom; crs=nothing)  where Target<:GI.AbstractTrait =\n    _apply(f, Target, geom; crs)\n\n_apply(f, ::Type{Target}, geom; crs)  where Target =\n    _apply(f, Target, GI.trait(geom), geom; crs)","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"Try to _apply over iterables","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"_apply(f, ::Type{Target}, ::Nothing, iterable; crs) where Target =\n    map(x -> _apply(f, Target, x; crs), iterable)","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"Rewrap feature collections","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"function _apply(f, ::Type{Target}, ::GI.FeatureCollectionTrait, fc; crs=GI.crs(fc)) where Target\n    features = map(GI.getfeature(fc)) do feature\n        _apply(f, Target, feature)\n    end\n    return FeatureCollection(features; crs)\nend","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"Rewrap features","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"function _apply(f, ::Type{Target}, ::GI.FeatureTrait, feature; crs=GI.crs(feature)) where Target\n    properties = GI.properties(feature)\n    geometry = _apply(f, Target, geometry(feature); crs)\n    return Feature(geometry; properties, crs)\nend","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"Reconstruct nested geometries","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"function _apply(f, ::Type{Target}, trait, geom; crs=GI.crs(geom))::(GI.geointerface_geomtype(trait)) where Target","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"TODO handle zero length...","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"    geoms = map(g -> _apply(f, Target, g; crs), GI.getgeom(geom), )\n    return rebuild(geom, geoms)\nend","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"Apply f to the target geometry","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"_apply(f, ::Type{Target}, ::Trait, geom; crs=nothing) where {Target,Trait<:Target} = f(geom)","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"Fail if we hit PointTrait without running f","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"_apply(f, ::Type{Target}, trait::GI.PointTrait, geom; crs=nothing) where Target =\n    throw(ArgumentError(\"target $Target not found, but reached a `PointTrait` leaf\"))","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"Specific cases to avoid method ambiguity","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"_apply(f, ::Type{GI.PointTrait}, trait::GI.PointTrait, geom; crs=nothing) = f(geom)\n_apply(f, ::Type{GI.FeatureTrait}, ::GI.FeatureTrait, feature; crs=nothing) = f(feature)\n_apply(f, ::Type{GI.FeatureCollectionTrait}, ::GI.FeatureCollectionTrait, fc; crs=nothing) = f(fc)\n\n\"\"\"\n    unwrap(target::Type{<:AbstractTrait}, obj)\n    unwrap(f, target::Type{<:AbstractTrait}, obj)\n\nUnwrap the geometry to vectors, down to the target trait.\n\nIf `f` is passed in it will be applied to the target geometries\nas they are found.\n\"\"\"\nfunction unwrap end\nunwrap(target::Type, geom) = unwrap(identity, target, geom)","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"Add dispatch argument for trait","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"unwrap(f, target::Type, geom) = unwrap(f, target, GI.trait(geom), geom)","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"Try to unwrap over iterables","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"unwrap(f, target::Type, ::Nothing, iterable) =\n    map(x -> unwrap(f, target, x), iterable)","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"Rewrap feature collections","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"unwrap(f, target::Type, ::GI.FeatureCollectionTrait, fc) =\n    map(x -> unwrap(f, target, x), GI.getfeature(fc))\nunwrap(f, target::Type, ::GI.FeatureTrait, feature) = unwrap(f, target, geometry(feature))\nunwrap(f, target::Type, trait, geom) = map(g -> unwrap(f, target, g), GI.getgeom(geom))","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"Apply f to the target geometry","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"unwrap(f, ::Type{Target}, ::Trait, geom) where {Target,Trait<:Target} = f(geom)","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"Fail if we hit PointTrait","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"unwrap(f, target::Type, trait::GI.PointTrait, geom) =\n    throw(ArgumentError(\"target $target not found, but reached a `PointTrait` leaf\"))","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"Specific cases to avoid method ambiguity","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"unwrap(f, target::Type{GI.PointTrait}, trait::GI.PointTrait, geom) = f(geom)\nunwrap(f, target::Type{GI.FeatureTrait}, ::GI.FeatureTrait, feature) = f(feature)\nunwrap(f, target::Type{GI.FeatureCollectionTrait}, ::GI.FeatureCollectionTrait, fc) = f(fc)\n\n\"\"\"\n    flatten(target::Type{<:GI.AbstractTrait}, geom)\n\nLazily flatten any geometry, feature or iterator of geometries or features\nso that objects with the specified trait are returned by the iterator.\n\"\"\"\nflatten(::Type{Target}, geom) where {Target<:GI.AbstractTrait} = flatten(identity, Target, geom)\nflatten(f, ::Type{Target}, geom) where {Target<:GI.AbstractTrait} = _flatten(f, Target, geom)\n\n_flatten(f, ::Type{Target}, geom) where Target = _flatten(f, Target, GI.trait(geom), geom)","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"Try to flatten over iterables","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"_flatten(f, ::Type{Target}, ::Nothing, iterable) where Target =\n    Iterators.flatten(Iterators.map(x -> _flatten(f, Target, x), iterable))","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"Flatten feature collections","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"function _flatten(f, ::Type{Target}, ::GI.FeatureCollectionTrait, fc) where Target\n    Iterators.map(GI.getfeature(fc)) do feature\n        _flatten(f, Target, feature)\n    end |> Iterators.flatten\nend\n_flatten(f, ::Type{Target}, ::GI.FeatureTrait, feature) where Target =\n    _flatten(f, Target, GI.geometry(feature))","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"Apply f to the target geometry","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"_flatten(f, ::Type{Target}, ::Trait, geom) where {Target,Trait<:Target} = (f(geom),)\n_flatten(f, ::Type{Target}, trait, geom) where Target =\n    Iterators.flatten(Iterators.map(g -> _flatten(f, Target, g), GI.getgeom(geom)))","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"Fail if we hit PointTrait without running f","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"_flatten(f, ::Type{Target}, trait::GI.PointTrait, geom) where Target =\n    throw(ArgumentError(\"target $Target not found, but reached a `PointTrait` leaf\"))","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"Specific cases to avoid method ambiguity","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"_flatten(f, ::Type{<:GI.PointTrait}, ::GI.PointTrait, geom) = (f(geom),)\n_flatten(f, ::Type{<:GI.FeatureTrait}, ::GI.FeatureTrait, feature) = (f(feature),)\n_flatten(f, ::Type{<:GI.FeatureCollectionTrait}, ::GI.FeatureCollectionTrait, fc) = (f(fc),)\n\n\n\"\"\"\n    reconstruct(geom, components)\n\nReconstruct `geom` from an iterable of component objects that match its structure.\n\nAll objects in `components` must have the same `GeoInterface.trait`.\n\nUsusally used in combination with `flatten`.\n\"\"\"\nreconstruct(geom, components) = first(_reconstruct(geom, components))\n\n_reconstruct(geom, components) =\n    _reconstruct(typeof(GI.trait(first(components))), GI.trait(geom), geom, components, 1)","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"Try to reconstruct over iterables","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"function _reconstruct(::Type{Target}, ::Nothing, iterable, components, iter) where Target\n    vect = map(iterable) do x\n        obj, iter = _reconstruct(Target, x, components, iter)\n        obj\n    end\n    return vect, iter\nend","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"Reconstruct feature collections","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"function _reconstruct(::Type{Target}, ::GI.FeatureCollectionTrait, fc, components, iter) where Target\n    features = map(GI.getfeature(fc)) do feature\n        newfeature, iter = _reconstruct(Target, feature, components, iter)\n        newfeature\n    end\n    return FeatureCollection(features; crs=GI.crs(fc)), iter\nend\nfunction _reconstruct(::Type{Target}, ::GI.FeatureTrait, feature, components, iter) where Target\n    geom, iter = _reconstruct(Target, geometry(feature), components, iter)\n    return Feature(geom; properties=GI.properties(feature), crs=GI.crs(feature)), iter\nend\nfunction _reconstruct(::Type{Target}, trait, geom, components, iter) where Target\n    geoms = map(GI.getgeom(geom)) do subgeom\n        subgeom1, iter = _reconstruct(Target, GI.trait(subgeom), subgeom, components, iter)\n        subgeom1\n    end\n    return rebuild(geom, geoms), iter\nend","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"Apply f to the target geometry","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"_reconstruct(::Type{Target}, ::Trait, geom, components, iter) where {Target,Trait<:Target} =\n    iterate(components, iter)","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"Specific cases to avoid method ambiguity","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"_reconstruct(::Type{<:GI.PointTrait}, ::GI.PointTrait, geom, components, iter) = iterate(components, iter)\n_reconstruct(::Type{<:GI.FeatureTrait}, ::GI.FeatureTrait, feature, components, iter) = iterate(feature, iter)\n_reconstruct(::Type{<:GI.FeatureCollectionTrait}, ::GI.FeatureCollectionTrait, fc, components, iter) = iterate(fc, iter)","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"Fail if we hit PointTrait without running f","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"_reconstruct(::Type{Target}, trait::GI.PointTrait, geom, components, iter) where Target =\n    throw(ArgumentError(\"target $Target not found, but reached a `PointTrait` leaf\"))\n\n\nconst BasicsGeoms = Union{GB.AbstractGeometry,GB.AbstractFace,GB.AbstractPoint,GB.AbstractMesh,\n    GB.AbstractPolygon,GB.LineString,GB.MultiPoint,GB.MultiLineString,GB.MultiPolygon,GB.Mesh}\n\n\"\"\"\n    rebuild(geom, child_geoms)\n\nRebuild a geometry from child geometries.\n\nBy default geometries will be rebuilt as a GeoInterface.Wrappers\ngeometry, but `rebuild` can have methods added to it to dispatch\non geometries from other packages and specify how to rebuild them.\n\n(Maybe it should go into GeoInterface.jl)\n\"\"\"\nrebuild(geom, child_geoms) = rebuild(GI.trait(geom), geom, child_geoms)\nfunction rebuild(trait::GI.AbstractTrait, geom, child_geoms; crs=GI.crs(geom))\n    T = GI.geointerface_geomtype(trait)\n    if GI.is3d(geom)","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"The Boolean type parameters here indicate 3d-ness and measure coordinate presence respectively.","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"        return T{true,false}(child_geoms; crs)\n    else\n        return T{false,false}(child_geoms; crs)\n    end\nend","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"So that GeometryBasics geoms rebuild as themselves","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"function rebuild(trait::GI.AbstractTrait, geom::BasicsGeoms, child_geoms; crs=nothing)\n    GB.geointerface_geomtype(trait)(child_geoms)\nend\nfunction rebuild(trait::GI.AbstractTrait, geom::Union{GB.LineString,GB.MultiPoint}, child_geoms; crs=nothing)\n    GB.geointerface_geomtype(trait)(GI.convert.(GB.Point, child_geoms))\nend\nfunction rebuild(trait::GI.PolygonTrait, geom::GB.Polygon, child_geoms; crs=nothing)\n    Polygon(child_geoms[1], child_geoms[2:end])\nend","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"source/transformations/reproject/","page":"-","title":"-","text":"\"\"\"\n    reproject(geometry; source_crs, target_crs, transform, always_xy, time)\n    reproject(geometry, source_crs, target_crs; always_xy, time)\n    reproject(geometry, transform; always_xy, time)\n\nReproject any GeoInterface.jl compatible `geometry` from `source_crs` to `target_crs`.\n\nThe returned object will be constructed from `GeoInterface.WrapperGeometry`\ngeometries, wrapping views of a `Vector{Proj.Point{D}}`, where `D` is the dimension.","category":"page"},{"location":"source/transformations/reproject/","page":"-","title":"-","text":"Arguments","category":"page"},{"location":"source/transformations/reproject/","page":"-","title":"-","text":"- `geometry`: Any GeoInterface.jl compatible geometries.\n- `source_crs`: the source coordinate referece system, as a GeoFormatTypes.jl object or a string.\n- `target_crs`: the target coordinate referece system, as a GeoFormatTypes.jl object or a string.\n\nIf these a passed as keywords, `transform` will take priority.\nWithout it `target_crs` is always needed, and `source_crs` is\nneeded if it is not retreivable from the geometry with `GeoInterface.crs(geometry)`.","category":"page"},{"location":"source/transformations/reproject/","page":"-","title":"-","text":"Keywords","category":"page"},{"location":"source/transformations/reproject/","page":"-","title":"-","text":"-`always_xy`: force x, y coordinate order, `true` by default.\n    `false` will expect and return points in the crs coordinate order.\n-`time`: the time for the coordinates. `Inf` by default.\n\"\"\"\nfunction reproject(geom;\n    source_crs=nothing, target_crs=nothing, transform=nothing, kw...\n)\n    if isnothing(transform)\n        source_crs = isnothing(source_crs) ? GeoInterface.crs(geom) : source_crs\n        isnothing(source_crs) && throw(ArgumentError(\"geom has no crs attatched. Pass a `source_crs` keyword\"))\n        reproject(geom, source_crs, target_crs; kw...)\n    else\n        reproject(geom, transform; kw...)\n    end\nend\nfunction reproject(geom, source_crs, target_crs;\n    time=Inf,\n    always_xy=true,\n    transform=Proj.Transformation(Proj.CRS(source_crs), Proj.CRS(target_crs); always_xy),\n)\n    reproject(geom, transform; time, target_crs)\nend\nfunction reproject(geom, transform::Proj.Transformation; time=Inf, target_crs=nothing)\n    if _is3d(geom)\n        return apply(PointTrait, geom; crs=target_crs) do p\n            transform(GI.x(p), GI.y(p), GI.z(p))\n        end\n    else\n        return apply(PointTrait, geom; crs=target_crs) do p\n            transform(GI.x(p), GI.y(p))\n        end\n    end\nend\n\n_is3d(geom) = _is3d(GI.trait(geom), geom)\n_is3d(::GI.AbstractGeometryTrait, geom) = GI.is3d(geom)\n_is3d(::GI.Feature, feature) = _is3d(GI.geometry(feature))\n_is3d(::GI.FeatureCollection, fc) = _is3d(GI.getfeature(fc, 1))\n_is3d(::Nothing, geom) = _is3d(first(geom)) # Otherwise step into an itererable","category":"page"},{"location":"source/transformations/reproject/","page":"-","title":"-","text":"","category":"page"},{"location":"source/transformations/reproject/","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"source/methods/barycentric/#Barycentric-coordinates","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"","category":"section"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"export barycentric_coordinates, barycentric_coordinates!, barycentric_interpolate\nexport MeanValue","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"Generalized barycentric coordinates are a generalization of barycentric coordinates, which are typically used in triangles, to arbitrary polygons.","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"They provide a way to express a point within a polygon as a weighted average of the polygon's vertices.","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"In the case of a triangle, barycentric coordinates are a set of three numbers (λ_1 λ_2 λ_3), each associated with a vertex of the triangle. Any point within the triangle can be expressed as a weighted average of the vertices, where the weights are the barycentric coordinates. The weights sum to 1, and each is non-negative.","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"For a polygon with n vertices, generalized barycentric coordinates are a set of n numbers (λ_1 λ_2  λ_n), each associated with a vertex of the polygon. Any point within the polygon can be expressed as a weighted average of the vertices, where the weights are the generalized barycentric coordinates.","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"As with the triangle case, the weights sum to 1, and each is non-negative.","category":"page"},{"location":"source/methods/barycentric/#Example","page":"Barycentric coordinates","title":"Example","text":"","category":"section"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"This example was taken from this page of CGAL's documentation.","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"using GeometryOps, Makie\nusing GeometryOps.GeometryBasics\n# Define a polygon\npolygon_points = Point3f[\n(0.03, 0.05, 0.00), (0.07, 0.04, 0.02), (0.10, 0.04, 0.04),\n(0.14, 0.04, 0.06), (0.17, 0.07, 0.08), (0.20, 0.09, 0.10),\n(0.22, 0.11, 0.12), (0.25, 0.11, 0.14), (0.27, 0.10, 0.16),\n(0.30, 0.07, 0.18), (0.31, 0.04, 0.20), (0.34, 0.03, 0.22),\n(0.37, 0.02, 0.24), (0.40, 0.03, 0.26), (0.42, 0.04, 0.28),\n(0.44, 0.07, 0.30), (0.45, 0.10, 0.32), (0.46, 0.13, 0.34),\n(0.46, 0.19, 0.36), (0.47, 0.26, 0.38), (0.47, 0.31, 0.40),\n(0.47, 0.35, 0.42), (0.45, 0.37, 0.44), (0.41, 0.38, 0.46),\n(0.38, 0.37, 0.48), (0.35, 0.36, 0.50), (0.32, 0.35, 0.52),\n(0.30, 0.37, 0.54), (0.28, 0.39, 0.56), (0.25, 0.40, 0.58),\n(0.23, 0.39, 0.60), (0.21, 0.37, 0.62), (0.21, 0.34, 0.64),\n(0.23, 0.32, 0.66), (0.24, 0.29, 0.68), (0.27, 0.24, 0.70),\n(0.29, 0.21, 0.72), (0.29, 0.18, 0.74), (0.26, 0.16, 0.76),\n(0.24, 0.17, 0.78), (0.23, 0.19, 0.80), (0.24, 0.22, 0.82),\n(0.24, 0.25, 0.84), (0.21, 0.26, 0.86), (0.17, 0.26, 0.88),\n(0.12, 0.24, 0.90), (0.07, 0.20, 0.92), (0.03, 0.15, 0.94),\n(0.01, 0.10, 0.97), (0.02, 0.07, 1.00)]\n# Plot it generally\nf, a, p = poly(polygon_points; color = last.(polygon_points), colormap = cgrad(:jet, 18; categorical = true), shading = false, axis = (; aspect = DataAspect(), title = \"Makie mesh based polygon rendering\", subtitle = \"Makie\"))\ncb = Colorbar(f[1, 2], p.plots[1])\nhidedecorations!(a)\nf\nax_bbox = a.finallimits[]\next = GeometryOps.GI.Extent(NamedTuple{(:X, :Y)}(zip(minimum(ax_bbox), maximum(ax_bbox))))\nxrange = LinRange(ext.X..., widths(a.scene.px_area[])[1])\nyrange = LinRange(ext.Y..., widths(a.scene.px_area[])[2])\n@time mean_values = barycentric_interpolate.(\n    (MeanValue(),),\n    (Point2f.(polygon_points),),\n    (last.(polygon_points,),),\n    Point2f.(xrange, yrange')\n)\n\nfig, ax, mvplt = heatmap(\n    xrange, yrange, mean_values;\n    colormap = cgrad(:jet, 18; categorical = true),\n    axis = (; aspect = DataAspect(), title = \"Barycentric coordinate based rendering\", subtitle = \"Mean value method\"),\n    colorrange = Makie.distinct_extrema_nan(last.(polygon_points)),\n)\nhidedecorations!(ax)\ncb = Colorbar(fig[1, 2], mvplt)\n# Crop out everything outside the polygon\npoly!(ax, GeometryOps.GeometryBasics.Polygon(Point2f[(ext.X[1], ext.Y[1]), (ext.X[2], ext.Y[1]), (ext.X[2], ext.Y[2]), (ext.X[1], ext.Y[2]), (ext.X[1], ext.Y[1])], [reverse(Point2f.(polygon_points))]); color = :white, xautolimits = false, yautolimits = false)\nfig","category":"page"},{"location":"source/methods/barycentric/#Barycentric-coordinate-API","page":"Barycentric coordinates","title":"Barycentric-coordinate API","text":"","category":"section"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"In some cases, we actually want barycentric interpolation, and have no interest in the coordinates themselves.","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"However, the coordinates can be useful for debugging, and when performing 3D rendering, multiple barycentric values (depth, uv) are needed for depth buffering.","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"const _VecTypes = Union{Tuple{Vararg{T, N}}, GeometryBasics.StaticArraysCore.StaticArray{Tuple{N}, T, 1}} where {N, T}\n\n\"\"\"\n    abstract type AbstractBarycentricCoordinateMethod\n\nAbstract supertype for barycentric coordinate methods.\nThe subtypes may serve as dispatch types, or may cache\nsome information about the target polygon.\n\n# API\nThe following methods must be implemented for all subtypes:\n- `barycentric_coordinates!(λs::Vector{<: Real}, method::AbstractBarycentricCoordinateMethod, exterior::Vector{<: Point{2, T1}}, point::Point{2, T2})`\n- `barycentric_interpolate(method::AbstractBarycentricCoordinateMethod, exterior::Vector{<: Point{2, T1}}, values::Vector{V}, point::Point{2, T2})::V`\n- `barycentric_interpolate(method::AbstractBarycentricCoordinateMethod, exterior::Vector{<: Point{2, T1}}, interiors::Vector{<: Vector{<: Point{2, T1}}} values::Vector{V}, point::Point{2, T2})::V`\nThe rest of the methods will be implemented in terms of these, and have efficient dispatches for broadcasting.\n\"\"\"\nabstract type AbstractBarycentricCoordinateMethod end\n\n\nBase.@propagate_inbounds function barycentric_coordinates!(λs::Vector{<: Real}, method::AbstractBarycentricCoordinateMethod, polypoints::AbstractVector{<: Point{N1, T1}}, point::Point{N2, T2}) where {N1, N2, T1 <: Real, T2 <: Real}\n    @boundscheck @assert length(λs) == length(polypoints)\n    @boundscheck @assert length(polypoints) >= 3\n\n    @error(\"Not implemented yet for method $(method).\")\nend\n\nBase.@propagate_inbounds function barycentric_coordinates(method::AbstractBarycentricCoordinateMethod, polypoints::AbstractVector{<: Point{N1, T1}}, point::Point{N2, T2}) where {N1, N2, T1 <: Real, T2 <: Real}\n    λs = zeros(promote_type(T1, T2), length(polypoints))\n    barycentric_coordinates!(λs, method, polypoints, point)\n    return λs\nend\n\nBase.@propagate_inbounds function barycentric_interpolate(method::AbstractBarycentricCoordinateMethod, polypoints::AbstractVector{<: Point{N, T1}}, values::AbstractVector{V}, point::Point{N, T2}) where {N, T1 <: Real, T2 <: Real, V}\n    @boundscheck @assert length(values) == length(polypoints)\n    @boundscheck @assert length(polypoints) >= 3\n    λs = barycentric_coordinates(method, polypoints, point)\n    return sum(λs .* values)\nend\n\nBase.@propagate_inbounds function barycentric_interpolate(method::AbstractBarycentricCoordinateMethod, exterior::AbstractVector{<: Point{N, T1}}, interiors::AbstractVector{<: Point{N, T1}}, values::AbstractVector{V}, point::Point{N, T2}) where {N, T1 <: Real, T2 <: Real, V}\n    @boundscheck @assert length(values) == length(exterior) + isempty(interiors) ? 0 : sum(length.(interiors))\n    @boundscheck @assert length(exterior) >= 3\n    λs = barycentric_coordinates(method, exterior, interiors, point)\n    return sum(λs .* values)\nend\n\nBase.@propagate_inbounds function barycentric_interpolate(method::AbstractBarycentricCoordinateMethod, polygon::Polygon{2, T1}, values::AbstractVector{V}, point::Point{2, T2}) where {T1 <: Real, T2 <: Real, V}\n    exterior = decompose(Point{2, promote_type(T1, T2)}, polygon.exterior)\n    if isempty(polygon.interiors)\n        @boundscheck @assert length(values) == length(exterior)\n        return barycentric_interpolate(method, exterior, values, point)\n    else # the poly has interiors\n        interiors = reverse.(decompose.((Point{2, promote_type(T1, T2)},), polygon.interiors))\n        @boundscheck @assert length(values) == length(exterior) + sum(length.(interiors))\n        return barycentric_interpolate(method, exterior, interiors, values, point)\n    end\nend","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"3D polygons are considered to have their vertices in the XY plane, and the Z coordinate must represent some value.  This is to say that the Z coordinate is interpreted as an M coordinate.","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"Base.@propagate_inbounds function barycentric_interpolate(method::AbstractBarycentricCoordinateMethod, polygon::Polygon{3, T1}, point::Point{2, T2}) where {T1 <: Real, T2 <: Real, V}\n    exterior_point3s = decompose(Point{3, promote_type(T1, T2)}, polygon.exterior)\n    exterior_values = getindex.(exterior_point3s, 3)\n    exterior_points = Point2f.(exterior_point3s)\n    if isempty(polygon.interiors)\n        return barycentric_interpolate(method, exterior_points, exterior_values, point)\n    else # the poly has interiors\n        interior_point3s = decompose.((Point{3, promote_type(T1, T2)},), polygon.interiors)\n        interior_values = collect(Iterators.flatten((getindex.(point3s, 3) for point3s in interior_point3s)))\n        interior_points = map(point3s -> Point2f.(point3s), interior_point3s)\n        return barycentric_interpolate(method, exterior_points, interior_points, vcat(exterior_values, interior_values), point)\n    end\nend","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"This method is the one which supports GeoInterface.","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"Base.@propagate_inbounds function barycentric_interpolate(method::AbstractBarycentricCoordinateMethod, polygon, values::AbstractVector{V}, point) where V\n    @assert GeoInterface.trait(polygon) isa GeoInterface.PolygonTrait\n    @assert GeoInterface.trait(point) isa GeoInterface.PointTrait\n    passable_polygon = GeoInterface.convert(GeometryBasics, polygon)\n    @assert passable_polygon isa GeometryBasics.Polygon \"The polygon was converted to a $(typeof(passable_polygon)), which is not a `GeometryBasics.Polygon`.\"\n    # first_poly_point = GeoInterface.getpoint(GeoInterface.getexterior(polygon))\n    passable_point = GeoInterface.convert(GeometryBasics, point)\n    return barycentric_interpolate(method, passable_polygon, Point2(passable_point))\nend\n\n\n\"\"\"\n    weighted_mean(weight::Real, x1, x2)\n\nReturns the weighted mean of `x1` and `x2`, where `weight` is the weight of `x1`.\n\nSpecifically, calculates `x1 * weight + x2 * (1 - weight)`.\n\n!!! note\n    The idea for this method is that you can override this for custom types, like Color types, in extension modules.\n\"\"\"\nfunction weighted_mean(weight::WT, x1, x2) where {WT <: Real}\n    return muladd(x1, weight, x2 * (oneunit(WT) - weight))\nend\n\n\n\"\"\"\n    MeanValue() <: AbstractBarycentricCoordinateMethod\n\nThis method calculates barycentric coordinates using the mean value method.\n\n# References\n\n\"\"\"\nstruct MeanValue <: AbstractBarycentricCoordinateMethod\nend","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"Before we go to the actual implementation, there are some quick and simple utility functions that we need to implement.  These are mainly for convenience and code brevity.","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"\"\"\"\n    _det(s1::Point2{T1}, s2::Point2{T2}) where {T1 <: Real, T2 <: Real}\n\nReturns the determinant of the matrix formed by `hcat`'ing two points `s1` and `s2`.\n\nSpecifically, this is:\n```julia\ns1[1] * s2[2] - s1[2] * s2[1]\n```\n\n# Extended help\n\n# Doctests\n\n```jldoctest\njulia> _det((1,0), (0,1))\n1\n\njulia> _det(Point2f(1, 2), Point2f(3, 4))\n-2.0f0\n```\n\"\"\"\nfunction _det(s1::_VecTypes{2, T1}, s2::_VecTypes{2, T2}) where {T1 <: Real, T2 <: Real}\n    return s1[1] * s2[2] - s1[2] * s2[1]\nend\n\n\"\"\"\n    t_value(sᵢ, sᵢ₊₁, rᵢ, rᵢ₊₁)\n\nReturns the \"T-value\" as described in Hormann's presentation [^HormannPresentation] on how to calculate\nthe mean-value coordinate.\n\nHere, `sᵢ` is the vector from vertex `vᵢ` to the point, and `rᵢ` is the norm (length) of `sᵢ`.\n`s` must be `Point` and `r` must be real numbers.\n\n```math\ntᵢ = \\\\frac{\\\\mathrm{det}\\\\left(sᵢ, sᵢ₊₁\\\\right)}{rᵢ * rᵢ₊₁ + sᵢ ⋅ sᵢ₊₁}\n```\n\n[^HormannPresentation]: K. Hormann and N. Sukumar. Generalized Barycentric Coordinates in Computer Graphics and Computational Mechanics. Taylor & Fancis, CRC Press, 2017.\n\n# Extended help\n\n# Doctests\n\nFirst, we can test whether the T-value is 0 when the two points are the same:\n\n```jldoctest\njulia> t_value(Point2f(0,0), Point2f(1,0), 1, 1)\n0\n\njulia> t_value(Point2f(0, 1), Point2f(1, 0), 1, 2)\n-0.5f0\n```\n\n\"\"\"\nfunction t_value(sᵢ::_VecTypes{N, T1}, sᵢ₊₁::_VecTypes{N, T1}, rᵢ::T2, rᵢ₊₁::T2) where {N, T1 <: Real, T2 <: Real}\n    return _det(sᵢ, sᵢ₊₁) / muladd(rᵢ, rᵢ₊₁, dot(sᵢ, sᵢ₊₁))\nend\n\n\nfunction barycentric_coordinates!(λs::Vector{<: Real}, ::MeanValue, polypoints::AbstractVector{<: Point{2, T1}}, point::Point{2, T2}) where {T1 <: Real, T2 <: Real}\n    @boundscheck @assert length(λs) == length(polypoints)\n    @boundscheck @assert length(polypoints) >= 3\n    n_points = length(polypoints)\n    # Initialize counters and register variables\n    # Points - these are actually vectors from point to vertices\n    #  polypoints[i-1], polypoints[i], polypoints[i+1]\n    sᵢ₋₁ = polypoints[end] - point\n    sᵢ   = polypoints[begin] - point\n    sᵢ₊₁ = polypoints[begin+1] - point\n    # radius / Euclidean distance between points.\n    rᵢ₋₁ = norm(sᵢ₋₁)\n    rᵢ   = norm(sᵢ  )\n    rᵢ₊₁ = norm(sᵢ₊₁)\n    # Perform the first computation explicitly, so we can cut down on\n    # a mod in the loop.\n    λs[1] = (t_value(sᵢ₋₁, sᵢ, rᵢ₋₁, rᵢ) + t_value(sᵢ, sᵢ₊₁, rᵢ, rᵢ₊₁)) / rᵢ\n    # Loop through the rest of the vertices, compute, store in λs\n    for i in 2:n_points\n        # Increment counters + set variables\n        sᵢ₋₁ = sᵢ\n        sᵢ   = sᵢ₊₁\n        sᵢ₊₁ = polypoints[mod1(i+1, n_points)] - point\n        rᵢ₋₁ = rᵢ\n        rᵢ   = rᵢ₊₁\n        rᵢ₊₁ = norm(sᵢ₊₁) # radius / Euclidean distance between points.\n        λs[i] = (t_value(sᵢ₋₁, sᵢ, rᵢ₋₁, rᵢ) + t_value(sᵢ, sᵢ₊₁, rᵢ, rᵢ₊₁)) / rᵢ\n    end\n    # Normalize λs to the 1-norm (sum=1)\n    λs ./= sum(λs)\n    return λs\nend","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"function barycentric_coordinates(::MeanValue, polypoints::NTuple{N, Point{2, T2}}, point::Point{2, T1},) where {N, T1, T2}\n    ## Initialize counters and register variables\n    ## Points - these are actually vectors from point to vertices\n    ##  polypoints[i-1], polypoints[i], polypoints[i+1]\n    sᵢ₋₁ = polypoints[end] - point\n    sᵢ   = polypoints[begin] - point\n    sᵢ₊₁ = polypoints[begin+1] - point\n    ## radius / Euclidean distance between points.\n    rᵢ₋₁ = norm(sᵢ₋₁)\n    rᵢ   = norm(sᵢ  )\n    rᵢ₊₁ = norm(sᵢ₊₁)\n    λ₁ = (t_value(sᵢ₋₁, sᵢ, rᵢ₋₁, rᵢ) + t_value(sᵢ, sᵢ₊₁, rᵢ, rᵢ₊₁)) / rᵢ\n    λs = ntuple(N) do i\n        if i == 1\n            return λ₁\n        end\n        ## Increment counters + set variables\n        sᵢ₋₁ = sᵢ\n        sᵢ   = sᵢ₊₁\n        sᵢ₊₁ = polypoints[mod1(i+1, N)] - point\n        rᵢ₋₁ = rᵢ\n        rᵢ   = rᵢ₊₁\n        rᵢ₊₁ = norm(sᵢ₊₁) # radius / Euclidean distance between points.\n        return (t_value(sᵢ₋₁, sᵢ, rᵢ₋₁, rᵢ) + t_value(sᵢ, sᵢ₊₁, rᵢ, rᵢ₊₁)) / rᵢ\n    end\n\n    ∑λ = sum(λs)\n\n    return ntuple(N) do i\n        λs[i] / ∑λ\n    end\nend","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"This performs an inplace accumulation, using less memory and is faster. That's particularly good if you are using a polygon with a large number of points...","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"function barycentric_interpolate(::MeanValue, polypoints::AbstractVector{<: Point{2, T1}}, values::AbstractVector{V}, point::Point{2, T2}) where {T1 <: Real, T2 <: Real, V}\n    @boundscheck @assert length(values) == length(polypoints)\n    @boundscheck @assert length(polypoints) >= 3\n\n    n_points = length(polypoints)\n    # Initialize counters and register variables\n    # Points - these are actually vectors from point to vertices\n    #  polypoints[i-1], polypoints[i], polypoints[i+1]\n    sᵢ₋₁ = polypoints[end] - point\n    sᵢ   = polypoints[begin] - point\n    sᵢ₊₁ = polypoints[begin+1] - point\n    # radius / Euclidean distance between points.\n    rᵢ₋₁ = norm(sᵢ₋₁)\n    rᵢ   = norm(sᵢ  )\n    rᵢ₊₁ = norm(sᵢ₊₁)\n    # Now, we set the interpolated value to the first point's value, multiplied\n    # by the weight computed relative to the first point in the polygon.\n    wᵢ = (t_value(sᵢ₋₁, sᵢ, rᵢ₋₁, rᵢ) + t_value(sᵢ, sᵢ₊₁, rᵢ, rᵢ₊₁)) / rᵢ\n    wₜₒₜ = wᵢ\n    interpolated_value = values[begin] * wᵢ\n    for i in 2:n_points\n        # Increment counters + set variables\n        sᵢ₋₁ = sᵢ\n        sᵢ   = sᵢ₊₁\n        sᵢ₊₁ = polypoints[mod1(i+1, n_points)] - point\n        rᵢ₋₁ = rᵢ\n        rᵢ   = rᵢ₊₁\n        rᵢ₊₁ = norm(sᵢ₊₁)\n        # Now, we calculate the weight:\n        wᵢ = (t_value(sᵢ₋₁, sᵢ, rᵢ₋₁, rᵢ) + t_value(sᵢ, sᵢ₊₁, rᵢ, rᵢ₊₁)) / rᵢ\n        # perform a weighted sum with the interpolated value:\n        interpolated_value += values[i] * wᵢ\n        # and add the weight to the total weight accumulator.\n        wₜₒₜ += wᵢ\n    end\n    # Return the normalized interpolated value.\n    return interpolated_value / wₜₒₜ\nend","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"When you have holes, then you have to be careful about the order you iterate around points.","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"Specifically, you have to iterate around each linear ring separately and ensure there are no degenerate/repeated points at the start and end!","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"function barycentric_interpolate(::MeanValue, exterior::AbstractVector{<: Point{N, T1}}, interiors::AbstractVector{<: AbstractVector{<: Point{N, T1}}}, values::AbstractVector{V}, point::Point{N, T2}) where {N, T1 <: Real, T2 <: Real, V}\n    # @boundscheck @assert length(values) == (length(exterior) + isempty(interiors) ? 0 : sum(length.(interiors)))\n    # @boundscheck @assert length(exterior) >= 3\n\n    current_index = 1\n    l_exterior = length(exterior)\n\n    sᵢ₋₁ = exterior[end] - point\n    sᵢ   = exterior[begin] - point\n    sᵢ₊₁ = exterior[begin+1] - point\n    rᵢ₋₁ = norm(sᵢ₋₁) # radius / Euclidean distance between points.\n    rᵢ   = norm(sᵢ  ) # radius / Euclidean distance between points.\n    rᵢ₊₁ = norm(sᵢ₊₁) # radius / Euclidean distance between points.","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"Now, we set the interpolated value to the first point's value, multiplied by the weight computed relative to the first point in the polygon.","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"    wᵢ = (t_value(sᵢ₋₁, sᵢ, rᵢ₋₁, rᵢ) + t_value(sᵢ, sᵢ₊₁, rᵢ, rᵢ₊₁)) / rᵢ\n    wₜₒₜ = wᵢ\n    interpolated_value = values[begin] * wᵢ\n\n    for i in 2:l_exterior","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"Increment counters + set variables","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"        sᵢ₋₁ = sᵢ\n        sᵢ   = sᵢ₊₁\n        sᵢ₊₁ = exterior[mod1(i+1, l_exterior)] - point\n        rᵢ₋₁ = rᵢ\n        rᵢ   = rᵢ₊₁\n        rᵢ₊₁ = norm(sᵢ₊₁) # radius / Euclidean distance between points.\n        wᵢ = (t_value(sᵢ₋₁, sᵢ, rᵢ₋₁, rᵢ) + t_value(sᵢ, sᵢ₊₁, rᵢ, rᵢ₊₁)) / rᵢ","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"Updates - first the interpolated value,","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"        interpolated_value += values[current_index] * wᵢ","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"then the accumulators for total weight and current index.","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"        wₜₒₜ += wᵢ\n        current_index += 1\n\n    end\n    for hole in interiors\n        l_hole = length(hole)\n        sᵢ₋₁ = hole[end] - point\n        sᵢ   = hole[begin] - point\n        sᵢ₊₁ = hole[begin+1] - point\n        rᵢ₋₁ = norm(sᵢ₋₁) # radius / Euclidean distance between points.\n        rᵢ   = norm(sᵢ  ) # radius / Euclidean distance between points.\n        rᵢ₊₁ = norm(sᵢ₊₁) # radius / Euclidean distance between points.\n        # Now, we set the interpolated value to the first point's value, multiplied\n        # by the weight computed relative to the first point in the polygon.\n        wᵢ = (t_value(sᵢ₋₁, sᵢ, rᵢ₋₁, rᵢ) + t_value(sᵢ, sᵢ₊₁, rᵢ, rᵢ₊₁)) / rᵢ\n\n        interpolated_value += values[current_index] * wᵢ\n\n        wₜₒₜ += wᵢ\n        current_index += 1\n\n        for i in 2:l_hole\n            # Increment counters + set variables\n            sᵢ₋₁ = sᵢ\n            sᵢ   = sᵢ₊₁\n            sᵢ₊₁ = hole[mod1(i+1, l_hole)] - point\n            rᵢ₋₁ = rᵢ\n            rᵢ   = rᵢ₊₁\n            rᵢ₊₁ = norm(sᵢ₊₁) ## radius / Euclidean distance between points.\n            wᵢ = (t_value(sᵢ₋₁, sᵢ, rᵢ₋₁, rᵢ) + t_value(sᵢ, sᵢ₊₁, rᵢ, rᵢ₊₁)) / rᵢ\n            interpolated_value += values[current_index] * wᵢ\n            wₜₒₜ += wᵢ\n            current_index += 1\n        end\n    end\n    return interpolated_value / wₜₒₜ\n\nend\n\nstruct Wachspress <: AbstractBarycentricCoordinateMethod\nend","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"This page was generated using Literate.jl.","category":"page"},{"location":"source/methods/signed_distance/#Signed-distance","page":"Signed distance","title":"Signed distance","text":"","category":"section"},{"location":"source/methods/signed_distance/","page":"Signed distance","title":"Signed distance","text":"export signed_distance","category":"page"},{"location":"source/methods/signed_distance/","page":"Signed distance","title":"Signed distance","text":"TODO: clean this up.  It already supports GeoInterface.","category":"page"},{"location":"source/methods/signed_distance/","page":"Signed distance","title":"Signed distance","text":"Base.@propagate_inbounds euclid_distance(p1, p2) = sqrt((GeoInterface.x(p2)-GeoInterface.x(p1))^2 + (GeoInterface.y(p2)-GeoInterface.y(p1))^2)\neuclid_distance(x1, y1, x2, y2) = sqrt((x2-x1)^2 + (y2-y1)^2)\n\n\n\n\" Distance from p0 to the line segment formed by p1 and p2.  Implementation from Turf.jl.\"\nfunction _distance(p0, p1, p2)\n    x0, y0 = GeoInterface.x(p0), GeoInterface.y(p0)\n    x1, y1 = GeoInterface.x(p1), GeoInterface.y(p1)\n    x2, y2 = GeoInterface.x(p2), GeoInterface.y(p2)\n\n    if x1 < x2\n        xfirst, yfirst = x1, y1\n        xlast, ylast = x2, y2\n    else\n        xfirst, yfirst = x2, y2\n        xlast, ylast = x1, y1\n    end\n\n    v = (xlast - xfirst, ylast - yfirst)\n    w = (x0 - xfirst, y0 - yfirst)\n\n    c1 = sum(w .* v)\n    if c1 <= 0\n        return euclid_distance(x0, y0, xfirst, yfirst)\n    end\n\n    c2 = sum(v .* v)\n\n    if c2 <= c1\n        return euclid_distance(x0, y0, xlast, ylast)\n    end\n\n    b2 = c1 / c2\n\n    return euclid_distance(x0, y0, xfirst + (b2 * v[1]), yfirst + (b2 * v[2]))\nend\n\n\nfunction _distance(linestring, xy)\n    mindist = typemax(Float64)\n    N = GeoInterface.npoint(linestring)\n    @assert N ≥ 3\n    p1 = GeoInterface.getpoint(linestring, 1)\n    p2 = p1\n\n    for point_ind in 2:N\n        p2 = GeoInterface.getpoint(linestring, point_ind)\n        newdist = _distance(xy, p1, p2)\n        if newdist < mindist\n            mindist = newdist\n        end\n        p1 = p2\n    end\n\n    return mindist\nend\n\nfunction signed_distance(::GeoInterface.PolygonTrait, poly, x, y)\n\n    xy = (x, y)\n    mindist = _distance(GeoInterface.getexterior(poly), xy)\n\n    @inbounds for hole in GeoInterface.gethole(poly)\n        newdist = _distance(hole, xy)\n        if newdist < mindist\n            mindist = newdist\n        end\n    end\n\n    if GeoInterface.contains(poly, GeoInterface.convert(Base.parentmodule(typeof(poly)), (x, y)))\n        return mindist\n    else\n        return -mindist\n    end\nend\n\nfunction signed_distance(::GeoInterface.MultiPolygonTrait, multipoly, x, y)\n    distances = signed_distance.(GeoInterface.getpolygon(multipoly), x, y)\n    max_val, max_ind = findmax(distances)\n    return max_val\nend\n\n\n\"\"\"\n    signed_distance(geom, x::Real, y::Real)::Float64\n\nCalculates the signed distance from the geometry `geom` to the point\ndefined by `(x, y)`.  Points within `geom` have a negative distance,\nand points outside of `geom` have a positive distance.\n\nIf `geom` is a MultiPolygon, then this function returns the maximum distance\nto any of the polygons in `geom`.\n\"\"\"\nsigned_distance(geom, x, y) = signed_distance(GeoInterface.geomtrait(geom), geom, x, y)","category":"page"},{"location":"source/methods/signed_distance/","page":"Signed distance","title":"Signed distance","text":"","category":"page"},{"location":"source/methods/signed_distance/","page":"Signed distance","title":"Signed distance","text":"This page was generated using Literate.jl.","category":"page"},{"location":"source/methods/centroid/","page":"-","title":"-","text":"export centroid","category":"page"},{"location":"source/methods/centroid/","page":"-","title":"-","text":"These are all GeometryBasics.jl methods so far. They need to be converted to GeoInterface.","category":"page"},{"location":"source/methods/centroid/","page":"-","title":"-","text":"The reason that there is a centroid_and_signed_area function, is because in conputing the centroid, you end up computing the signed area.","category":"page"},{"location":"source/methods/centroid/","page":"-","title":"-","text":"In some computational geometry applications this may be a useful source of efficiency, so I added it here.","category":"page"},{"location":"source/methods/centroid/","page":"-","title":"-","text":"However, it's totally fine to ignore this and not have this code path. We simply need to decide on this.","category":"page"},{"location":"source/methods/centroid/","page":"-","title":"-","text":"function centroid(ls::LineString{2, T}) where T\n    centroid = Point{2, T}(0)\n    total_area = T(0)\n    if length(ls) == 1\n        return sum(ls[1])/2\n    end\n\n    p0 = ls[1][1]\n\n    for i in 1:(length(ls)-1)\n        p1 = ls[i][2]\n        p2 = ls[i+1][2]\n        area = signed_area(p0, p1, p2)\n        centroid = centroid .+ Point{2, T}((p0[1] + p1[1] + p2[1])/3, (p0[2] + p1[2] + p2[2])/3) * area\n        total_area += area\n    end\n    return centroid ./ total_area\nend","category":"page"},{"location":"source/methods/centroid/","page":"-","title":"-","text":"a more optimized function, so we only calculate signed area once!","category":"page"},{"location":"source/methods/centroid/","page":"-","title":"-","text":"function centroid_and_signed_area(ls::LineString{2, T}) where T\n    centroid = Point{2, T}(0)\n    total_area = T(0)\n    if length(ls) == 1\n        return sum(ls[1])/2\n    end\n\n    p0 = ls[1][1]\n\n    for i in 1:(length(ls)-1)\n        p1 = ls[i][2]\n        p2 = ls[i+1][2]\n        area = signed_area(p0, p1, p2)\n        centroid = centroid .+ Point{2, T}((p0[1] + p1[1] + p2[1])/3, (p0[2] + p1[2] + p2[2])/3) * area\n        total_area += area\n    end\n    return (centroid ./ total_area, total_area)\nend\n\nfunction centroid(poly::GeometryBasics.Polygon{2, T}) where T\n    exterior_centroid, exterior_area = centroid_and_signed_area(poly.exterior)\n\n    total_area = exterior_area\n    interior_numerator = Point{2, T}(0)\n    for interior in poly.interiors\n        interior_centroid, interior_area = centroid_and_signed_area(interior)\n        total_area += interior_area\n        interior_numerator += interior_centroid * interior_area\n    end\n\n    return (exterior_centroid * exterior_area - interior_numerator) / total_area\n\nend\n\nfunction centroid(multipoly::MultiPolygon)\n    centroids = centroid.(multipoly.polygons)\n    areas = signed_area.(multipoly.polygons)\n    areas ./= sum(areas)\n\n    return sum(centroids .* areas) / sum(areas)\nend\n\n\nfunction centroid(rect::Rect{N, T}) where {N, T}\n    return Point{N, T}(rect.origin .- rect.widths ./ 2)\nend\n\nfunction centroid(sphere::HyperSphere{N, T}) where {N, T}\n    return sphere.center\nend","category":"page"},{"location":"source/methods/centroid/","page":"-","title":"-","text":"","category":"page"},{"location":"source/methods/centroid/","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"source/methods/contains/","page":"-","title":"-","text":"More GeometryBasics code","category":"page"},{"location":"source/methods/contains/","page":"-","title":"-","text":"_cross(p1, p2, p3) = (GI.x(p1) - GI.x(p3)) * (GI.y(p2) - GI.y(p3)) - (GI.x(p2) - GI.x(p3)) * (GI.y(p1) - GI.y(p3))\n\ncontains(pointlist, point) = contains(GI.trait(pointlist), GI.trait(point), pointlist, point)","category":"page"},{"location":"source/methods/contains/","page":"-","title":"-","text":"Implementation of a point-in-polygon algorithm from Luxor.jl.  This is the Hormann-Agathos (2001) algorithm.","category":"page"},{"location":"source/methods/contains/","page":"-","title":"-","text":"For the source, see https://github.com/JuliaGraphics/Luxor.jl/blob/66d60fb51f6b1bb38690fe8dcc6c0084eeb80710/src/polygons.jl#L190-L229.","category":"page"},{"location":"source/methods/contains/","page":"-","title":"-","text":"function contains(::GI.LineStringTrait, ::GI.PointTrait, pointlist, point)\n    n = GI.npoint(pointlist)\n    c = false\n    q1 = GI.getpoint(pointlist, 1)\n    q2 = GI.getpoint(pointlist, 1)\n    @inbounds for (counter, current_point) in enumerate(Iterators.drop(GI.getpoint(pointlist), 1))\n        q1 = q2","category":"page"},{"location":"source/methods/contains/","page":"-","title":"-","text":"if reached last point, set \"next point\" to first point","category":"page"},{"location":"source/methods/contains/","page":"-","title":"-","text":"        if counter == (n-1)\n            q2 = GI.getpoint(pointlist, 1)\n        else\n            q2 = current_point\n        end\n        if GI.x(q1) == GI.x(point) && GI.x(q1) == GI.y(point)","category":"page"},{"location":"source/methods/contains/","page":"-","title":"-","text":"allowonedge || error(\"isinside(): VertexException a\")","category":"page"},{"location":"source/methods/contains/","page":"-","title":"-","text":"            continue\n        end\n        if GI.y(q2) == GI.y(point)\n            if GI.x(q2) == GI.x(point)","category":"page"},{"location":"source/methods/contains/","page":"-","title":"-","text":"allowonedge || error(\"isinside(): VertexException b\")","category":"page"},{"location":"source/methods/contains/","page":"-","title":"-","text":"                continue\n            elseif (GI.y(q1) == GI.y(point)) && ((GI.x(q2) > GI.x(point)) == (GI.x(q1) < GI.x(point)))","category":"page"},{"location":"source/methods/contains/","page":"-","title":"-","text":"allowonedge || error(\"isinside(): EdgeException\")","category":"page"},{"location":"source/methods/contains/","page":"-","title":"-","text":"                continue\n            end\n        end\n        if (GI.y(q1) < GI.y(point)) != (GI.y(q2) < GI.y(point)) # crossing\n            if GI.x(q1) >= GI.x(point)\n                if GI.x(q2) > GI.x(point)\n                    c = !c\n                elseif ((_cross(q1, q2, point) > 0) == (GI.y(q2) > GI.y(q1)))\n                    c = !c\n                end\n            elseif GI.x(q2) > GI.x(point)\n                if ((_cross(q1, q2, point) > 0) == (GI.y(q2) > GI.y(q1)))\n                    c = !c\n                end\n            end\n        end\n    end\n    return c\n\nend\n\nfunction contains(poly::Polygon{2, T1}, point::Point{2, T2}) where {T1, T2}\n    c = contains(poly.exterior, point)\n    for interior in poly.interiors\n        if contains(interior, point)\n            return false\n        end\n    end\n    return c\nend","category":"page"},{"location":"source/methods/contains/","page":"-","title":"-","text":"TODOs: implement contains for mesh, simplex, and 3d objects (eg rect, triangle, etc.)","category":"page"},{"location":"source/methods/contains/","page":"-","title":"-","text":"contains(mp::MultiPolygon{2, T1}, point::Point{2, T2}) where {T1, T2} = any((contains(poly, point) for poly in mp.polygons))","category":"page"},{"location":"source/methods/contains/","page":"-","title":"-","text":"","category":"page"},{"location":"source/methods/contains/","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"source/transformations/flip/","page":"-","title":"-","text":"\"\"\"\n    flip(obj)\n\nSwap all of the x and y coordinates in obj, otherwise\nkeeping the original structure (but not necessarily the\noriginal type).\n\"\"\"\nfunction flip(geom)\n    if GI.is3d(geom)\n        return apply(PointTrait, geom) do point\n            (GI.y(p), GI.x(p), GI.z(p))\n        end\n    else\n        return apply(PointTrait, geom) do point\n            (GI.y(p), GI.x(p))\n        end\n    end\nend","category":"page"},{"location":"source/transformations/flip/","page":"-","title":"-","text":"","category":"page"},{"location":"source/transformations/flip/","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"source/methods/signed_area/#Signed-area","page":"Signed area","title":"Signed area","text":"","category":"section"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"export signed_area","category":"page"},{"location":"source/methods/signed_area/#What-is-signed-area?","page":"Signed area","title":"What is signed area?","text":"","category":"section"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"Signed area is simply the integral over the exterior path of a polygon, minus the sum of integrals over its interior holes.","category":"page"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"It is signed such that a clockwise path has a positive area, and a counterclockwise path has a negative area.","category":"page"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"To provide an example, consider this rectangle:","category":"page"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"using GeometryOps\nusing GeometryOps.GeometryBasics\nusing Makie\n\nrect = Polygon([Point(0,0), Point(0,1), Point(1,1), Point(1,0), Point(0, 0)])\nf, a, p = poly(rect; axis = (; aspect = DataAspect()))","category":"page"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"This is clearly a rectangle, etc.  But now let's look at how the points look:","category":"page"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"lines!(a, rect; color = 1:length(coordinates(rect))+1)\nf","category":"page"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"The points are ordered in a clockwise fashion, which means that the signed area is positive.  If we reverse the order of the points, we get a negative area.","category":"page"},{"location":"source/methods/signed_area/#Implementation","page":"Signed area","title":"Implementation","text":"","category":"section"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"This is the GeoInterface-compatible implementation.","category":"page"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"First, we implement a wrapper method that dispatches to the correct implementation based on the geometry trait.","category":"page"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"This is also used in the implementation, since it's a lot less work!","category":"page"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"\"\"\"\n    signed_area(geom)::Real\n\nReturns the signed area of the geometry, based on winding order.\n\"\"\"\nsigned_area(x) = signed_area(GI.trait(x), x)","category":"page"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"TODOS here:","category":"page"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"This could conceivably be multithreaded.  How to indicate that it should be so?\nWhat to do for corner cases (nan point, etc)?","category":"page"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"function signed_area(::Union{LineStringTrait, LinearRingTrait}, geom)","category":"page"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"Basically, we integrate the area under the line string, which gives us the signed area.","category":"page"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"    point₁ = GI.getpoint(geom, 1)\n    point₂ = GI.getpoint(geom, 2)\n    area = GI.x(point₁) * GI.y(point₂) - GI.y(point₁) * GI.x(point₂)\n    for point in GI.getpoint(geom)","category":"page"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"Advance the point buffers by 1 point","category":"page"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"        point₁ = point₂\n        point₂ = point","category":"page"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"Accumulate the area into area","category":"page"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"        area += GI.x(point₁) * GI.y(point₂) - GI.y(point₁) * GI.x(point₂)\n    end\n    area /= 2\n    return area\nend","category":"page"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"This subtracts the","category":"page"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"function signed_area(::PolygonTrait, geom)\n    s_area = signed_area(GI.getexterior(geom))\n    area = abs(s_area)\n    for hole in GI.gethole(geom)\n        area -= abs(signed_area(hole))\n    end\n    return area * sign(s_area)\nend\n\nsigned_area(::MultiPolygonTrait, geom) = sum((signed_area(poly) for poly in GI.getpolygon(geom)))","category":"page"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"This should theoretically work for anything, but I haven't actually tested yet!","category":"page"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"Below is the original GeometryBasics implementation:","category":"page"},{"location":"source/methods/signed_area/#julia","page":"Signed area","title":"```julia","text":"","category":"section"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"function signed_area(a::Point{2, T}, b::Point{2, T}, c::Point{2, T}) where T     return ((b[1] - a[1]) * (c[2] - a[2]) - (c[1] - a[1]) * (b[2] - a[2])) / 2 end","category":"page"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"function signed_area(points::AbstractVector{<: Point{2, T}}) where {T}     area = sum((points[i][1] * points[i+1][2] - points[i][2] * points[i+1][1] for i in 1:(length(points)-1))) / 2.0 end","category":"page"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"function signedarea(ls::GeometryBasics.LineString)     # coords = GeometryBasics.decompose(Point2f, ls)     return sum((p1[1] * p2[2] - p1[2] * p2[1] for (p1, p2) in ls)) / 2.0#signedarea(coords) end","category":"page"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"function signedarea(poly::GeometryBasics.Polygon{2})     sarea = signedarea(poly.exterior)     area = abs(sarea)     for hole in poly.interiors         area -= abs(signedarea(hole))     end     return area * sign(sarea) end","category":"page"},{"location":"source/methods/signed_area/#WARNING:-this-may-not-do-what-you-expect,-since-it's","page":"Signed area","title":"WARNING: this may not do what you expect, since it's","text":"","category":"section"},{"location":"source/methods/signed_area/#sensitive-to-winding-order.-Use-GeoInterface.area-instead.","page":"Signed area","title":"sensitive to winding order.  Use GeoInterface.area instead.","text":"","category":"section"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"signedarea(mp::MultiPolygon) = sum(signedarea.(mp.polygons)) ```","category":"page"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"","category":"page"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"This page was generated using Literate.jl.","category":"page"},{"location":"source/GeometryOps.jl.2687/","page":"-","title":"-","text":"        8 module GeometryOps\n        -\n        - using GeoInterface\n        - using GeometryBasics\n        - import Proj\n        - using LinearAlgebra\n        -\n        - const GI = GeoInterface\n        - const GB = GeometryBasics\n        -\n        - include(\"primitives.jl\")\n        - include(\"methods/signed_distance.jl\")\n        - include(\"methods/signed_area.jl\")\n        - include(\"methods/centroid.jl\")\n        - include(\"methods/contains.jl\")\n        - include(\"methods/barycentric.jl\")\n        - include(\"transformations/reproject.jl\")\n        - include(\"transformations/flip.jl\")\n        -\n        - end","category":"page"},{"location":"source/GeometryOps.jl.2687/","page":"-","title":"-","text":"","category":"page"},{"location":"source/GeometryOps.jl.2687/","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = GeometryOps","category":"page"},{"location":"#GeometryOps","page":"Home","title":"GeometryOps","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for GeometryOps.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [GeometryOps]","category":"page"},{"location":"#GeometryOps.AbstractBarycentricCoordinateMethod","page":"Home","title":"GeometryOps.AbstractBarycentricCoordinateMethod","text":"abstract type AbstractBarycentricCoordinateMethod\n\nAbstract supertype for barycentric coordinate methods.   The subtypes may serve as dispatch types, or may cache  some information about the target polygon.  \n\nAPI\n\nThe following methods must be implemented for all subtypes:\n\nbarycentric_coordinates!(λs::Vector{<: Real}, method::AbstractBarycentricCoordinateMethod, exterior::Vector{<: Point{2, T1}}, point::Point{2, T2})\nbarycentric_interpolate(method::AbstractBarycentricCoordinateMethod, exterior::Vector{<: Point{2, T1}}, values::Vector{V}, point::Point{2, T2})::V\nbarycentric_interpolate(method::AbstractBarycentricCoordinateMethod, exterior::Vector{<: Point{2, T1}}, interiors::Vector{<: Vector{<: Point{2, T1}}} values::Vector{V}, point::Point{2, T2})::V\n\nThe rest of the methods will be implemented in terms of these, and have efficient dispatches for broadcasting.\n\n\n\n\n\n","category":"type"},{"location":"#GeometryOps.MeanValue","page":"Home","title":"GeometryOps.MeanValue","text":"MeanValue() <: AbstractBarycentricCoordinateMethod\n\nThis method calculates barycentric coordinates using the mean value method.\n\nReferences\n\n\n\n\n\n","category":"type"},{"location":"#GeometryOps._det-Union{Tuple{T2}, Tuple{T1}, Tuple{Union{Tuple{T1, T1}, StaticArraysCore.StaticArray{Tuple{2}, T1, 1}}, Union{Tuple{T2, T2}, StaticArraysCore.StaticArray{Tuple{2}, T2, 1}}}} where {T1<:Real, T2<:Real}","page":"Home","title":"GeometryOps._det","text":"_det(s1::Point2{T1}, s2::Point2{T2}) where {T1 <: Real, T2 <: Real}\n\nReturns the determinant of the matrix formed by hcat'ing two points s1 and s2.\n\nSpecifically, this is: \n\ns1[1] * s2[2] - s1[2] * s2[1]\n\nExtended help\n\nDoctests\n\njulia> _det((1,0), (0,1))\n1\n\njulia> _det(Point2f(1, 2), Point2f(3, 4))\n-2.0f0\n\n\n\n\n\n","category":"method"},{"location":"#GeometryOps._distance-Tuple{Any, Any, Any}","page":"Home","title":"GeometryOps._distance","text":"Distance from p0 to the line segment formed by p1 and p2.  Implementation from Turf.jl.\n\n\n\n\n\n","category":"method"},{"location":"#GeometryOps.apply-Union{Tuple{Target}, Tuple{Any, Type{Target}, Any}} where Target<:GeoInterface.AbstractTrait","page":"Home","title":"GeometryOps.apply","text":"apply(f, target::Type{<:AbstractTrait}, obj; crs)\n\nReconstruct a geometry or feature using the function f on the target trait.\n\nf(target_geom) => x where x also has the target trait, or an equivalent.\n\nThe result is an functionally similar geometry with values depending on f\n\nFlipped point the order in any feature or geometry, or iterables of either:\n\n```juia import GeoInterface as GI import GeometryOps as GO geom = GI.Polygon([GI.LinearRing([(1, 2), (3, 4), (5, 6), (1, 2)]),                     GI.LinearRing([(3, 4), (5, 6), (6, 7), (3, 4)])])\n\nflipped_geom = GO.apply(GI.PointTrait, geom) do p     (GI.y(p), GI.x(p)) end\n\n\n\n\n\n","category":"method"},{"location":"#GeometryOps.flatten-Union{Tuple{Target}, Tuple{Type{Target}, Any}} where Target<:GeoInterface.AbstractTrait","page":"Home","title":"GeometryOps.flatten","text":"flatten(target::Type{<:GI.AbstractTrait}, geom)\n\nLazily flatten any geometry, feature or iterator of geometries or features so that objects with the specified trait are returned by the iterator.\n\n\n\n\n\n","category":"method"},{"location":"#GeometryOps.flip-Tuple{Any}","page":"Home","title":"GeometryOps.flip","text":"flip(obj)\n\nSwap all of the x and y coordinates in obj, otherwise keeping the original structure (but not necessarily the original type).\n\n\n\n\n\n","category":"method"},{"location":"#GeometryOps.rebuild-Tuple{Any, Any}","page":"Home","title":"GeometryOps.rebuild","text":"rebuild(geom, child_geoms)\n\nRebuild a geometry from child geometries.\n\nBy default geometries will be rebuilt as a GeoInterface.Wrappers  geometry, but rebuild can have methods added to it to dispatch on geometries from other packages and specify how to rebuild them.\n\n(Maybe it should go into GeoInterface.jl)\n\n\n\n\n\n","category":"method"},{"location":"#GeometryOps.reconstruct-Tuple{Any, Any}","page":"Home","title":"GeometryOps.reconstruct","text":"reconstruct(geom, components)\n\nReconstruct geom from an iterable of component objects that match its structure.\n\nAll objects in components must have the same GeoInterface.trait.\n\nUsusally used in combination with flatten.\n\n\n\n\n\n","category":"method"},{"location":"#GeometryOps.reproject-Tuple{Any}","page":"Home","title":"GeometryOps.reproject","text":"reproject(geometry; source_crs, target_crs, transform, always_xy, time)\nreproject(geometry, source_crs, target_crs; always_xy, time)\nreproject(geometry, transform; always_xy, time)\n\nReproject any GeoInterface.jl compatible geometry from source_crs to target_crs.\n\nThe returned object will be constructed from GeoInterface.WrapperGeometry geometries, wrapping views of a Vector{Proj.Point{D}}, where D is the dimension.\n\nArguments\n\ngeometry: Any GeoInterface.jl compatible geometries.\nsource_crs: the source coordinate referece system, as a GeoFormatTypes.jl object or a string.\ntarget_crs: the target coordinate referece system, as a GeoFormatTypes.jl object or a string.\n\nIf these a passed as keywords, transform will take priority. Without it target_crs is always needed, and source_crs is needed if it is not retreivable from the geometry with GeoInterface.crs(geometry).\n\nKeywords\n\n-always_xy: force x, y coordinate order, true by default.     false will expect and return points in the crs coordinate order. -time: the time for the coordinates. Inf by default.\n\n\n\n\n\n","category":"method"},{"location":"#GeometryOps.signed_area-Tuple{Any}","page":"Home","title":"GeometryOps.signed_area","text":"signed_area(geom)::Real\n\nReturns the signed area of the geometry, based on winding order.\n\n\n\n\n\n","category":"method"},{"location":"#GeometryOps.signed_distance-Tuple{Any, Any, Any}","page":"Home","title":"GeometryOps.signed_distance","text":"signed_distance(geom, x::Real, y::Real)::Float64\n\nCalculates the signed distance from the geometry geom to the point defined by (x, y).  Points within geom have a negative distance, and points outside of geom have a positive distance.\n\nIf geom is a MultiPolygon, then this function returns the maximum distance  to any of the polygons in geom.\n\n\n\n\n\n","category":"method"},{"location":"#GeometryOps.t_value-Union{Tuple{T2}, Tuple{T1}, Tuple{N}, Tuple{Union{Tuple{Vararg{T1, N}}, StaticArraysCore.StaticArray{Tuple{N}, T1, 1}}, Union{Tuple{Vararg{T1, N}}, StaticArraysCore.StaticArray{Tuple{N}, T1, 1}}, T2, T2}} where {N, T1<:Real, T2<:Real}","page":"Home","title":"GeometryOps.t_value","text":"t_value(sᵢ, sᵢ₊₁, rᵢ, rᵢ₊₁)\n\nReturns the \"T-value\" as described in Hormann's presentation [HormannPresentation] on how to calculate the mean-value coordinate.  \n\nHere, sᵢ is the vector from vertex vᵢ to the point, and rᵢ is the norm (length) of sᵢ. s must be Point and r must be real numbers.\n\ntᵢ = fracmathrmdetleft(sᵢ sᵢ₁right)rᵢ * rᵢ₁ + sᵢ  sᵢ₁\n\n[HormannPresentation]: K. Hormann and N. Sukumar. Generalized Barycentric Coordinates in Computer Graphics and Computational Mechanics. Taylor & Fancis, CRC Press, 2017.\n\nExtended help\n\nDoctests\n\nFirst, we can test whether the T-value is 0 when the two points are the same:\n\njulia> t_value(Point2f(0,0), Point2f(1,0), 1, 1)\n0\n\njulia> t_value(Point2f(0, 1), Point2f(1, 0), 1, 2)\n-0.5f0\n\n\n\n\n\n","category":"method"},{"location":"#GeometryOps.unwrap","page":"Home","title":"GeometryOps.unwrap","text":"unwrap(target::Type{<:AbstractTrait}, obj)\nunwrap(f, target::Type{<:AbstractTrait}, obj)\n\nUnwrap the geometry to vectors, down to the target trait.\n\nIf f is passed in it will be applied to the target geometries as they are found.\n\n\n\n\n\n","category":"function"},{"location":"#GeometryOps.weighted_mean-Union{Tuple{WT}, Tuple{WT, Any, Any}} where WT<:Real","page":"Home","title":"GeometryOps.weighted_mean","text":"weighted_mean(weight::Real, x1, x2)\n\nReturns the weighted mean of x1 and x2, where weight is the weight of x1.\n\nSpecifically, calculates x1 * weight + x2 * (1 - weight).\n\nnote: Note\nThe idea for this method is that you can override this for custom types, like Color types, in extension modules.\n\n\n\n\n\n","category":"method"}]
}
