var documenterSearchIndex = {"docs":
[{"location":"source/GeometryOps/","page":"-","title":"-","text":"module GeometryOps\n\nusing GeoInterface\nusing GeometryBasics\nimport Proj\n\nusing GeoInterface.Extents: Extents\n\nconst GI = GeoInterface\nconst GB = GeometryBasics\n\ninclude(\"primitives.jl\")\ninclude(\"utils.jl\")\ninclude(\"methods/bools.jl\")\ninclude(\"methods/signed_distance.jl\")\ninclude(\"methods/signed_area.jl\")\ninclude(\"methods/centroid.jl\")\ninclude(\"methods/intersects.jl\")\ninclude(\"methods/contains.jl\")\ninclude(\"transformations/flip.jl\")\ninclude(\"transformations/simplify.jl\")\ninclude(\"transformations/flip.jl\")\ninclude(\"transformations/reproject.jl\")\n\nend","category":"page"},{"location":"source/GeometryOps/","page":"-","title":"-","text":"","category":"page"},{"location":"source/GeometryOps/","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"\"\"\"\n    apply(f, target::Type{<:AbstractTrait}, obj; crs)\n\nReconstruct a geometry or feature using the function `f` on the `target` trait.\n\n`f(target_geom) => x` where `x` also has the `target` trait, or an equivalent.\n\nThe result is an functionally similar geometry with values depending on `f`","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"Flipped point the order in any feature or geometry, or iterables of either:","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"```juia\nimport GeoInterface as GI\nimport GeometryOps as GO\ngeom = GI.Polygon([GI.LinearRing([(1, 2), (3, 4), (5, 6), (1, 2)]),\n                   GI.LinearRing([(3, 4), (5, 6), (6, 7), (3, 4)])])\n\nflipped_geom = GO.apply(GI.PointTrait, geom) do p\n    (GI.y(p), GI.x(p))\nend\n\"\"\"\napply(f, ::Type{Target}, geom; kw...) where Target = _apply(f, Target, geom; kw...)\n\n_apply(f, ::Type{Target}, geom; kw...)  where Target =\n    _apply(f, Target, GI.trait(geom), geom; kw...)","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"Try to _apply over iterables","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"_apply(f, ::Type{Target}, ::Nothing, iterable; kw...) where Target =\n    map(x -> _apply(f, Target, x; kw...), iterable)","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"Rewrap feature collections","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"function _apply(f, ::Type{Target}, ::GI.FeatureCollectionTrait, fc; crs=GI.crs(fc)) where Target\n    applicator(feature) = _apply(f, Target, feature; crs)::GI.Feature\n    features = map(applicator, GI.getfeature(fc))\n    return GI.FeatureCollection(features; crs)\nend","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"Rewrap features","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"function _apply(f, ::Type{Target}, ::GI.FeatureTrait, feature; crs=GI.crs(feature)) where Target\n    properties = GI.properties(feature)\n    geometry = _apply(f, Target, GI.geometry(feature); crs)\n    return GI.Feature(geometry; properties, crs)\nend","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"Reconstruct nested geometries","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"function _apply(f, ::Type{Target}, trait, geom; crs=GI.crs(geom))::(GI.geointerface_geomtype(trait)) where Target","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"TODO handle zero length...","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"    applicator(g) = _apply(f, Target, g; crs)\n    geoms = map(applicator, GI.getgeom(geom))\n    return rebuild(geom, geoms; crs)\nend","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"Apply f to the target geometry","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"_apply(f, ::Type{Target}, ::Trait, geom; crs=GI.crs(geom)) where {Target,Trait<:Target} = f(geom)","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"Fail if we hit PointTrait without running f","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"_apply(f, ::Type{Target}, trait::GI.PointTrait, geom; crs=nothing) where Target =\n    throw(ArgumentError(\"target $Target not found, but reached a `PointTrait` leaf\"))","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"Specific cases to avoid method ambiguity","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"_apply(f, ::Type{GI.PointTrait}, trait::GI.PointTrait, geom; crs=nothing) = f(geom)\n_apply(f, ::Type{GI.FeatureTrait}, ::GI.FeatureTrait, feature; crs=GI.crs(feature)) = f(feature)\n_apply(f, ::Type{GI.FeatureCollectionTrait}, ::GI.FeatureCollectionTrait, fc; crs=GI.crs(fc)) = f(fc)\n\n\"\"\"\n    unwrap(target::Type{<:AbstractTrait}, obj)\n    unwrap(f, target::Type{<:AbstractTrait}, obj)\n\nUnwrap the geometry to vectors, down to the target trait.\n\nIf `f` is passed in it will be applied to the target geometries\nas they are found.\n\"\"\"\nfunction unwrap end\nunwrap(target::Type, geom) = unwrap(identity, target, geom)","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"Add dispatch argument for trait","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"unwrap(f, target::Type, geom) = unwrap(f, target, GI.trait(geom), geom)","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"Try to unwrap over iterables","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"unwrap(f, target::Type, ::Nothing, iterable) =\n    map(x -> unwrap(f, target, x), iterable)","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"Rewrap feature collections","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"unwrap(f, target::Type, ::GI.FeatureCollectionTrait, fc) =\n    map(x -> unwrap(f, target, x), GI.getfeature(fc))\nunwrap(f, target::Type, ::GI.FeatureTrait, feature) = unwrap(f, target, GI.geometry(feature))\nunwrap(f, target::Type, trait, geom) = map(g -> unwrap(f, target, g), GI.getgeom(geom))","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"Apply f to the target geometry","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"unwrap(f, ::Type{Target}, ::Trait, geom) where {Target,Trait<:Target} = f(geom)","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"Fail if we hit PointTrait","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"unwrap(f, target::Type, trait::GI.PointTrait, geom) =\n    throw(ArgumentError(\"target $target not found, but reached a `PointTrait` leaf\"))","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"Specific cases to avoid method ambiguity","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"unwrap(f, target::Type{GI.PointTrait}, trait::GI.PointTrait, geom) = f(geom)\nunwrap(f, target::Type{GI.FeatureTrait}, ::GI.FeatureTrait, feature) = f(feature)\nunwrap(f, target::Type{GI.FeatureCollectionTrait}, ::GI.FeatureCollectionTrait, fc) = f(fc)\n\n\"\"\"\n    flatten(target::Type{<:GI.AbstractTrait}, geom)\n\nLazily flatten any geometry, feature or iterator of geometries or features\nso that objects with the specified trait are returned by the iterator.\n\"\"\"\nflatten(::Type{Target}, geom) where {Target<:GI.AbstractTrait} = flatten(identity, Target, geom)\nflatten(f, ::Type{Target}, geom) where {Target<:GI.AbstractTrait} = _flatten(f, Target, geom)\n\n_flatten(f, ::Type{Target}, geom) where Target = _flatten(f, Target, GI.trait(geom), geom)","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"Try to flatten over iterables","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"_flatten(f, ::Type{Target}, ::Nothing, iterable) where Target =\n    Iterators.flatten(Iterators.map(x -> _flatten(f, Target, x), iterable))","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"Flatten feature collections","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"function _flatten(f, ::Type{Target}, ::GI.FeatureCollectionTrait, fc) where Target\n    Iterators.map(GI.getfeature(fc)) do feature\n        _flatten(f, Target, feature)\n    end |> Iterators.flatten\nend\n_flatten(f, ::Type{Target}, ::GI.FeatureTrait, feature) where Target =\n    _flatten(f, Target, GI.geometry(feature))","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"Apply f to the target geometry","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"_flatten(f, ::Type{Target}, ::Trait, geom) where {Target,Trait<:Target} = (f(geom),)\n_flatten(f, ::Type{Target}, trait, geom) where Target =\n    Iterators.flatten(Iterators.map(g -> _flatten(f, Target, g), GI.getgeom(geom)))","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"Fail if we hit PointTrait without running f","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"_flatten(f, ::Type{Target}, trait::GI.PointTrait, geom) where Target =\n    throw(ArgumentError(\"target $Target not found, but reached a `PointTrait` leaf\"))","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"Specific cases to avoid method ambiguity","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"_flatten(f, ::Type{<:GI.PointTrait}, ::GI.PointTrait, geom) = (f(geom),)\n_flatten(f, ::Type{<:GI.FeatureTrait}, ::GI.FeatureTrait, feature) = (f(feature),)\n_flatten(f, ::Type{<:GI.FeatureCollectionTrait}, ::GI.FeatureCollectionTrait, fc) = (f(fc),)\n\n\n\"\"\"\n    reconstruct(geom, components)\n\nReconstruct `geom` from an iterable of component objects that match its structure.\n\nAll objects in `components` must have the same `GeoInterface.trait`.\n\nUsusally used in combination with `flatten`.\n\"\"\"\nreconstruct(geom, components) = first(_reconstruct(geom, components))\n\n_reconstruct(geom, components) =\n    _reconstruct(typeof(GI.trait(first(components))), geom, components, 1)\n_reconstruct(::Type{Target}, geom, components, iter) where Target =\n    _reconstruct(Target, GI.trait(geom), geom, components, iter)","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"Try to reconstruct over iterables","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"function _reconstruct(::Type{Target}, ::Nothing, iterable, components, iter) where Target\n    vect = map(iterable) do x\n        obj, iter = _reconstruct(Target, x, components, iter)\n        obj\n    end\n    return vect, iter\nend","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"Reconstruct feature collections","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"function _reconstruct(::Type{Target}, ::GI.FeatureCollectionTrait, fc, components, iter) where Target\n    features = map(GI.getfeature(fc)) do feature\n        newfeature, iter = _reconstruct(Target, feature, components, iter)\n        newfeature\n    end\n    return GI.FeatureCollection(features; crs=GI.crs(fc)), iter\nend\nfunction _reconstruct(::Type{Target}, ::GI.FeatureTrait, feature, components, iter) where Target\n    geom, iter = _reconstruct(Target, GI.geometry(feature), components, iter)\n    return GI.Feature(geom; properties=GI.properties(feature), crs=GI.crs(feature)), iter\nend\nfunction _reconstruct(::Type{Target}, trait, geom, components, iter) where Target\n    geoms = map(GI.getgeom(geom)) do subgeom\n        subgeom1, iter = _reconstruct(Target, GI.trait(subgeom), subgeom, components, iter)\n        subgeom1\n    end\n    return rebuild(geom, geoms), iter\nend","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"Apply f to the target geometry","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"_reconstruct(::Type{Target}, ::Trait, geom, components, iter) where {Target,Trait<:Target} =\n    iterate(components, iter)","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"Specific cases to avoid method ambiguity","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"_reconstruct(::Type{<:GI.PointTrait}, ::GI.PointTrait, geom, components, iter) = iterate(components, iter)\n_reconstruct(::Type{<:GI.FeatureTrait}, ::GI.FeatureTrait, feature, components, iter) = iterate(feature, iter)\n_reconstruct(::Type{<:GI.FeatureCollectionTrait}, ::GI.FeatureCollectionTrait, fc, components, iter) = iterate(fc, iter)","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"Fail if we hit PointTrait without running f","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"_reconstruct(::Type{Target}, trait::GI.PointTrait, geom, components, iter) where Target =\n    throw(ArgumentError(\"target $Target not found, but reached a `PointTrait` leaf\"))\n\n\nconst BasicsGeoms = Union{GB.AbstractGeometry,GB.AbstractFace,GB.AbstractPoint,GB.AbstractMesh,\n    GB.AbstractPolygon,GB.LineString,GB.MultiPoint,GB.MultiLineString,GB.MultiPolygon,GB.Mesh}\n\n\"\"\"\n    rebuild(geom, child_geoms)\n\nRebuild a geometry from child geometries.\n\nBy default geometries will be rebuilt as a GeoInterface.Wrappers\ngeometry, but `rebuild` can have methods added to it to dispatch\non geometries from other packages and specify how to rebuild them.\n\n(Maybe it should go into GeoInterface.jl)\n\"\"\"\nrebuild(geom, child_geoms; kw...) = rebuild(GI.trait(geom), geom, child_geoms; kw...)\nfunction rebuild(trait::GI.AbstractTrait, geom, child_geoms; crs=GI.crs(geom))\n    T = GI.geointerface_geomtype(trait)\n    if GI.is3d(geom)","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"The Boolean type parameters here indicate 3d-ness and measure coordinate presence respectively.","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"        return T{true,false}(child_geoms; crs)\n    else\n        return T{false,false}(child_geoms; crs)\n    end\nend","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"So that GeometryBasics geoms rebuild as themselves","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"function rebuild(trait::GI.AbstractTrait, geom::BasicsGeoms, child_geoms; crs=nothing)\n    GB.geointerface_geomtype(trait)(child_geoms)\nend\nfunction rebuild(trait::GI.AbstractTrait, geom::Union{GB.LineString,GB.MultiPoint}, child_geoms; crs=nothing)\n    GB.geointerface_geomtype(trait)(GI.convert.(GB.Point, child_geoms))\nend\nfunction rebuild(trait::GI.PolygonTrait, geom::GB.Polygon, child_geoms; crs=nothing)\n    Polygon(child_geoms[1], child_geoms[2:end])\nend","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"","category":"page"},{"location":"source/primitives/","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"source/transformations/reproject/","page":"-","title":"-","text":"\"\"\"\n    reproject(geometry; source_crs, target_crs, transform, always_xy, time)\n    reproject(geometry, source_crs, target_crs; always_xy, time)\n    reproject(geometry, transform; always_xy, time)\n\nReproject any GeoInterface.jl compatible `geometry` from `source_crs` to `target_crs`.\n\nThe returned object will be constructed from `GeoInterface.WrapperGeometry`\ngeometries, wrapping views of a `Vector{Proj.Point{D}}`, where `D` is the dimension.","category":"page"},{"location":"source/transformations/reproject/","page":"-","title":"-","text":"Arguments","category":"page"},{"location":"source/transformations/reproject/","page":"-","title":"-","text":"- `geometry`: Any GeoInterface.jl compatible geometries.\n- `source_crs`: the source coordinate referece system, as a GeoFormatTypes.jl object or a string.\n- `target_crs`: the target coordinate referece system, as a GeoFormatTypes.jl object or a string.\n\nIf these a passed as keywords, `transform` will take priority.\nWithout it `target_crs` is always needed, and `source_crs` is\nneeded if it is not retreivable from the geometry with `GeoInterface.crs(geometry)`.","category":"page"},{"location":"source/transformations/reproject/","page":"-","title":"-","text":"Keywords","category":"page"},{"location":"source/transformations/reproject/","page":"-","title":"-","text":"-`always_xy`: force x, y coordinate order, `true` by default.\n    `false` will expect and return points in the crs coordinate order.\n-`time`: the time for the coordinates. `Inf` by default.\n\"\"\"\nfunction reproject(geom;\n    source_crs=nothing, target_crs=nothing, transform=nothing, kw...\n)\n    if isnothing(transform)\n        source_crs = isnothing(source_crs) ? GeoInterface.crs(geom) : source_crs\n        isnothing(source_crs) && throw(ArgumentError(\"geom has no crs attatched. Pass a `source_crs` keyword\"))\n        reproject(geom, source_crs, target_crs; kw...)\n    else\n        reproject(geom, transform; kw...)\n    end\nend\nfunction reproject(geom, source_crs, target_crs;\n    time=Inf,\n    always_xy=true,\n    transform=Proj.Transformation(Proj.CRS(source_crs), Proj.CRS(target_crs); always_xy),\n)\n    reproject(geom, transform; time, target_crs)\nend\nfunction reproject(geom, transform::Proj.Transformation; time=Inf, target_crs=nothing)\n    if _is3d(geom)\n        return apply(PointTrait, geom; crs=target_crs) do p\n            transform(GI.x(p), GI.y(p), GI.z(p))\n        end\n    else\n        return apply(PointTrait, geom; crs=target_crs) do p\n            transform(GI.x(p), GI.y(p))\n        end\n    end\nend","category":"page"},{"location":"source/transformations/reproject/","page":"-","title":"-","text":"","category":"page"},{"location":"source/transformations/reproject/","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"source/methods/overlaps/","page":"-","title":"-","text":"\"\"\"\n    overlaps(geom1, geom2)::Bool\n\nCompare two Geometries of the same dimension and return true if their intersection set results in a geometry\ndifferent from both but of the same dimension. It applies to Polygon/Polygon, LineString/LineString,\nMultipoint/Multipoint, MultiLineString/MultiLineString and MultiPolygon/MultiPolygon.","category":"page"},{"location":"source/methods/overlaps/","page":"-","title":"-","text":"Examples","category":"page"},{"location":"source/methods/overlaps/","page":"-","title":"-","text":"```jldoctest\njulia> poly1 = Polygon([[[0,0],[0,5],[5,5],[5,0],[0,0]]])\nPolygon(Array{Array{Float64,1},1}[[[0.0, 0.0], [0.0, 5.0], [5.0, 5.0], [5.0, 0.0], [0.0, 0.0]]])\n\njulia> poly2 = Polygon([[[1,1],[1,6],[6,6],[6,1],[1,1]]])\nPolygon(Array{Array{Float64,1},1}[[[1.0, 1.0], [1.0, 6.0], [6.0, 6.0], [6.0, 1.0], [1.0, 1.0]]])\n\njulia> overlap(poly1, poly2)\ntrue\n```\n\"\"\"\noverlaps(g1, g2)::Bool = overlaps(trait(g1), g1, trait(g2), g2)::Bool\noverlaps(t1::FeatureTrait, g1, t2, g2)::Bool = overlaps(GI.geometry(g1), g2)\noverlaps(t1, g1, t2::FeatureTrait, g2)::Bool = overlaps(g1, geometry(g2))\nfunction overlaps(::MultiPointTrait, g1, ::MultiPointTrait, g2)::Bool\n    for p1 in GI.getpoint(g1)\n        for p2 in GI.getpoint(g2)\n            equals(p1, p2) && return true\n        end\n    end\nend\nfunction overlaps(::PolygonTrait, g1, ::PolygonTrait, g2)::Bool\n    line1 = polygon_to_line(geom1)\n    line2 = polygon_to_line(geom2)\n\n    intersection(line1, line2)\nend\noverlaps(::PolygonTrait, mp, ::MultiPointTrait, p)::Bool = overlaps(p, mp)\nfunction overlaps(t1::MultiPolygonTrait, mp, t2::Polygon, p1)::Bool\n    for p2 in GI.getgeom(mp)\n        overlaps(p1, p2)\n    end\nend\nfunction overlaps(::MultiPolygonTrait, g1, ::MultiPolygonTrait, g2)::Bool\n    for p1 in GI.getgeom(g1)\n        overlaps(PolygonTrait(), mp, PolygonTrait(), p1)\n    end\nend","category":"page"},{"location":"source/methods/overlaps/","page":"-","title":"-","text":"","category":"page"},{"location":"source/methods/overlaps/","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"source/methods/disjoint/","page":"-","title":"-","text":"\"\"\"\n    disjoint(geom1, geom2)::Bool\n\nReturn `true` if the intersection of the two geometries is an empty set.","category":"page"},{"location":"source/methods/disjoint/","page":"-","title":"-","text":"Examples","category":"page"},{"location":"source/methods/disjoint/","page":"-","title":"-","text":"```jldoctest\njulia> poly = Polygon([[[-1, 2], [3, 2], [3, 3], [-1, 3], [-1, 2]]])\nPolygon(Array{Array{Float64,1},1}[[[-1.0, 2.0], [3.0, 2.0], [3.0, 3.0], [-1.0, 3.0], [-1.0, 2.0]]])\n\njulia> point = Point([1, 1])\nPoint([1.0, 1.0])\n\njulia> disjoint(poly, point)\ntrue\n```\n\"\"\"\ndisjoint(t1::FeatureTrait, g1, t2, g2)::Bool = disjoint(GI.geometry(g1), g2)\ndisjoint(t1, g1, t2::FeatureTrait, g2)::Bool = disjoint(g1, geometry(g2))\ndisjoint(t1::PointTrait, g1, t2::PointTrait, g2)::Bool = !point_equals_point(g1, g2)\ndisjoint(t1::PointTrait, g1, t2::LineStringTrait, g2)::Bool = !point_on_line(g1, g2)\ndisjoint(t1::PointTrait, g1, t2::PolygonTrait, g2)::Bool = !point_in_polygon(g1, g2)\ndisjoint(t1::LineStringTrait, g1, t2::PointTrait, g2)::Bool = !point_on_line(g2, g1)\ndisjoint(t1::LineStringTrait, g1, t2::LineStringTrait, g2)::Bool = !line_on_line(g1, g2)\ndisjoint(t1::LineStringTrait, g1, t2::PolygonTrait, g2)::Bool = !line_in_polygon(g2, g1)\ndisjoint(t1::PolygonTrait, g1, t2::PointTrait, g2)::Bool = !point_in_polygon(g2, g1)\ndisjoint(t1::PolygonTrait, g1, t2::LineStringTrait, g2)::Bool = !line_in_polygon(g2, g1)\ndisjoint(t1::PolygonTrait, g1, t2::PolygonTrait, g2)::Bool = !poly_in_poly(g2, g1)","category":"page"},{"location":"source/methods/disjoint/","page":"-","title":"-","text":"","category":"page"},{"location":"source/methods/disjoint/","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"source/methods/crosses/","page":"-","title":"-","text":"\"\"\"\n     crosses(ft1::AbstractGeometry, ft2::AbstractGeometry)::Bool\n\nReturn `true` if the intersection results in a geometry whose dimension is one less than\nthe maximum dimension of the two source geometries and the intersection set is interior to\nboth source geometries.","category":"page"},{"location":"source/methods/crosses/","page":"-","title":"-","text":"Examples","category":"page"},{"location":"source/methods/crosses/","page":"-","title":"-","text":"```jldoctest\njulia> line = LineString([[1, 1], [1, 2], [1, 3], [1, 4]])\nLineString(Array{Float64,1}[[1.0, 1.0], [1.0, 2.0], [1.0, 3.0], [1.0, 4.0]])\n\njulia> line2 = LineString([[-2, 2], [4, 2]])\nLineString(Array{Float64,1}[[-2.0, 2.0], [4.0, 2.0]])\n\njulia> crosses(line2, line)\ntrue\n```\n\"\"\"\ncrosses(g1, g2)::Bool = crosses(trait(g1), g1, trait(g2), g2)::Bool\ncrosses(t1::FeatureTrait, g1, t2, g2)::Bool = crosses(GI.geometry(g1), g2)\ncrosses(t1, g1, t2::FeatureTrait, g2)::Bool = crosses(g1, geometry(g2))\ncrosses(::MultiPointTrait, g1::LineStringTrait, , g2)::Bool = multipoint_cross_line(g1, g2)\ncrosses(::MultiPointTrait, g1::PolygonTrait, , g2)::Bool = multipoint_cross_poly(g1, g2)\ncrosses(::LineStringTrait, g1, ::MultiPointTrait, g2)::Bool = multipoint_cross_lines(g2, g1)\ncrosses(::LineStringTrait, g1, ::PolygonTrait, g2)::Bool = line_cross_poly(g1, g2)\ncrosses(::LineStringTrait, g1, ::LineStringTrait, g2)::Bool = line_cross_line(g1, g2)\ncrosses(::PolygonTrait, g1, ::MultiPointTrait, g2)::Bool = multipoint_cross_poly(g2, g1)\ncrosses(::PolygonTrait, g1, ::LineStringTrait, g2)::Bool = line_cross_poly(g2, g1)\n\nfunction multipoint_cross_line(geom1, geom2)\n    int_point = false\n    ext_point = false\n    i = 1\n    np2 = GI.npoint(geom2)\n\n    while i < GI.npoint(geom1) && !intPoint && !extPoint\n        for j in 1:GI.npoint(geom2) - 1\n            inc_vertices = (j === 1 || j === np2 - 2) ? :none : :both\n\n            if is_point_on_segment(GI.getpoint(geom2, j), GI.getpoint(geom2.coordinates, j + 1), GI.getpoint(geom1, i), inc_vertices)\n                int_point = true\n            else\n                ext_point = true\n            end\n\n        end\n        i += 1\n    end\n\n    return int_point && ext_point\nend\n\nfunction line_cross_line(line1, line2)\n    inter = intersection(line1, line2)\n\n    np2 = GI.npoint(line2)\n    if !isnothing(inter)\n        for i in 1:GI.npoint(line1) - 1\n            for j in 1:GI.npoint(line2) - 1\n                inc_vertices = (j === 1 || j === np2 - 2) ? :none : :both\n                pa = GI.getpoint(line1, i)\n                pb = GI.getpoint(line1, i + 1)\n                p = GI.getpoint(line2, j)\n                is_point_on_segment(pa, pb, p, inc_vertices) && return true\n            end\n        end\n    end\n    return false\nend\n\nfunction line_cross_poly(line, poly) =\n\n    for line in flatten(AbstractCurveTrait, poly)\n        intersects(line)\n    end\nend\n\nfunction multipoint_cross_poly(mp, poly)\n    int_point = false\n    ext_point = false\n\n    for p in GI.getpoint(mp)\n        if point_in_polygon(p, poly)\n            int_point = true\n        else\n            ext_point = true\n        end\n        in_point && ext_point && return true\n    end\n    return false\nend","category":"page"},{"location":"source/methods/crosses/","page":"-","title":"-","text":"","category":"page"},{"location":"source/methods/crosses/","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"source/methods/signed_distance/#Signed-distance","page":"Signed distance","title":"Signed distance","text":"","category":"section"},{"location":"source/methods/signed_distance/","page":"Signed distance","title":"Signed distance","text":"export signed_distance","category":"page"},{"location":"source/methods/signed_distance/","page":"Signed distance","title":"Signed distance","text":"TODO: clean this up.  It already supports GeoInterface.","category":"page"},{"location":"source/methods/signed_distance/","page":"Signed distance","title":"Signed distance","text":"Base.@propagate_inbounds euclid_distance(p1, p2) = sqrt((GeoInterface.x(p2)-GeoInterface.x(p1))^2 + (GeoInterface.y(p2)-GeoInterface.y(p1))^2)\neuclid_distance(x1, y1, x2, y2) = sqrt((x2-x1)^2 + (y2-y1)^2)\n\n\n\n\" Distance from p0 to the line segment formed by p1 and p2.  Implementation from Turf.jl.\"\nfunction _distance(p0, p1, p2)\n    x0, y0 = GeoInterface.x(p0), GeoInterface.y(p0)\n    x1, y1 = GeoInterface.x(p1), GeoInterface.y(p1)\n    x2, y2 = GeoInterface.x(p2), GeoInterface.y(p2)\n\n    if x1 < x2\n        xfirst, yfirst = x1, y1\n        xlast, ylast = x2, y2\n    else\n        xfirst, yfirst = x2, y2\n        xlast, ylast = x1, y1\n    end\n\n    v = (xlast - xfirst, ylast - yfirst)\n    w = (x0 - xfirst, y0 - yfirst)\n\n    c1 = sum(w .* v)\n    if c1 <= 0\n        return euclid_distance(x0, y0, xfirst, yfirst)\n    end\n\n    c2 = sum(v .* v)\n\n    if c2 <= c1\n        return euclid_distance(x0, y0, xlast, ylast)\n    end\n\n    b2 = c1 / c2\n\n    return euclid_distance(x0, y0, xfirst + (b2 * v[1]), yfirst + (b2 * v[2]))\nend\n\n\nfunction _distance(linestring, xy)\n    mindist = typemax(Float64)\n    N = GeoInterface.npoint(linestring)\n    @assert N ≥ 3\n    p1 = GeoInterface.getpoint(linestring, 1)\n    p2 = p1\n\n    for point_ind in 2:N\n        p2 = GeoInterface.getpoint(linestring, point_ind)\n        newdist = _distance(xy, p1, p2)\n        if newdist < mindist\n            mindist = newdist\n        end\n        p1 = p2\n    end\n\n    return mindist\nend\n\nfunction signed_distance(::GeoInterface.PolygonTrait, poly, x, y)\n\n    xy = (x, y)\n    mindist = _distance(GeoInterface.getexterior(poly), xy)\n\n    @inbounds for hole in GeoInterface.gethole(poly)\n        newdist = _distance(hole, xy)\n        if newdist < mindist\n            mindist = newdist\n        end\n    end\n\n    if GeoInterface.contains(poly, GeoInterface.convert(Base.parentmodule(typeof(poly)), (x, y)))\n        return mindist\n    else\n        return -mindist\n    end\nend\n\nfunction signed_distance(::GeoInterface.MultiPolygonTrait, multipoly, x, y)\n    distances = signed_distance.(GeoInterface.getpolygon(multipoly), x, y)\n    max_val, max_ind = findmax(distances)\n    return max_val\nend\n\n\n\"\"\"\n    signed_distance(geom, x::Real, y::Real)::Float64\n\nCalculates the signed distance from the geometry `geom` to the point\ndefined by `(x, y)`.  Points within `geom` have a negative distance,\nand points outside of `geom` have a positive distance.\n\nIf `geom` is a MultiPolygon, then this function returns the maximum distance\nto any of the polygons in `geom`.\n\"\"\"\nsigned_distance(geom, x, y) = signed_distance(GeoInterface.geomtrait(geom), geom, x, y)","category":"page"},{"location":"source/methods/signed_distance/","page":"Signed distance","title":"Signed distance","text":"","category":"page"},{"location":"source/methods/signed_distance/","page":"Signed distance","title":"Signed distance","text":"This page was generated using Literate.jl.","category":"page"},{"location":"source/methods/centroid/","page":"-","title":"-","text":"export centroid","category":"page"},{"location":"source/methods/centroid/","page":"-","title":"-","text":"These are all GeometryBasics.jl methods so far. They need to be converted to GeoInterface.","category":"page"},{"location":"source/methods/centroid/","page":"-","title":"-","text":"The reason that there is a centroid_and_signed_area function, is because in conputing the centroid, you end up computing the signed area.","category":"page"},{"location":"source/methods/centroid/","page":"-","title":"-","text":"In some computational geometry applications this may be a useful source of efficiency, so I added it here.","category":"page"},{"location":"source/methods/centroid/","page":"-","title":"-","text":"However, it's totally fine to ignore this and not have this code path. We simply need to decide on this.","category":"page"},{"location":"source/methods/centroid/","page":"-","title":"-","text":"function centroid(ls::LineString{2, T}) where T\n    centroid = Point{2, T}(0)\n    total_area = T(0)\n    if length(ls) == 1\n        return sum(ls[1])/2\n    end\n\n    p0 = ls[1][1]\n\n    for i in 1:(length(ls)-1)\n        p1 = ls[i][2]\n        p2 = ls[i+1][2]\n        area = signed_area(p0, p1, p2)\n        centroid = centroid .+ Point{2, T}((p0[1] + p1[1] + p2[1])/3, (p0[2] + p1[2] + p2[2])/3) * area\n        total_area += area\n    end\n    return centroid ./ total_area\nend","category":"page"},{"location":"source/methods/centroid/","page":"-","title":"-","text":"a more optimized function, so we only calculate signed area once!","category":"page"},{"location":"source/methods/centroid/","page":"-","title":"-","text":"function centroid_and_signed_area(ls::LineString{2, T}) where T\n    centroid = Point{2, T}(0)\n    total_area = T(0)\n    if length(ls) == 1\n        return sum(ls[1])/2\n    end\n\n    p0 = ls[1][1]\n\n    for i in 1:(length(ls)-1)\n        p1 = ls[i][2]\n        p2 = ls[i+1][2]\n        area = signed_area(p0, p1, p2)\n        centroid = centroid .+ Point{2, T}((p0[1] + p1[1] + p2[1])/3, (p0[2] + p1[2] + p2[2])/3) * area\n        total_area += area\n    end\n    return (centroid ./ total_area, total_area)\nend\n\nfunction centroid(poly::GeometryBasics.Polygon{2, T}) where T\n    exterior_centroid, exterior_area = centroid_and_signed_area(poly.exterior)\n\n    total_area = exterior_area\n    interior_numerator = Point{2, T}(0)\n    for interior in poly.interiors\n        interior_centroid, interior_area = centroid_and_signed_area(interior)\n        total_area += interior_area\n        interior_numerator += interior_centroid * interior_area\n    end\n\n    return (exterior_centroid * exterior_area - interior_numerator) / total_area\n\nend\n\nfunction centroid(multipoly::MultiPolygon)\n    centroids = centroid.(multipoly.polygons)\n    areas = signed_area.(multipoly.polygons)\n    areas ./= sum(areas)\n\n    return sum(centroids .* areas) / sum(areas)\nend\n\n\nfunction centroid(rect::Rect{N, T}) where {N, T}\n    return Point{N, T}(rect.origin .- rect.widths ./ 2)\nend\n\nfunction centroid(sphere::HyperSphere{N, T}) where {N, T}\n    return sphere.center\nend","category":"page"},{"location":"source/methods/centroid/","page":"-","title":"-","text":"","category":"page"},{"location":"source/methods/centroid/","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"source/methods/contains/","page":"-","title":"-","text":"More GeometryBasics code","category":"page"},{"location":"source/methods/contains/","page":"-","title":"-","text":"_cross(p1, p2, p3) = (p1[1] - p3[1]) * (p2[2] - p3[2]) - (p2[1] - p3[1]) * (p1[2] - p3[2])","category":"page"},{"location":"source/methods/contains/","page":"-","title":"-","text":"Implementation of a point-in-polygon algorithm from Luxor.jl.  This is the Hormann-Agathos (2001) algorithm.","category":"page"},{"location":"source/methods/contains/","page":"-","title":"-","text":"For the source, see https://github.com/JuliaGraphics/Luxor.jl/blob/66d60fb51f6b1bb38690fe8dcc6c0084eeb80710/src/polygons.jl#L190-L229.","category":"page"},{"location":"source/methods/contains/","page":"-","title":"-","text":"function contains(ls::GeometryBasics.LineString{2, T1}, point::Point{2, T2}) where {T1, T2}\n    pointlist = decompose(Point{2, promote_type(T1, T2)}, ls)\n    c = false\n    @inbounds for counter in eachindex(pointlist)\n        q1 = pointlist[counter]","category":"page"},{"location":"source/methods/contains/","page":"-","title":"-","text":"if reached last point, set \"next point\" to first point","category":"page"},{"location":"source/methods/contains/","page":"-","title":"-","text":"        if counter == length(pointlist)\n            q2 = pointlist[1]\n        else\n            q2 = pointlist[counter + 1]\n        end\n        if q1 == point","category":"page"},{"location":"source/methods/contains/","page":"-","title":"-","text":"allowonedge || error(\"isinside(): VertexException a\")","category":"page"},{"location":"source/methods/contains/","page":"-","title":"-","text":"            continue\n        end\n        if q2[2] == point[2]\n            if q2[1] == point[1]","category":"page"},{"location":"source/methods/contains/","page":"-","title":"-","text":"allowonedge || error(\"isinside(): VertexException b\")","category":"page"},{"location":"source/methods/contains/","page":"-","title":"-","text":"                continue\n            elseif (q1[2] == point[2]) && ((q2[1] > point[1]) == (q1[1] < point[1]))","category":"page"},{"location":"source/methods/contains/","page":"-","title":"-","text":"allowonedge || error(\"isinside(): EdgeException\")","category":"page"},{"location":"source/methods/contains/","page":"-","title":"-","text":"                continue\n            end\n        end\n        if (q1[2] < point[2]) != (q2[2] < point[2]) # crossing\n            if q1[1] >= point[1]\n                if q2[1] > point[1]\n                    c = !c\n                elseif ((_cross(q1, q2, point) > 0) == (q2[2] > q1[2]))\n                    c = !c\n                end\n            elseif q2[1] > point[1]\n                if ((_cross(q1, q2, point) > 0) == (q2[2] > q1[2]))\n                    c = !c\n                end\n            end\n        end\n    end\n    return c\n\nend\n\nfunction contains(poly::Polygon{2, T1}, point::Point{2, T2}) where {T1, T2}\n    c = contains(poly.exterior, point)\n    for interior in poly.interiors\n        if contains(interior, point)\n            return false\n        end\n    end\n    return c\nend","category":"page"},{"location":"source/methods/contains/","page":"-","title":"-","text":"TODOs: implement contains for mesh, simplex, and 3d objects (eg rect, triangle, etc.)","category":"page"},{"location":"source/methods/contains/","page":"-","title":"-","text":"contains(mp::MultiPolygon{2, T1}, point::Point{2, T2}) where {T1, T2} = any((contains(poly, point) for poly in mp.polygons))","category":"page"},{"location":"source/methods/contains/","page":"-","title":"-","text":"","category":"page"},{"location":"source/methods/contains/","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"source/transformations/flip/","page":"-","title":"-","text":"\"\"\"\n    flip(obj)\n\nSwap all of the x and y coordinates in obj, otherwise\nkeeping the original structure (but not necessarily the\noriginal type).\n\"\"\"\nfunction flip(geom)\n    if _is3d(geom)\n        return apply(PointTrait, geom) do p\n            (GI.y(p), GI.x(p), GI.z(p))\n        end\n    else\n        return apply(PointTrait, geom) do p\n            (GI.y(p), GI.x(p))\n        end\n    end\nend","category":"page"},{"location":"source/transformations/flip/","page":"-","title":"-","text":"","category":"page"},{"location":"source/transformations/flip/","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"source/transformations/simplify/","page":"-","title":"-","text":"abstract type SimplifyAlg end\n\nconst SIMPLIFY_ALG_KEYWORDS = \"\"\"\n# Keywords\n- `ratio`: the fraction of points that should remain after `simplify`.\n    Useful as it will generalise for large collections of objects.\n- `number`: the number of points that should remain after `simplify`.\n    Less useful for large collections of mixed size objects.\n\"\"\"\n\nconst MIN_POINTS = 3\n\nfunction checkargs(number, ratio, tol)\n    count(isnothing, (number, ratio, tol)) == 2 ||\n        error(\"Must provide one of `number`, `ratio` or `tol` keywords\")\n    if !isnothing(ratio)\n        if ratio <= 0 || ratio > 1\n            error(\"`ratio` must be 0 < ratio <= 1. Got $ratio\")\n        end\n    end\n    if !isnothing(number)\n        if number < MIN_POINTS\n            error(\"`number` must be $MIN_POINTS or larger. Got $number\")\n        end\n    end\n    return nothing\nend\n\n\"\"\"\n    simplify(obj; kw...)\n    simplify(::SimplifyAlg, obj)\n\nSimplify a geometry, feature, feature collection,\nor nested vectors or a table of these.\n\n`RadialDistance`, `DouglasPeucker`, or\n`VisvalingamWhyatt` algorithms are available,\nlisted in order of increasing quality but decreaseing performance.\n\n`PoinTrait` and `MultiPointTrait` are returned unchanged.\n\nThe default behaviour is `simplify(DouglasPeucker(; kw...), obj)`.\nPass in other `SimplifyAlg` to use other algorithms.","category":"page"},{"location":"source/transformations/simplify/","page":"-","title":"-","text":"Example","category":"page"},{"location":"source/transformations/simplify/","page":"-","title":"-","text":"Simplify a polygon to have six points:\n\n```jldoctest\nimport GeoInterface as GI\nimport GeometryOps as GO\n\npoly = GI.Polygon([[\n    [-70.603637, -33.399918],\n    [-70.614624, -33.395332],\n    [-70.639343, -33.392466],\n    [-70.659942, -33.394759],\n    [-70.683975, -33.404504],\n    [-70.697021, -33.419406],\n    [-70.701141, -33.434306],\n    [-70.700454, -33.446339],\n    [-70.694274, -33.458369],\n    [-70.682601, -33.465816],\n    [-70.668869, -33.472117],\n    [-70.646209, -33.473835],\n    [-70.624923, -33.472117],\n    [-70.609817, -33.468107],\n    [-70.595397, -33.458369],\n    [-70.587158, -33.442901],\n    [-70.587158, -33.426283],\n    [-70.590591, -33.414248],\n    [-70.594711, -33.406224],\n    [-70.603637, -33.399918]]])\n\nsimple = GO.simplify(poly; number=6)\nGI.npoint(simple)","category":"page"},{"location":"source/transformations/simplify/","page":"-","title":"-","text":"output","category":"page"},{"location":"source/transformations/simplify/","page":"-","title":"-","text":"6\n```\n\"\"\"\nsimplify(data; kw...) = _simplify(DouglasPeucker(; kw...), data)\nsimplify(alg::SimplifyAlg, data) = _simplify(alg, data)\n\nfunction _simplify(alg::SimplifyAlg, data)","category":"page"},{"location":"source/transformations/simplify/","page":"-","title":"-","text":"Apply simplication to all curves, multipoints, and points, reconstructing everything else around them.","category":"page"},{"location":"source/transformations/simplify/","page":"-","title":"-","text":"    simplifier(geom) = _simplify(trait(geom), alg, geom)\n    apply(simplifier, Union{PolygonTrait,AbstractCurveTrait,MultiPoint,PointTrait}, data)\nend","category":"page"},{"location":"source/transformations/simplify/","page":"-","title":"-","text":"For Point and MultiPoint traits we do nothing","category":"page"},{"location":"source/transformations/simplify/","page":"-","title":"-","text":"_simplify(::PointTrait, alg, geom) = geom\n_simplify(::MultiPointTrait, alg, geom) = geom\nfunction _simplify(::PolygonTrait, alg, geom)","category":"page"},{"location":"source/transformations/simplify/","page":"-","title":"-","text":"Force treating children as LinearRing","category":"page"},{"location":"source/transformations/simplify/","page":"-","title":"-","text":"    rebuilder(g) = rebuild(g, _simplify(LinearRingTrait(), alg, g))\n    lrs = map(rebuilder, GI.getgeom(geom))\n    return rebuild(geom, lrs)\nend","category":"page"},{"location":"source/transformations/simplify/","page":"-","title":"-","text":"For curves and rings we simplify","category":"page"},{"location":"source/transformations/simplify/","page":"-","title":"-","text":"_simplify(::AbstractCurveTrait, alg, geom) = rebuild(geom, simplify(alg, tuple_points(geom)))\nfunction _simplify(::LinearRingTrait, alg, geom)","category":"page"},{"location":"source/transformations/simplify/","page":"-","title":"-","text":"Make a vector of points","category":"page"},{"location":"source/transformations/simplify/","page":"-","title":"-","text":"    points = tuple_points(geom)","category":"page"},{"location":"source/transformations/simplify/","page":"-","title":"-","text":"Simplify it once","category":"page"},{"location":"source/transformations/simplify/","page":"-","title":"-","text":"    simple = _simplify(alg, points)\n\n    return rebuild(geom, simple)\nend\n\n\"\"\"\n    RadialDistance <: SimplifyAlg\n\nSimplifies geometries by removing points less than\n`tol` distance from the line between its neighboring points.\n\n$SIMPLIFY_ALG_KEYWORDS\n- `tol`: the minimum distance between points.\n\"\"\"\nstruct RadialDistance <: SimplifyAlg\n    number::Union{Int64,Nothing}\n    ratio::Union{Float64,Nothing}\n    tol::Union{Float64,Nothing}\nend\nfunction RadialDistance(; number=nothing, ratio=nothing, tol=nothing)\n    checkargs(number, ratio, tol)\n    return RadialDistance(number, ratio, tol)\nend\n\nsettol(alg::RadialDistance, tol) = RadialDistance(alg.number, alg.ratio, tol)\n\nfunction _simplify(alg::RadialDistance, points::Vector)\n    previous = first(points)\n    distances = Array{Float64}(undef, length(points))\n    for i in eachindex(points)\n        point = points[i]\n        distances[i] = _squared_dist(point, previous)\n        previous = point\n    end","category":"page"},{"location":"source/transformations/simplify/","page":"-","title":"-","text":"Never remove the end points","category":"page"},{"location":"source/transformations/simplify/","page":"-","title":"-","text":"    distances[begin] = distances[end] = Inf","category":"page"},{"location":"source/transformations/simplify/","page":"-","title":"-","text":"This avoids taking the square root of each distance above","category":"page"},{"location":"source/transformations/simplify/","page":"-","title":"-","text":"    if !isnothing(alg.tol)\n        alg = settol(alg, (alg.tol::Float64)^2)\n    end\n    return _get_points(alg, points, distances)\nend\n\nfunction _squared_dist(p1, p2)\n    dx = GI.x(p1) - GI.x(p2)\n    dy = GI.y(p1) - GI.y(p2)\n    return dx^2 + dy^2\nend\n\n\"\"\"\n    DouglasPeucker <: SimplifyAlg\n\n    DouglasPeucker(; number, ratio, tol)\n\nSimplifies geometries by removing points below `tol`\ndistance from the line between its neighboring points.\n\n$SIMPLIFY_ALG_KEYWORDS\n- `tol`: the minimum distance a point will be from the line\n    joining its neighboring points.\n\"\"\"\nstruct DouglasPeucker <: SimplifyAlg\n    number::Union{Int64,Nothing}\n    ratio::Union{Float64,Nothing}\n    tol::Union{Float64,Nothing}\n    prefilter::Bool\nend\nfunction DouglasPeucker(; number=nothing, ratio=nothing, tol=nothing, prefilter=false)\n    checkargs(number, ratio, tol)\n    return DouglasPeucker(number, ratio, tol, prefilter)\nend\n\nsettol(alg::DouglasPeucker, tol) = DouglasPeucker(alg.number, alg.ratio, tol, alg.prefilter)\n\nfunction _simplify(alg::DouglasPeucker, points::Vector)\n    length(points) <= MIN_POINTS && return points","category":"page"},{"location":"source/transformations/simplify/","page":"-","title":"-","text":"TODO do we need this? points = alg.prefilter ? simplify(RadialDistance(alg.tol), points) : points","category":"page"},{"location":"source/transformations/simplify/","page":"-","title":"-","text":"    distances = _build_tolerances(_squared_segdist, points)\n    return _get_points(alg, points, distances)\nend\n\nfunction _squared_segdist(l1, p, l2)\n    x, y = GI.x(l1), GI.y(l1)\n    dx = GI.x(l2) - x\n    dy = GI.y(l2) - y\n\n    if !iszero(dx) || !iszero(dy)\n        t = ((GI.x(p) - x) * dx + (GI.y(p) - y) * dy) / (dx * dx + dy * dy)\n        if t > 1\n            x = GI.x(l2)\n            y = GI.y(l2)\n        elseif t > 0\n            x += dx * t\n            y += dy * t\n        end\n    end\n\n    dx = GI.x(p) - x\n    dy = GI.y(p) - y\n\n    return dx^2 + dy^2\nend\n\n\n\"\"\"\n    VisvalingamWhyatt <: SimplifyAlg\n\n    VisvalingamWhyatt(; kw...)\n\nSimplifies geometries by removing points below `tol`\ndistance from the line between its neighboring points.\n\n$SIMPLIFY_ALG_KEYWORDS\n- `tol`: the minimum area of a triangle made with a point and\n    its neighboring points.\n\"\"\"\nstruct VisvalingamWhyatt <: SimplifyAlg\n    number::Union{Int,Nothing}\n    ratio::Union{Float64,Nothing}\n    tol::Union{Float64,Nothing}\n    prefilter::Bool\nend\nfunction VisvalingamWhyatt(; number=nothing, ratio=nothing, tol=nothing, prefilter=false)\n    checkargs(number, ratio, tol)\n    return VisvalingamWhyatt(number, ratio, tol, prefilter)\nend\n\nsettol(alg::VisvalingamWhyatt, tol) = VisvalingamWhyatt(alg.number, alg.ratio, tol, alg.prefilter)\n\nfunction _simplify(alg::VisvalingamWhyatt, points::Vector)\n    length(points) <= MIN_POINTS && return points\n    areas = _build_tolerances(_triangle_double_area, points)","category":"page"},{"location":"source/transformations/simplify/","page":"-","title":"-","text":"This avoids diving everything by two","category":"page"},{"location":"source/transformations/simplify/","page":"-","title":"-","text":"    if !isnothing(alg.tol)\n        alg = settol(alg, (alg.tol::Float64)*2)\n    end\n    return _get_points(alg, points, areas)\nend","category":"page"},{"location":"source/transformations/simplify/","page":"-","title":"-","text":"calculates the area of a triangle given its vertices","category":"page"},{"location":"source/transformations/simplify/","page":"-","title":"-","text":"_triangle_double_area(p1, p2, p3) =\n    abs(p1[1] * (p2[2] - p3[2]) + p2[1] * (p3[2] - p1[2]) + p3[1] * (p1[2] - p2[2]))","category":"page"},{"location":"source/transformations/simplify/","page":"-","title":"-","text":"Shared utils","category":"page"},{"location":"source/transformations/simplify/","page":"-","title":"-","text":"function _build_tolerances(f, points)\n    nmax = length(points)\n    real_tolerances = _flat_tolerances(f, points)\n\n    tolerances = copy(real_tolerances)\n    i = collect(1:nmax)\n\n    min_vert = argmin(tolerances)\n    this_tolerance = tolerances[min_vert]\n    _remove!(tolerances, min_vert)\n    deleteat!(i, min_vert)\n\n    while this_tolerance < Inf\n        skip = false\n\n        if min_vert < length(i)\n            right_tolerance = f(\n                points[i[min_vert - 1]],\n                points[i[min_vert]],\n                points[i[min_vert + 1]],\n            )\n            if right_tolerance <= this_tolerance\n                right_tolerance = this_tolerance\n                skip = min_vert == 1\n            end\n\n            real_tolerances[i[min_vert]] = right_tolerance\n            tolerances[min_vert] = right_tolerance\n        end\n\n        if min_vert > 2\n            left_tolerance = f(\n                points[i[min_vert - 2]],\n                points[i[min_vert - 1]],\n                points[i[min_vert]],\n            )\n            if left_tolerance <= this_tolerance\n                left_tolerance = this_tolerance\n                skip = min_vert == 2\n            end\n            real_tolerances[i[min_vert - 1]] = left_tolerance\n            tolerances[min_vert - 1] = left_tolerance\n        end\n\n        if !skip\n            min_vert = argmin(tolerances)\n        end\n        deleteat!(i, min_vert)\n        this_tolerance = tolerances[min_vert]\n        _remove!(tolerances, min_vert)\n    end\n\n    return real_tolerances\nend\n\nfunction tuple_points(geom)\n    points = Array{Tuple{Float64,Float64}}(undef, GI.ngeom(geom))\n    for (i, p) in enumerate(GI.getpoint(geom))\n        points[i] = (GI.x(p), GI.y(p))\n    end\n    return points\nend\n\nfunction _get_points(alg, points, tolerances)\n    (; tol, number, ratio) = alg\n    bit_indices = if !isnothing(tol)\n        _tol_indices(alg.tol::Float64, points, tolerances)\n    elseif !isnothing(number)\n        _number_indices(alg.number::Int64, points, tolerances)\n    else\n        _ratio_indices(alg.ratio::Float64, points, tolerances)\n    end\n    return points[bit_indices]\nend\n\nfunction _tol_indices(tol, points, tolerances)\n    tolerances .>= tol\nend\n\nfunction _number_indices(n, points, tolerances)\n    tol = partialsort(tolerances, length(points) - n + 1)\n    bit_indices = _tol_indices(tol, points, tolerances)\n    nselected = sum(bit_indices)","category":"page"},{"location":"source/transformations/simplify/","page":"-","title":"-","text":"If there are multiple values exactly at tol we will get the wrong output length. So we need to remove some.","category":"page"},{"location":"source/transformations/simplify/","page":"-","title":"-","text":"    while nselected > n\n        min_tol = Inf\n        min_i = 0\n        for i in eachindex(bit_indices)\n            bit_indices[i] || continue\n            if tolerances[i] < min_tol\n                min_tol = tolerances[i]\n                min_i = i\n            end\n        end\n        nselected -= 1\n        bit_indices[min_i] = false\n    end\n    return bit_indices\nend\n\nfunction _ratio_indices(r, points, tolerances)\n    n = max(3, round(Int, r * length(points)))\n    return _number_indices(n, points, tolerances)\nend\n\nfunction _flat_tolerances(f, points)\n    result = Array{Float64}(undef, length(points))\n    result[1] = result[end] = Inf\n\n    for i in 2:length(result) - 1\n        result[i] = f(points[i-1], points[i], points[i+1])\n    end\n    return result\nend\n\n_remove!(s, i) = s[i:end-1] .= s[i+1:end]","category":"page"},{"location":"source/transformations/simplify/","page":"-","title":"-","text":"","category":"page"},{"location":"source/transformations/simplify/","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"source/methods/within/","page":"-","title":"-","text":"\"\"\"\n    within(geom1, geom)::Bool\n\nReturn `true` if the first geometry is completely within the second geometry.\nThe interiors of both geometries must intersect and, the interior and boundary of the primary (geometry a)\nmust not intersect the exterior of the secondary (geometry b).\n`within` returns the exact opposite result of `contains`.","category":"page"},{"location":"source/methods/within/","page":"-","title":"-","text":"Examples","category":"page"},{"location":"source/methods/within/","page":"-","title":"-","text":"```jldoctest\njulia> line = LineString([[1, 1], [1, 2], [1, 3], [1, 4]])\nLineString(Array{Float64,1}[[1.0, 1.0], [1.0, 2.0], [1.0, 3.0], [1.0, 4.0]])\n\njulia> point = Point([1, 2])\nPoint([1.0, 2.0])\n\njulia> within(point, line)\ntrue\n```\n\"\"\"\nwithin(g1, g2)::Bool = within(trait(g1), g1, trait(g2), g2)::Bool\nwithin(t1::FeatureTrait, g1, t2, g2)::Bool = within(GI.geometry(g1), g2)\nwithin(t1, g1, t2::FeatureTrait, g2)::Bool = within(g1, geometry(g2))\nwithin(t1::PointTrait, g1::LineStringTrait, t2, g2)::Bool = point_on_line(ft1, ft2, true)\nwithin(t1::PointTrait, g1, t2::PolygonTrait, g2)::Bool = point_in_polygon(ft1, ft2, true)\nwithin(t1::LineStringTrait, g1, t2::PolygonTrait, g2)::Bool = line_in_polygon(ft1, ft2)\nwithin(t1::LineStringTrait, g1, t2::LineStringTrait, g2)::Bool = line_on_line(ft1, ft2)\nwithin(t1::PolygonTrait, g1, t2::PolygonTrait, g2)::Bool = polygon_in_polygon(ft1, ft2, true)","category":"page"},{"location":"source/methods/within/","page":"-","title":"-","text":"","category":"page"},{"location":"source/methods/within/","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"source/methods/signed_area/#Signed-area","page":"Signed area","title":"Signed area","text":"","category":"section"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"export signed_area","category":"page"},{"location":"source/methods/signed_area/#What-is-signed-area?","page":"Signed area","title":"What is signed area?","text":"","category":"section"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"Signed area is simply the integral over the exterior path of a polygon, minus the sum of integrals over its interior holes.","category":"page"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"It is signed such that a clockwise path has a positive area, and a counterclockwise path has a negative area.","category":"page"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"To provide an example, consider this rectangle:","category":"page"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"using GeometryBasics\nrect = Polygon([Point(0,0), Point(0,1), Point(1,1), Point(1,0), Point(0, 0)])\nf, a, p = poly(rect; axis = (; aspect = DataAspect()))","category":"page"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"This is clearly a rectangle, etc.  But now let's look at how the points look:","category":"page"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"lines!(a, rect; color = 1:length(coordinates(rect))+1)\nf","category":"page"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"The points are ordered in a clockwise fashion, which means that the signed area is positive.  If we reverse the order of the points, we get a negative area.","category":"page"},{"location":"source/methods/signed_area/#Implementation","page":"Signed area","title":"Implementation","text":"","category":"section"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"This is the GeoInterface-compatible implementation.","category":"page"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"First, we implement a wrapper method that dispatches to the correct implementation based on the geometry trait.","category":"page"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"This is also used in the implementation, since it's a lot less work!","category":"page"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"\"\"\"\n    signed_area(geom)::Real\n\nReturns the signed area of the geometry, based on winding order.\n\"\"\"\nsigned_area(x) = signed_area(GI.trait(x), x)","category":"page"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"TODOS here:","category":"page"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"This could conceivably be multithreaded.  How to indicate that it should be so?\nWhat to do for corner cases (nan point, etc)?","category":"page"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"function signed_area(::Union{LineStringTrait, LinearRingTrait}, geom)","category":"page"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"Basically, we integrate the area under the line string, which gives us the signed area.","category":"page"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"    point₁ = GI.getpoint(geom, 1)\n    point₂ = GI.getpoint(geom, 2)\n    area = GI.x(point₁) * GI.y(point₂) - GI.y(point₁) * GI.x(point₂)\n    for point in GI.getpoint(geom)","category":"page"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"Advance the point buffers by 1 point","category":"page"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"        point₁ = point₂\n        point₂ = point","category":"page"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"Accumulate the area into area","category":"page"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"        area += GI.x(point₁) * GI.y(point₂) - GI.y(point₁) * GI.x(point₂)\n    end\n    area /= 2\n    return area\nend","category":"page"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"This subtracts the","category":"page"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"function signed_area(::PolygonTrait, geom)\n    s_area = signed_area(GI.getexterior(geom))\n    area = abs(s_area)\n    for hole in GI.gethole(geom)\n        area -= abs(signed_area(hole))\n    end\n    return area * sign(s_area)\nend\n\nsigned_area(::MultiPolygonTrait, geom) = sum((signed_area(poly) for poly in GI.getpolygon(geom)))","category":"page"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"This should theoretically work for anything, but I haven't actually tested yet!","category":"page"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"Below is the original GeometryBasics implementation:","category":"page"},{"location":"source/methods/signed_area/#julia","page":"Signed area","title":"```julia","text":"","category":"section"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"function signed_area(a::Point{2, T}, b::Point{2, T}, c::Point{2, T}) where T     return ((b[1] - a[1]) * (c[2] - a[2]) - (c[1] - a[1]) * (b[2] - a[2])) / 2 end","category":"page"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"function signed_area(points::AbstractVector{<: Point{2, T}}) where {T}     area = sum((points[i][1] * points[i+1][2] - points[i][2] * points[i+1][1] for i in 1:(length(points)-1))) / 2.0 end","category":"page"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"function signedarea(ls::GeometryBasics.LineString)     # coords = GeometryBasics.decompose(Point2f, ls)     return sum((p1[1] * p2[2] - p1[2] * p2[1] for (p1, p2) in ls)) / 2.0#signedarea(coords) end","category":"page"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"function signedarea(poly::GeometryBasics.Polygon{2})     sarea = signedarea(poly.exterior)     area = abs(sarea)     for hole in poly.interiors         area -= abs(signedarea(hole))     end     return area * sign(sarea) end","category":"page"},{"location":"source/methods/signed_area/#WARNING:-this-may-not-do-what-you-expect,-since-it's","page":"Signed area","title":"WARNING: this may not do what you expect, since it's","text":"","category":"section"},{"location":"source/methods/signed_area/#sensitive-to-winding-order.-Use-GeoInterface.area-instead.","page":"Signed area","title":"sensitive to winding order.  Use GeoInterface.area instead.","text":"","category":"section"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"signedarea(mp::MultiPolygon) = sum(signedarea.(mp.polygons)) ```","category":"page"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"","category":"page"},{"location":"source/methods/signed_area/","page":"Signed area","title":"Signed area","text":"This page was generated using Literate.jl.","category":"page"},{"location":"source/methods/intersects/","page":"-","title":"-","text":"\"\"\"\n    intersects(line_a, line_b)\n\nCheck if `line_a` intersects with `line_b`.\n\nThese can be `LineTrait`, `LineStringTrait` or `LinearRingTrait`\n\"\"\"\nintersects(a, b) = isnothing(intersection) # Probably faster ways to do this\n\n\"\"\"\n    intersection(line_a, line_b)\n\nFind a point that intersects LineStrings with two coordinates each.\n\nReturns `nothing` if no point is found.","category":"page"},{"location":"source/methods/intersects/","page":"-","title":"-","text":"Examples","category":"page"},{"location":"source/methods/intersects/","page":"-","title":"-","text":"```jldoctest\njulia>\nline1 = LineString([[124.584961,-12.768946],[126.738281,-17.224758]])\nLineString(Array{Float64,1}[[124.585, -12.7689], [126.738, -17.2248]])\n\njulia> line2 = LineString([[123.354492,-15.961329],[127.22168,-14.008696]])\nLineString(Array{Float64,1}[[123.354, -15.9613], [127.222, -14.0087]])\n\njulia>\nintersection(line1, line2)\nPoint([125.584, -14.8357])\n```\n\"\"\"\nintersection(line_a, line_b) = intersection(trait(line_a), line_a, trait(line_b), line_b)\nfunction intersection(\n    ::Union{LineStringTrait,LinearRingTrait}, line_a,\n    ::Union{LineStringTrait,LinearRingTrait}, line_b,\n)\n    result = Tuple{Float64,Float64}[] # TODO handle 3d, and other Real ?\n    a1 = GI.getpoint(line_a, 1)\n    b1 = GI.getpoint(line_b, 1)","category":"page"},{"location":"source/methods/intersects/","page":"-","title":"-","text":"TODO we can check all of these against the extent of line_b and continue the loop if theyre outside","category":"page"},{"location":"source/methods/intersects/","page":"-","title":"-","text":"    for i in 1:GI.npoint(line1) - 1\n        for j in 1:GI.npoint(line_b) - 1\n            a2 = GI.getpoint(line_a, i + 1)\n            b2 = GI.getpoint(line_b, j + 1)\n            inter = _intersection((a1, a2), (b1, b2))\n            isnothing(inter) || push!(result, inter)\n            a1 = a2\n            b1 = b2\n        end\n    end\n    return unique!(result)\nend\n\nfunction intersection(::LineTrait, line_a, ::LineTrait, line_b)\n    a1 = GI.getpoint(line_a, 1)\n    b1 = GI.getpoint(line_b, 1)\n    a2 = GI.getpoint(line_a, 2)\n    b2 = GI.getpoint(line_b, 2)\n\n    return _intersection((a1, a2), (b1, b2))\nend\n\nfunction _intersection((p11, p12)::Tuple, (p21, p22)::Tuple)","category":"page"},{"location":"source/methods/intersects/","page":"-","title":"-","text":"Get points from lines","category":"page"},{"location":"source/methods/intersects/","page":"-","title":"-","text":"    x1, y1 = GI.x(p11), GI.y(p11)\n    x2, y2 = GI.x(p12), GI.y(p12)\n    x3, y3 = GI.x(p21), GI.y(p21)\n    x4, y4 = GI.x(p22), GI.y(p22)\n\n    d = ((y4 - y3) * (x2 - x1)) - ((x4 - x3) * (y2 - y1))\n    a = ((x4 - x3) * (y1 - y3)) - ((y4 - y3) * (x1 - x3))\n    b = ((x2 - x1) * (y1 - y3)) - ((y2 - y1) * (x1 - x3))\n\n    if d == 0\n        if a == 0 && b == 0\n            return nothing\n        end\n        return nothing\n    end\n\n    ã  = a / d\n    b̃  = b / d\n\n    if ã  >= 0 && ã  <= 1 && b̃  >= 0 && b̃  <= 1\n        x = x1 + (ã  * (x2 - x1))\n        y = y1 + (ã  * (y2 - y1))\n        return (x, y)\n    end\n\n    return nothing\nend","category":"page"},{"location":"source/methods/intersects/","page":"-","title":"-","text":"","category":"page"},{"location":"source/methods/intersects/","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"source/utils/","page":"-","title":"-","text":"_is3d(geom) = _is3d(GI.trait(geom), geom)\n_is3d(::GI.AbstractGeometryTrait, geom) = GI.is3d(geom)\n_is3d(::GI.FeatureTrait, feature) = _is3d(GI.geometry(feature))\n_is3d(::GI.FeatureCollectionTrait, fc) = _is3d(GI.getfeature(fc, 1))\n_is3d(::Nothing, geom) = _is3d(first(geom)) # Otherwise step into an itererable","category":"page"},{"location":"source/utils/","page":"-","title":"-","text":"","category":"page"},{"location":"source/utils/","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"source/methods/bools/","page":"Examples","title":"Examples","text":"These are all adapted from Turf.jl The may not necessarily be what want in the end but work for now","category":"page"},{"location":"source/methods/bools/","page":"Examples","title":"Examples","text":"\"\"\"\n    isclockwise(line::Union{LineString, Vector{Position}})::Bool\n\nTake a ring and return true or false whether or not the ring is clockwise or counter-clockwise.","category":"page"},{"location":"source/methods/bools/","page":"Examples","title":"Examples","text":"Examples","category":"page"},{"location":"source/methods/bools/","page":"Examples","title":"Examples","text":"```jldoctest\nimport GeoInterface as GI, GeometryOps as GO\njulia>\nline = GI.LineString([(0, 0), (1, 1), (1, 0), (0, 0)])\nGeoInterface.Wrappers.LineString{false, false, Vector{Tuple{Int64, Int64}}, Nothing, Nothing}([(0, 0), (1, 1), (1, 0), (0, 0)], nothing, nothing)\n\njulia> GO.isclockwise(line)\ntrue\n```\n\"\"\"\nisclockwise(geom)::Bool = isclockwise(GI.trait(geom), geom)\nfunction isclockwise(::AbstractCurveTrait, line)::Bool\n    sum = 0.0\n    prev = GI.getpoint(line, 1)\n    for p in GI.getpoint(line)","category":"page"},{"location":"source/methods/bools/","page":"Examples","title":"Examples","text":"sum will be zero for the first point as x is subtracted from itself","category":"page"},{"location":"source/methods/bools/","page":"Examples","title":"Examples","text":"        sum += (GI.x(p) - GI.x(prev)) * (GI.y(p) + GI.y(prev))\n        prev = p\n    end\n\n    return sum > 0.0\nend\n\n\"\"\"\n    isconcave(poly::Polygon)::Bool\n\nTake a polygon and return true or false as to whether it is concave or not.","category":"page"},{"location":"source/methods/bools/","page":"Examples","title":"Examples","text":"Examples","category":"page"},{"location":"source/methods/bools/","page":"Examples","title":"Examples","text":"```jldoctest\nimport GeoInterface as GI, GeometryOps as GO\njulia> poly = GI.Polygon([[(0, 0), (0, 1), (1, 1), (1, 0), (0, 0)]])\nPolygon(Array{Array{Float64,1},1}[[[0.0, 0.0], [0.0, 1.0], [1.0, 1.0], [1.0, 0.0], [0.0, 0.0]]])\n\njulia> GO.isconcave(poly)\nfalse\n```\n\"\"\"\nfunction isconcave(poly)::Bool\n    sign = false\n\n    exterior = GI.getexterior(poly)\n    GI.npoint(exterior) <= 4 && return false\n\n    n = GI.npoint(exterior) - 1\n\n    for i in 1:n\n        j = ((i + 1) % n) === 0 ? 1 : (i + 1) % n\n        m = ((i + 2) % n) === 0 ? 1 : (i + 2) % n\n\n        pti = GI.getpoint(exterior, i)\n        ptj = GI.getpoint(exterior, j)\n        ptm = GI.getpoint(exterior, m)\n\n        dx1 = GI.x(ptm) - GI.x(ptj)\n        dy1 = GI.y(ptm) - GI.y(ptj)\n        dx2 = GI.x(pti) - GI.x(ptj)\n        dy2 = GI.y(pti) - GI.y(ptj)\n\n        cross = (dx1 * dy2) - (dy1 * dx2)\n\n        if i === 0\n            sign = cross > 0\n        elseif sign !== (cross > 0)\n            return true\n        end\n    end\n\n    return false\nend\n\n\nfunction equals(geo1, geo2)\n    GI.geomtrait(geo1) !== GI.geomtrait(geo2) && return false\n\n    GI.geomtrait(geo1) isa PointTrait && return compare_points(geo1, geo2)\n    GI.geomtrait(geo1) isa LineStringTrait && return compare_lines(geo1, geo2)\n\n    error(\"Cant compare $(GI.trait(geo1)) and $(GI.trait(geo2)) yet\")\nend\n\nfunction compare_points(p1, p2)\n    length(p1) !== length(p2) && return false\n\n    for i in eachindex(p1)\n        round(p1[i]; digits=10) !== round(p2[i]; digits=10) && return false\n    end\n\n    return true\nend\n\nfunction compare_lines(p1::Vector, p2::Vector)","category":"page"},{"location":"source/methods/bools/","page":"Examples","title":"Examples","text":"TODO: complete this","category":"page"},{"location":"source/methods/bools/","page":"Examples","title":"Examples","text":"    length(p1[1]) !== length(p2[1]) && return false\nend","category":"page"},{"location":"source/methods/bools/","page":"Examples","title":"Examples","text":"\"\"\"     parallel(line1::LineString, line2::LineString)::Bool","category":"page"},{"location":"source/methods/bools/","page":"Examples","title":"Examples","text":"Return true if each segment of line1 is parallel to the correspondent segment of line2","category":"page"},{"location":"source/methods/bools/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"source/methods/bools/","page":"Examples","title":"Examples","text":"import GeoInterface as GI, GeometryOps as GO\njulia> line1 = GI.LineString([(9.170356, 45.477985), (9.164434, 45.482551), (9.166644, 45.484003)])\nGeoInterface.Wrappers.LineString{false, false, Vector{Tuple{Float64, Float64}}, Nothing, Nothing}([(9.170356, 45.477985), (9.164434, 45.482551), (9.166644, 45.484003)], nothing, nothing)\n\njulia> line2 = GI.LineString([(9.169356, 45.477985), (9.163434, 45.482551), (9.165644, 45.484003)])\nGeoInterface.Wrappers.LineString{false, false, Vector{Tuple{Float64, Float64}}, Nothing, Nothing}([(9.169356, 45.477985), (9.163434, 45.482551), (9.165644, 45.484003)], nothing, nothing)\n\njulia>\nGO.isparallel(line1, line2)\ntrue","category":"page"},{"location":"source/methods/bools/","page":"Examples","title":"Examples","text":"\"\"\" function isparallel(line1, line2)::Bool     seg1 = linesegment(line1)     seg2 = linesegment(line2)","category":"page"},{"location":"source/methods/bools/","page":"Examples","title":"Examples","text":"for i in eachindex(seg1)\n    coors2 = nothing\n    coors1 = seg1[i]\n    coors2 = seg2[i]\n    _isparallel(coors1, coors2) == false && return false\nend\nreturn true","category":"page"},{"location":"source/methods/bools/","page":"Examples","title":"Examples","text":"end","category":"page"},{"location":"source/methods/bools/","page":"Examples","title":"Examples","text":"@inline function isparallel(p1, p2)     slope1 = bearingtoazimuth(rhumbbearing(GI.x(p1), GI.x(p2)))     slope2 = bearingtoazimuth(rhumb_bearing(GI.y(p1), GI.y(p2)))","category":"page"},{"location":"source/methods/bools/","page":"Examples","title":"Examples","text":"return slope1 === slope2","category":"page"},{"location":"source/methods/bools/","page":"Examples","title":"Examples","text":"end","category":"page"},{"location":"source/methods/bools/","page":"Examples","title":"Examples","text":"\"\"\"\n    point_on_line(point::Point, line::LineString, ignoreEndVertices::Bool=false)::Bool\n\nReturn true if a point is on a line. Accept a optional parameter to ignore the\nstart and end vertices of the linestring.","category":"page"},{"location":"source/methods/bools/","page":"Examples","title":"Examples","text":"Examples","category":"page"},{"location":"source/methods/bools/","page":"Examples","title":"Examples","text":"```jldoctest\nimport GeoInterface as GI, GeometryOps as GO\njulia> point = GI.Point(1, 1)\nGeoInterface.Wrappers.Point{false, false, Tuple{Int64, Int64}, Nothing}((1, 1), nothing)\n\njulia> line = GI.LineString([(0, 0), (3, 3), (4, 4)])\nGeoInterface.Wrappers.LineString{false, false, Vector{Tuple{Int64, Int64}}, Nothing, Nothing}([(0, 0), (3, 3), (4, 4)], nothing, nothing)\n\njulia> GO.point_on_line(point, line)\ntrue\n```\n\"\"\"\nfunction point_on_line(point, line; ignore_end_vertices::Bool=false)::Bool\n    line_points = tuple_points(line)\n    n = length(line_points)\n\n    ignore = :none\n    for i in 1:n - 1\n        if ignore_end_vertices == true\n            if i === 1\n                ignore = :start\n            elseif i === n - 2\n                ignore = :end\n            elseif (i === 1 && i + 1 === n - 1)\n                ignore = :both\n            end\n        end\n        if point_on_segment(line_points[i], line_points[i + 1], point, ignore)\n            return true\n        end\n    end\n    return false\nend\n\nfunction point_on_segment(start, stop, point, exclude_boundary::Symbol=:none)::Bool\n    x, y = GI.x(point), GI.y(point)\n    x1, y1 = GI.x(start), GI.y(start)\n    x2, y2 = GI.x(stop), GI.y(stop)\n\n    dxc = x - x1\n    dyc = y - y1\n    dx1 = x2 - x1\n    dy1 = y2 - y1","category":"page"},{"location":"source/methods/bools/","page":"Examples","title":"Examples","text":"TODO use better predicate for crossing here","category":"page"},{"location":"source/methods/bools/","page":"Examples","title":"Examples","text":"    cross = dxc * dy1 - dyc * dx1\n    cross != 0 && return false","category":"page"},{"location":"source/methods/bools/","page":"Examples","title":"Examples","text":"Will constprop optimise these away?","category":"page"},{"location":"source/methods/bools/","page":"Examples","title":"Examples","text":"    if exclude_boundary === :none\n        if abs(dx1) >= abs(dy1)\n            return dx1 > 0 ? x1 <= x && x <= x2 : x2 <= x && x <= x1\n        end\n        return dy1 > 0 ? y1 <= y && y <= y2 : y2 <= y && y <= y1\n    elseif exclude_boundary === :start\n        if abs(dx1) >= abs(dy1)\n             return dx1 > 0 ? x1 < x && x <= x2 : x2 <= x && x < x1\n        end\n        return dy1 > 0 ? y1 < y && y <= y2 : y2 <= y && y < y1\n    elseif exclude_boundary === :end\n        if abs(dx1) >= abs(dy1)\n            return dx1 > 0 ? x1 <= x && x < x2 : x2 < x && x <= x1\n        end\n        return dy1 > 0 ? y1 <= y && y < y2 : y2 < y && y <= y1\n    elseif exclude_boundary === :both\n        if abs(dx1) >= abs(dy1)\n            return dx1 > 0 ? x1 < x && x < x2 : x2 < x && x < x1\n        end\n        return dy1 > 0 ? y1 < y && y < y2 : y2 < y && y < y1\n    end\n    return false\nend\n\n\"\"\"\n    point_in_polygon(point::Point, polygon::Union{Polygon, MultiPolygon}, ignoreBoundary::Bool=false)::Bool\n\nTake a Point and a Polygon and determine if the point\nresides inside the polygon. The polygon can be convex or concave. The function accounts for holes.","category":"page"},{"location":"source/methods/bools/","page":"Examples","title":"Examples","text":"Examples","category":"page"},{"location":"source/methods/bools/","page":"Examples","title":"Examples","text":"```jldoctest\nimport GeoInterface as GI, GeometryOps as GO\njulia> point = (-77.0, 44.0)\n(-77.0, 44.0)\n\njulia> poly = GI.Polygon([[[-81, 41], [-81, 47], [-72, 47], [-72, 41], [-81, 41]]])\nPolygon(Array{Array{Float64,1},1}[[[-81.0, 41.0], [-81.0, 47.0], [-72.0, 47.0], [-72.0, 41.0], [-81.0, 41.0]]])\n\njulia> GO.point_in_polygon(point, poly)\ntrue\n```\n\"\"\"\nfunction point_in_polygon(p, polygon, ignore_boundary::Bool=false)::Bool\n    GI.trait(polygon) isa PolygonTrait || throw(ArgumentError(\"Not a polygon\"))\n\n    point_in_extent(p, GI.extent(polygon)) || return false\n    point_in_ring(p, GI.getexterior(polygon), ignore_boundary) || return false\n\n    for ring in GI.gethole(polygon)\n        point_in_ring(pt, ring, !ignore_boundary) && return false\n    end\n    return true\nend\n\nfunction point_in_ring(pt, ring, ignore_boundary::Bool=false)\n    GI.trait(polygon) isa Union{LineStringTrait,LinearRingTrait} || throw(ArgumentError(\"Not a ring\"))\n    inside = false\n    n = GI.npoint(ring)\n    p1 = first(GI.getpoint(ring))\n    p_end = GI.getpoint(ring, n)\n\n    l = if GI.x(p1) == GI.x(p_end) && GI.y(p1) == GI.y(p_end)\n        l = n -1\n    else\n        n\n    end\n\n    for i in 1:l - 1\n        j = i + 1\n\n        p_i = GI.getpoint(ring, i)\n        p_j = GI.getpoint(ring, j)\n        xi = GI.x(p_i)\n        yi = GI.y(p_i)\n        xj = GI.x(p_j)\n        yj = GI.y(p_j)\n\n        on_boundary = (GI.y(pt) * (xi - xj) + yi * (xj - GI.x(pt)) + yj * (GI.x(pt) - xi) == 0) &&\n            ((xi - GI.x(pt)) * (xj - GI.x(pt)) <= 0) && ((yi - GI.y(pt)) * (yj - GI.y(pt)) <= 0)\n\n        on_boundary && return !ignore_boundary\n\n        intersects = ((yi > GI.y(pt)) !== (yj > GI.y(pt))) &&\n            (GI.x(pt) < (xj - xi) * (GI.y(pt) - yi) / (yj - yi) + xi)\n\n        if intersects\n            inside = !inside\n        end\n    end\n\n    return inside\nend\n\nfunction point_in_extent(p, extent::Extents.Extent)\n    extent.X[1] <= GI.x(p) && extent.Y[1] <= GI.y(p) &&\n        extent.X[2] >= GI.x(p) && extent.Y[2] >= GI.y(p)\nend\n\nfunction line_in_polygon(poly, line)\n    out = false\n\n    polybox = bbox(poly)\n    linebox = bbox(line)\n\n    !(bboxOverlap(polybox, linebox)) && return false\n\n    coords = line.coordinates\n\n    for i in 1:length(coords) - 1\n        mid = [(coords[i][1] + coords[i + 1][1]) / 2, (coords[i][2] + coords[i + 1][2]) / 2]\n        if point_in_polygon(Point(mid), poly, true)\n            out = true\n            break\n        end\n    end\n    return out\nend\n\nline_on_line(line1, line2) = line_on_line(trait(line1), line1, trait(line2), line2)\nfunction line_on_line(t1::GI.AbstractCurveTrait, line1, t2::AbstractCurveTrait, line2)\n    for p in GI.getpoint(line1)\n        point_on_line(p, line2) || return false\n    end\n    return true\nend\n\nline_in_polygon(line, poly) = line_in_polygon(trait(line), line, trait(poly), poly)\nfunction line_in_polygon(::LineStringTrait, line, ::PolygonTrait, poly)\n    polybox = bbox(poly)\n    linebox = bbox(line)\n\n    !(bboxOverlap(polybox, linebox)) && return false\n\n    coords = line.coordinates\n    inside = false\n\n    for i in 1:length(coords) - 1\n        !(point_in_polygon(Point(coords[i]), poly)) && return false\n        !inside && (inside = point_in_polygon(Point(coords[i]), poly, true))\n        if !inside\n            mid = [(coords[i][1] + coords[i + 1][1]) / 2, (coords[i][2] + coords[i + 1][2]) / 2]\n            inside = point_in_polygon(Point(mid), poly, true)\n        end\n    end\n    return inside\nend","category":"page"},{"location":"source/methods/bools/","page":"Examples","title":"Examples","text":"TODO why were there two methods for this in Turf.jl?","category":"page"},{"location":"source/methods/bools/","page":"Examples","title":"Examples","text":"function polygon_in_polygon(ft1, ft2, reverse::Bool=false)\n    polybox1 = bbox(ft1)\n    polybox2 = bbox(ft2)\n    coords = []\n\n    if reverse\n        !(bbox_overlap(polybox2, polybox1)) && return false\n\n        for point in GI.getpoint(ft1)\n            !(point_in_polygon(point, ft2)) && return false\n        end\n    else\n        !(bbox_overlap(polybox1, polybox2)) && return false\n\n        for point in GI.getpoint(ft2)\n            !(point_in_polygon(point, ft1)) && return false\n        end\n    end\n\n    return true\nend\nfunction poly_in_poly(poly1, poly2)\n\n    for point in GI.getpoint(poly1)\n        (point_in_polygon(point, poly2)) && return true\n    end\n\n    for point in GI.getpoint(poly2)\n        (point_in_polygon(point, poly1)) && return true\n    end\n\n    inter = line_intersects(polygon_to_line(poly1), polygon_to_line(poly2))\n    inter != nothing && return true\n\n    return false\n\nend\n\nfunction bbox_overlap(box1::Vector{T}, box2::Vector{T}) where {T <: Real}\n    box1[1] > box2[1] && return false\n    box1[3] < box2[3] && return false\n    box1[2] > box2[2] && return false\n    box1[4] < box2[4] && return false\n    return true\nend","category":"page"},{"location":"source/methods/bools/","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"source/methods/bools/","page":"Examples","title":"Examples","text":"This page was generated using Literate.jl.","category":"page"},{"location":"source/transformations/tuples/","page":"-","title":"-","text":"\"\"\"\n    tuples(obj)\n\nConvert all points on obj to `Tuple`s.\n\"\"\"\nfunction tuples(geom)\n    if _is3d(geom)\n        return apply(PointTrait, geom) do p\n            (GI.x(p), GI.y(p), GI.z(p))\n        end\n    else\n        return apply(PointTrait, geom) do p\n            (GI.x(p), GI.y(p))\n        end\n    end\nend","category":"page"},{"location":"source/transformations/tuples/","page":"-","title":"-","text":"","category":"page"},{"location":"source/transformations/tuples/","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"source/GeometryOps.jl.2602/","page":"-","title":"-","text":"       12 module GeometryOps\n        -\n        - using GeoInterface\n        - using GeometryBasics\n        - import Proj\n        -\n        - using GeoInterface.Extents: Extents\n        -\n        - const GI = GeoInterface\n        - const GB = GeometryBasics\n        -\n        - include(\"primitives.jl\")\n        - include(\"utils.jl\")\n        - include(\"methods/bools.jl\")\n        - include(\"methods/signed_distance.jl\")\n        - include(\"methods/signed_area.jl\")\n        - include(\"methods/centroid.jl\")\n        - include(\"methods/intersects.jl\")\n        - include(\"methods/contains.jl\")\n        - include(\"transformations/flip.jl\")\n        - include(\"transformations/simplify.jl\")\n        - include(\"transformations/flip.jl\")\n        - include(\"transformations/reproject.jl\")\n        -\n        - end","category":"page"},{"location":"source/GeometryOps.jl.2602/","page":"-","title":"-","text":"","category":"page"},{"location":"source/GeometryOps.jl.2602/","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = GeometryOps","category":"page"},{"location":"#GeometryOps","page":"Home","title":"GeometryOps","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for GeometryOps.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [GeometryOps]","category":"page"},{"location":"#GeometryOps.DouglasPeucker","page":"Home","title":"GeometryOps.DouglasPeucker","text":"DouglasPeucker <: SimplifyAlg\n\nDouglasPeucker(; number, ratio, tol)\n\nSimplifies geometries by removing points below tol distance from the line between its neighboring points.\n\nKeywords\n\nratio: the fraction of points that should remain after simplify.    Useful as it will generalise for large collections of objects.\nnumber: the number of points that should remain after simplify.   Less useful for large collections of mixed size objects.\ntol: the minimum distance a point will be from the line   joining its neighboring points.\n\n\n\n\n\n","category":"type"},{"location":"#GeometryOps.RadialDistance","page":"Home","title":"GeometryOps.RadialDistance","text":"RadialDistance <: SimplifyAlg\n\nSimplifies geometries by removing points less than tol distance from the line between its neighboring points.\n\nKeywords\n\nratio: the fraction of points that should remain after simplify.    Useful as it will generalise for large collections of objects.\nnumber: the number of points that should remain after simplify.   Less useful for large collections of mixed size objects.\ntol: the minimum distance between points.\n\n\n\n\n\n","category":"type"},{"location":"#GeometryOps.VisvalingamWhyatt","page":"Home","title":"GeometryOps.VisvalingamWhyatt","text":"VisvalingamWhyatt <: SimplifyAlg\n\nVisvalingamWhyatt(; kw...)\n\nSimplifies geometries by removing points below tol distance from the line between its neighboring points.\n\nKeywords\n\nratio: the fraction of points that should remain after simplify.    Useful as it will generalise for large collections of objects.\nnumber: the number of points that should remain after simplify.   Less useful for large collections of mixed size objects.\ntol: the minimum area of a triangle made with a point and   its neighboring points.\n\n\n\n\n\n","category":"type"},{"location":"#GeometryOps._distance-Tuple{Any, Any, Any}","page":"Home","title":"GeometryOps._distance","text":"Distance from p0 to the line segment formed by p1 and p2.  Implementation from Turf.jl.\n\n\n\n\n\n","category":"method"},{"location":"#GeometryOps.apply-Union{Tuple{Target}, Tuple{Any, Type{Target}, Any}} where Target","page":"Home","title":"GeometryOps.apply","text":"apply(f, target::Type{<:AbstractTrait}, obj; crs)\n\nReconstruct a geometry or feature using the function f on the target trait.\n\nf(target_geom) => x where x also has the target trait, or an equivalent.\n\nThe result is an functionally similar geometry with values depending on f\n\nFlipped point the order in any feature or geometry, or iterables of either:\n\n```juia import GeoInterface as GI import GeometryOps as GO geom = GI.Polygon([GI.LinearRing([(1, 2), (3, 4), (5, 6), (1, 2)]),                     GI.LinearRing([(3, 4), (5, 6), (6, 7), (3, 4)])])\n\nflipped_geom = GO.apply(GI.PointTrait, geom) do p     (GI.y(p), GI.x(p)) end\n\n\n\n\n\n","category":"method"},{"location":"#GeometryOps.flatten-Union{Tuple{Target}, Tuple{Type{Target}, Any}} where Target<:GeoInterface.AbstractTrait","page":"Home","title":"GeometryOps.flatten","text":"flatten(target::Type{<:GI.AbstractTrait}, geom)\n\nLazily flatten any geometry, feature or iterator of geometries or features so that objects with the specified trait are returned by the iterator.\n\n\n\n\n\n","category":"method"},{"location":"#GeometryOps.flip-Tuple{Any}","page":"Home","title":"GeometryOps.flip","text":"flip(obj)\n\nSwap all of the x and y coordinates in obj, otherwise keeping the original structure (but not necessarily the original type).\n\n\n\n\n\n","category":"method"},{"location":"#GeometryOps.intersection-Tuple{Any, Any}","page":"Home","title":"GeometryOps.intersection","text":"intersection(line_a, line_b)\n\nFind a point that intersects LineStrings with two coordinates each.\n\nReturns nothing if no point is found.\n\nExamples\n\njulia> \nline1 = LineString([[124.584961,-12.768946],[126.738281,-17.224758]])\nLineString(Array{Float64,1}[[124.585, -12.7689], [126.738, -17.2248]])\n\njulia> line2 = LineString([[123.354492,-15.961329],[127.22168,-14.008696]])\nLineString(Array{Float64,1}[[123.354, -15.9613], [127.222, -14.0087]])\n\njulia> \nintersection(line1, line2)\nPoint([125.584, -14.8357])\n\n\n\n\n\n","category":"method"},{"location":"#GeometryOps.intersects-Tuple{Any, Any}","page":"Home","title":"GeometryOps.intersects","text":"intersects(line_a, line_b)\n\nCheck if line_a intersects with line_b.\n\nThese can be LineTrait, LineStringTrait or LinearRingTrait\n\n\n\n\n\n","category":"method"},{"location":"#GeometryOps.isclockwise-Tuple{Any}","page":"Home","title":"GeometryOps.isclockwise","text":"isclockwise(line::Union{LineString, Vector{Position}})::Bool\n\nTake a ring and return true or false whether or not the ring is clockwise or counter-clockwise.\n\nExamples\n\nimport GeoInterface as GI, GeometryOps as GO\njulia> \nline = GI.LineString([(0, 0), (1, 1), (1, 0), (0, 0)])\nGeoInterface.Wrappers.LineString{false, false, Vector{Tuple{Int64, Int64}}, Nothing, Nothing}([(0, 0), (1, 1), (1, 0), (0, 0)], nothing, nothing)\n\njulia> GO.isclockwise(line)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GeometryOps.isconcave-Tuple{Any}","page":"Home","title":"GeometryOps.isconcave","text":"isconcave(poly::Polygon)::Bool\n\nTake a polygon and return true or false as to whether it is concave or not.\n\nExamples\n\nimport GeoInterface as GI, GeometryOps as GO\njulia> poly = GI.Polygon([[(0, 0), (0, 1), (1, 1), (1, 0), (0, 0)]])\nPolygon(Array{Array{Float64,1},1}[[[0.0, 0.0], [0.0, 1.0], [1.0, 1.0], [1.0, 0.0], [0.0, 0.0]]])\n\njulia> GO.isconcave(poly)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#GeometryOps.point_in_polygon","page":"Home","title":"GeometryOps.point_in_polygon","text":"point_in_polygon(point::Point, polygon::Union{Polygon, MultiPolygon}, ignoreBoundary::Bool=false)::Bool\n\nTake a Point and a Polygon and determine if the point resides inside the polygon. The polygon can be convex or concave. The function accounts for holes.\n\nExamples\n\nimport GeoInterface as GI, GeometryOps as GO\njulia> point = (-77.0, 44.0)\n(-77.0, 44.0)\n\njulia> poly = GI.Polygon([[[-81, 41], [-81, 47], [-72, 47], [-72, 41], [-81, 41]]])\nPolygon(Array{Array{Float64,1},1}[[[-81.0, 41.0], [-81.0, 47.0], [-72.0, 47.0], [-72.0, 41.0], [-81.0, 41.0]]])\n\njulia> GO.point_in_polygon(point, poly)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#GeometryOps.point_on_line-Tuple{Any, Any}","page":"Home","title":"GeometryOps.point_on_line","text":"point_on_line(point::Point, line::LineString, ignoreEndVertices::Bool=false)::Bool\n\nReturn true if a point is on a line. Accept a optional parameter to ignore the start and end vertices of the linestring.\n\nExamples\n\nimport GeoInterface as GI, GeometryOps as GO\njulia> point = GI.Point(1, 1)\nGeoInterface.Wrappers.Point{false, false, Tuple{Int64, Int64}, Nothing}((1, 1), nothing)\n\njulia> line = GI.LineString([(0, 0), (3, 3), (4, 4)])\nGeoInterface.Wrappers.LineString{false, false, Vector{Tuple{Int64, Int64}}, Nothing, Nothing}([(0, 0), (3, 3), (4, 4)], nothing, nothing)\n\njulia> GO.point_on_line(point, line)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GeometryOps.rebuild-Tuple{Any, Any}","page":"Home","title":"GeometryOps.rebuild","text":"rebuild(geom, child_geoms)\n\nRebuild a geometry from child geometries.\n\nBy default geometries will be rebuilt as a GeoInterface.Wrappers  geometry, but rebuild can have methods added to it to dispatch on geometries from other packages and specify how to rebuild them.\n\n(Maybe it should go into GeoInterface.jl)\n\n\n\n\n\n","category":"method"},{"location":"#GeometryOps.reconstruct-Tuple{Any, Any}","page":"Home","title":"GeometryOps.reconstruct","text":"reconstruct(geom, components)\n\nReconstruct geom from an iterable of component objects that match its structure.\n\nAll objects in components must have the same GeoInterface.trait.\n\nUsusally used in combination with flatten.\n\n\n\n\n\n","category":"method"},{"location":"#GeometryOps.reproject-Tuple{Any}","page":"Home","title":"GeometryOps.reproject","text":"reproject(geometry; source_crs, target_crs, transform, always_xy, time)\nreproject(geometry, source_crs, target_crs; always_xy, time)\nreproject(geometry, transform; always_xy, time)\n\nReproject any GeoInterface.jl compatible geometry from source_crs to target_crs.\n\nThe returned object will be constructed from GeoInterface.WrapperGeometry geometries, wrapping views of a Vector{Proj.Point{D}}, where D is the dimension.\n\nArguments\n\ngeometry: Any GeoInterface.jl compatible geometries.\nsource_crs: the source coordinate referece system, as a GeoFormatTypes.jl object or a string.\ntarget_crs: the target coordinate referece system, as a GeoFormatTypes.jl object or a string.\n\nIf these a passed as keywords, transform will take priority. Without it target_crs is always needed, and source_crs is needed if it is not retreivable from the geometry with GeoInterface.crs(geometry).\n\nKeywords\n\n-always_xy: force x, y coordinate order, true by default.     false will expect and return points in the crs coordinate order. -time: the time for the coordinates. Inf by default.\n\n\n\n\n\n","category":"method"},{"location":"#GeometryOps.signed_area-Tuple{Any}","page":"Home","title":"GeometryOps.signed_area","text":"signed_area(geom)::Real\n\nReturns the signed area of the geometry, based on winding order.\n\n\n\n\n\n","category":"method"},{"location":"#GeometryOps.signed_distance-Tuple{Any, Any, Any}","page":"Home","title":"GeometryOps.signed_distance","text":"signed_distance(geom, x::Real, y::Real)::Float64\n\nCalculates the signed distance from the geometry geom to the point defined by (x, y).  Points within geom have a negative distance, and points outside of geom have a positive distance.\n\nIf geom is a MultiPolygon, then this function returns the maximum distance  to any of the polygons in geom.\n\n\n\n\n\n","category":"method"},{"location":"#GeometryOps.simplify-Tuple{Any}","page":"Home","title":"GeometryOps.simplify","text":"simplify(obj; kw...)\nsimplify(::SimplifyAlg, obj)\n\nSimplify a geometry, feature, feature collection,  or nested vectors or a table of these.\n\nRadialDistance, DouglasPeucker, or  VisvalingamWhyatt algorithms are available,  listed in order of increasing quality but decreaseing performance.\n\nPoinTrait and MultiPointTrait are returned unchanged.\n\nThe default behaviour is simplify(DouglasPeucker(; kw...), obj). Pass in other SimplifyAlg to use other algorithms.\n\nExample\n\nSimplify a polygon to have six points:\n\nimport GeoInterface as GI\nimport GeometryOps as GO\n\npoly = GI.Polygon([[\n    [-70.603637, -33.399918],\n    [-70.614624, -33.395332],\n    [-70.639343, -33.392466],\n    [-70.659942, -33.394759],\n    [-70.683975, -33.404504],\n    [-70.697021, -33.419406],\n    [-70.701141, -33.434306],\n    [-70.700454, -33.446339],\n    [-70.694274, -33.458369],\n    [-70.682601, -33.465816],\n    [-70.668869, -33.472117],\n    [-70.646209, -33.473835],\n    [-70.624923, -33.472117],\n    [-70.609817, -33.468107],\n    [-70.595397, -33.458369],\n    [-70.587158, -33.442901],\n    [-70.587158, -33.426283],\n    [-70.590591, -33.414248],\n    [-70.594711, -33.406224],\n    [-70.603637, -33.399918]]])\n\nsimple = GO.simplify(poly; number=6)\nGI.npoint(simple)\n\n# output\n6\n\n\n\n\n\n","category":"method"},{"location":"#GeometryOps.unwrap","page":"Home","title":"GeometryOps.unwrap","text":"unwrap(target::Type{<:AbstractTrait}, obj)\nunwrap(f, target::Type{<:AbstractTrait}, obj)\n\nUnwrap the geometry to vectors, down to the target trait.\n\nIf f is passed in it will be applied to the target geometries as they are found.\n\n\n\n\n\n","category":"function"}]
}
