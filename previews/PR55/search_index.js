var documenterSearchIndex = {"docs":
[{"location":"source/GeometryOps/#GeometryOps.jl","page":"GeometryOps.jl","title":"GeometryOps.jl","text":"","category":"section"},{"location":"source/GeometryOps/","page":"GeometryOps.jl","title":"GeometryOps.jl","text":"module GeometryOps\n\nusing GeoInterface\nusing GeometryBasics\nimport Proj\nusing LinearAlgebra\nimport ExactPredicates\nimport Proj.CoordinateTransformations.StaticArrays\nimport Base.@kwdef\n\nusing GeoInterface.Extents: Extents\n\nconst GI = GeoInterface\nconst GB = GeometryBasics\n\nconst TuplePoint = Tuple{Float64,Float64}\nconst Edge = Tuple{TuplePoint,TuplePoint}\n\ninclude(\"primitives.jl\")\ninclude(\"utils.jl\")\n\ninclude(\"methods/angles.jl\")\ninclude(\"methods/area.jl\")\ninclude(\"methods/barycentric.jl\")\ninclude(\"methods/bools.jl\")\ninclude(\"methods/centroid.jl\")\ninclude(\"methods/distance.jl\")\ninclude(\"methods/equals.jl\")\ninclude(\"methods/clipping/clipping_processor.jl\")\ninclude(\"methods/clipping/intersection.jl\")\ninclude(\"methods/clipping/difference.jl\")\ninclude(\"methods/clipping/union.jl\")\ninclude(\"methods/geom_relations/contains.jl\")\ninclude(\"methods/geom_relations/coveredby.jl\")\ninclude(\"methods/geom_relations/covers.jl\")\ninclude(\"methods/geom_relations/crosses.jl\")\ninclude(\"methods/geom_relations/disjoint.jl\")\ninclude(\"methods/geom_relations/geom_geom_processors.jl\")\ninclude(\"methods/geom_relations/intersects.jl\")\ninclude(\"methods/geom_relations/overlaps.jl\")\ninclude(\"methods/geom_relations/touches.jl\")\ninclude(\"methods/geom_relations/within.jl\")\ninclude(\"methods/polygonize.jl\")\n\ninclude(\"transformations/extent.jl\")\ninclude(\"transformations/flip.jl\")\ninclude(\"transformations/reproject.jl\")\ninclude(\"transformations/simplify.jl\")\ninclude(\"transformations/tuples.jl\")\ninclude(\"transformations/transform.jl\")\n\nend","category":"page"},{"location":"source/GeometryOps/","page":"GeometryOps.jl","title":"GeometryOps.jl","text":"","category":"page"},{"location":"source/GeometryOps/","page":"GeometryOps.jl","title":"GeometryOps.jl","text":"This page was generated using Literate.jl.","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"const THREADED_KEYWORD = \"- `threaded`: `true` or `false`. Whether to use multithreading. Defaults to `false`.\"\nconst CRS_KEYWORD = \"- `crs`: The CRS to attach to geometries. Defaults to `nothing`.\"\nconst CALC_EXTENT_KEYWORD = \"- `calc_extent`: `true` or `false`. Whether to calculate the extent. Defaults to `false`.\"\n\nconst APPLY_KEYWORDS = \"\"\"\n$THREADED_KEYWORD\n$CRS_KEYWORD\n$CALC_EXTENT_KEYWORD\n\"\"\"","category":"page"},{"location":"source/primitives/#Primitive-functions","page":"Primitive functions","title":"Primitive functions","text":"","category":"section"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"This file mainly defines the apply function.","category":"page"},{"location":"source/primitives/#What-is-apply?","page":"Primitive functions","title":"What is apply?","text":"","category":"section"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"apply applies some function to every geometry matching the Target GeoInterface trait, in some arbitrarily nested object made up of:","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"AbstractArrays (we also try to iterate other non-GeoInteface compatible object)\nFeatureCollectionTrait objects\nFeatureTrait objects\nAbstractGeometryTrait objects","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"apply recursively calls itself through these nested layers until it reaches objects with the Target GeoInterface trait. When found apply applies the function f, and stops.","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"The outer recursive functions then progressively rebuild the object using GeoInterface objects matching the original traits.","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"If PointTrait is found  but it is not the Target, an error is thrown. This likely means the object contains a different geometry trait to the target, such as MultiPointTrait when LineStringTrait was specified.","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"To handle this possibility it may be necessary to make Target a Union of traits found at the same level of nesting, and define methods of f to handle all cases.","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Be careful making a union across \"levels\" of nesting, e.g. Union{FeatureTrait,PolygonTrait}, as _apply will just never reach PolygonTrait when all the polygons are wrapped in a FeatureTrait object.","category":"page"},{"location":"source/primitives/#Embedding:","page":"Primitive functions","title":"Embedding:","text":"","category":"section"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"extent and crs can be embedded in all geometries, features, and feature collections as part of apply. Geometries deeper than Target will of course not have new extent or crs embedded.","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"calc_extent signals to recalculate an Extent and embed it.\ncrs will be embedded as-is","category":"page"},{"location":"source/primitives/#Threading","page":"Primitive functions","title":"Threading","text":"","category":"section"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Threading is used at the outermost level possible - over an array, feature collection, or e.g. a MultiPolygonTrait where each PolygonTrait sub-geometry may be calculated on a different thread.","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Currently, threading defaults to false for all objects, but can be turned on by passing the keyword argument threaded=true to apply.","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"\"\"\"\n    apply(f, target::Type{<:AbstractTrait}, obj; kw...)\n\nReconstruct a geometry, feature, feature collection, or nested vectors of\neither using the function `f` on the `target` trait.\n\n`f(target_geom) => x` where `x` also has the `target` trait, or a trait that can\nbe substituted. For example, swapping `PolgonTrait` to `MultiPointTrait` will fail\nif the outer object has `MultiPolygonTrait`, but should work if it has `FeatureTrait`.\n\nObjects \"shallower\" than the target trait are always completely rebuilt, like\na `Vector` of `FeatureCollectionTrait` of `FeatureTrait` when the target\nhas `PolygonTrait` and is held in the features. But \"deeper\" objects may remain\nunchanged - such as points and linear rings if the target is the same `PolygonTrait`.\n\nThe result is a functionally similar geometry with values depending on `f`\n\n$APPLY_KEYWORDS","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Example","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Flipped point the order in any feature or geometry, or iterables of either:\n\n```julia\nimport GeoInterface as GI\nimport GeometryOps as GO\ngeom = GI.Polygon([GI.LinearRing([(1, 2), (3, 4), (5, 6), (1, 2)]),\n                   GI.LinearRing([(3, 4), (5, 6), (6, 7), (3, 4)])])\n\nflipped_geom = GO.apply(GI.PointTrait, geom) do p\n    (GI.y(p), GI.x(p))\nend\n\"\"\"\napply(f, ::Type{Target}, geom; kw...) where Target = _apply(f, Target, geom; kw...)","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Call _apply again with the trait of geom","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"_apply(f, ::Type{Target}, geom; kw...)  where Target =\n    _apply(f, Target, GI.trait(geom), geom; kw...)","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"There is no trait and this is an AbstractArray - so just iterate over it calling _apply on the contents","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"function _apply(f, ::Type{Target}, ::Nothing, A::AbstractArray; threaded=false, kw...) where Target","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"For an Array there is nothing else to do but map _apply over all values maptasks may run this level threaded if threaded==true, but deeper `apply` called in the closure will not be threaded","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"    _maptasks(eachindex(A); threaded) do i\n        _apply(f, Target, A[i]; threaded=false, kw...)\n    end\nend","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"There is no trait and this is not an AbstractArray. Try to call _apply over it. We can't use threading as we don't know if we can can index into it. So just map.","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"function _apply(f, ::Type{Target}, ::Nothing, iterable; threaded=false, kw...) where Target\n    if threaded","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"collect first so we can use threads","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"        _apply(f, Target, collect(iterable); threaded, kw...)\n    else\n        map(x -> _apply(f, Target, x; kw...), iterable)\n    end\nend","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Rewrap all FeatureCollectionTrait feature collections as GI.FeatureCollection Maybe use threads to call _apply on componenet features","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"function _apply(f, ::Type{Target}, ::GI.FeatureCollectionTrait, fc;\n    crs=GI.crs(fc), calc_extent=false, threaded=false\n) where Target","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Run _apply on all features in the feature collection, possibly threaded","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"    features = _maptasks(1:GI.nfeature(fc); threaded) do i\n        feature = GI.getfeature(fc, i)\n        _apply(f, Target, feature; crs, calc_extent, threaded=false)::GI.Feature\n    end\n    if calc_extent","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Calculate the extent of the features","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"        extent = mapreduce(GI.extent, Extents.union, features)","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Return a FeatureCollection with features, crs and caculated extent","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"        return GI.FeatureCollection(features; crs, extent)\n    else","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Return a FeatureCollection with features and crs","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"        return GI.FeatureCollection(features; crs)\n    end\nend","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Rewrap all FeatureTrait features as GI.Feature, keeping the properties","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"function _apply(f, ::Type{Target}, ::GI.FeatureTrait, feature;\n    crs=GI.crs(feature), calc_extent=false, threaded=false\n) where Target","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Run _apply on the contained geometry","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"    geometry = _apply(f, Target, GI.geometry(feature); crs, calc_extent, threaded)","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Get the feature properties","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"    properties = GI.properties(feature)\n    if calc_extent","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Calculate the extent of the geometry","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"        extent = GI.extent(geometry)","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Return a new Feature with the new geometry and calculated extent, but the oroginal properties and crs","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"        return GI.Feature(geometry; properties, crs, extent)\n    else","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Return a new Feature with the new geometry, but the oroginal properties and crs","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"        return GI.Feature(geometry; properties, crs)\n    end\nend","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Reconstruct nested geometries, maybe using threads to call _apply on component geoms","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"function _apply(f, ::Type{Target}, trait, geom;\n    crs=GI.crs(geom), calc_extent=false, threaded=false\n)::(GI.geointerface_geomtype(trait)) where Target","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Map _apply over all sub geometries of geom to create a new vector of geometries TODO handle zero length","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"    geoms = _maptasks(1:GI.ngeom(geom); threaded) do i\n        _apply(f, Target, GI.getgeom(geom, i); crs, calc_extent, threaded=false)\n    end\n    if calc_extent","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Calculate the extent of the sub geometries","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"        extent = mapreduce(GI.extent, Extents.union, geoms)","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Return a new geometry of the same trait as geom, holding tnew geoms with crs and calcualted extent","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"        return rebuild(geom, geoms; crs, extent)\n    else","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Return a new geometryof the same trait as geom, holding the new geoms with crs","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"        return rebuild(geom, geoms; crs)\n    end\nend","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Fail loudly if we hit PointTrait without running f (after PointTrait there is no further to dig with _apply)","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"_apply(f, ::Type{Target}, trait::GI.PointTrait, geom; crs=nothing, kw...) where Target =\n    throw(ArgumentError(\"target $Target not found, but reached a `PointTrait` leaf\"))","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Finally, these short methods are the main purpose of apply. The Trait is a subtype of the Target (or identical to it) So the Target is found. We apply f to geom and return it to previous _apply calls to be wrapped with the outer geometries/feature/featurecollection/array.","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"_apply(f, ::Type{Target}, ::Trait, geom; crs=GI.crs(geom), kw...) where {Target,Trait<:Target} = f(geom)","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Define some specific cases of this match to avoid method ambiguity","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"for T in (\n    GI.PointTrait, GI.LinearRing, GI.LineString,\n    GI.MultiPoint, GI.FeatureTrait, GI.FeatureCollectionTrait\n)\n    @eval _apply(f, target::Type{$T}, trait::$T, x; kw...) = f(x)\nend\n\n\"\"\"\n    applyreduce(f, op, target::Type{<:AbstractTrait}, obj; threaded)\n\nApply function `f` to all objects with the `target` trait,\nand reduce the result with an `op` like `+`.\n\nThe order and grouping of application of `op` is not guaranteed.\n\nIf `threaded==true` threads will be used over arrays and iterables,\nfeature collections and nested geometries.\n\"\"\"\nfunction applyreduce end","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Add dispatch argument for trait","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"applyreduce(f, op, target::Type, geom; threaded=false, init=nothing) =\n    _applyreduce(f, op, target, geom; threaded, init)\n\n_applyreduce(f, op, target, geom; threaded, init) =\n    _applyreduce(f, op, target, GI.trait(geom), geom; threaded, init)","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Maybe use threads recucing over arrays","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"function _applyreduce(f, op, target::Type, ::Nothing, A::AbstractArray; threaded, init)\n    _mapreducetasks(op, eachindex(A); threaded, init) do i\n        _applyreduce(f, op, target, A[i]; threaded=false, init)\n    end\nend","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Try to applyreduce over iterables","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"function _applyreduce(f, op, target::Type, ::Nothing, iterable; threaded, init)\n    if threaded # Try to `collect` and reduce over the vector with threads\n        _applyreduce(f, op, target, collect(iterable); threaded, init)\n    else","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Try to mapreduce the iterable as-is","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"        mapreduce(op, iterable; init) do x\n            _applyreduce(f, op, target, x; threaded=false, init)\n        end\n    end\nend","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Maybe use threads reducing over features of feature collections","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"function _applyreduce(f, op, target::Type, ::GI.FeatureCollectionTrait, fc; threaded, init)\n    _mapreducetasks(op, 1:GI.nfeature(fc); threaded, init) do i\n        _applyreduce(f, op, target, GI.getfeature(fc, i); threaded=false, init)\n    end\nend","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Features just applyreduce to their geometry","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"_applyreduce(f, op, target::Type, ::GI.FeatureTrait, feature; threaded, init) =\n    _applyreduce(f, op, target, GI.geometry(feature); threaded, init)","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Maybe use threads over components of nested geometries","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"function _applyreduce(f, op, target::Type, trait, geom; threaded, init)\n    _mapreducetasks(op, 1:GI.ngeom(geom); threaded, init) do i\n        _applyreduce(f, op, target, GI.getgeom(geom, i); threaded=false, init)\n    end\nend","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Don't thread over points it won't pay off","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"function _applyreduce(\n    f, op, target::Type, trait::Union{GI.LinearRing,GI.LineString,GI.MultiPoint}, geom;\n    threaded, init\n)\n    _applyreduce(f, op, target, GI.getgeom(geom); threaded=false, init)\nend","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Apply f to the target","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"function _applyreduce(f, op, ::Type{Target}, ::Trait, x; kw...) where {Target<:GI.AbstractTrait,Trait<:Target}\n    f(x)\nend","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Fail if we hit PointTrait","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"_applyreduce(f, op, target, trait, geom; kw...) = throw(ArgumentError(\"target $target not found\"))","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Specific cases to avoid method ambiguity","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"for T in (\n    GI.PointTrait, GI.LinearRing, GI.LineString,\n    GI.MultiPoint, GI.FeatureTrait, GI.FeatureCollectionTrait\n)\n    @eval _applyreduce(f, op, target::Type{$T}, trait::$T, x; kw...) = f(x)\nend\n\n\"\"\"\n    unwrap(target::Type{<:AbstractTrait}, obj)\n    unwrap(f, target::Type{<:AbstractTrait}, obj)\n\nUnwrap the object to vectors, down to the target trait.\n\nIf `f` is passed in it will be applied to the target geometries\nas they are found.\n\"\"\"\nfunction unwrap end\nunwrap(target::Type, geom) = unwrap(identity, target, geom)","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Add dispatch argument for trait","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"unwrap(f, target::Type, geom) = unwrap(f, target, GI.trait(geom), geom)","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Try to unwrap over iterables","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"unwrap(f, target::Type, ::Nothing, iterable) =\n    map(x -> unwrap(f, target, x), iterable)","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Rewrap feature collections","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"unwrap(f, target::Type, ::GI.FeatureCollectionTrait, fc) =\n    map(x -> unwrap(f, target, x), GI.getfeature(fc))\nunwrap(f, target::Type, ::GI.FeatureTrait, feature) =\n    unwrap(f, target, GI.geometry(feature))\nunwrap(f, target::Type, trait, geom) = map(g -> unwrap(f, target, g), GI.getgeom(geom))","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Apply f to the target geometry","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"unwrap(f, ::Type{Target}, ::Trait, geom) where {Target,Trait<:Target} = f(geom)","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Fail if we hit PointTrait","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"unwrap(f, target::Type, trait::GI.PointTrait, geom) =\n    throw(ArgumentError(\"target $target not found, but reached a `PointTrait` leaf\"))","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Specific cases to avoid method ambiguity","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"unwrap(f, target::Type{GI.PointTrait}, trait::GI.PointTrait, geom) = f(geom)\nunwrap(f, target::Type{GI.FeatureTrait}, ::GI.FeatureTrait, feature) = f(feature)\nunwrap(f, target::Type{GI.FeatureCollectionTrait}, ::GI.FeatureCollectionTrait, fc) = f(fc)\n\n\"\"\"\n    flatten(target::Type{<:GI.AbstractTrait}, obj)\n    flatten(f, target::Type{<:GI.AbstractTrait}, obj)\n\nLazily flatten any `AbstractArray`, iterator, `FeatureCollectionTrait`,\n`FeatureTrait` or `AbstractGeometryTrait` object `obj`, so that objects\nwith the `target` trait are returned by the iterator.\n\nIf `f` is passed in it will be applied to the target geometries.\n\"\"\"\nflatten(::Type{Target}, geom) where {Target<:GI.AbstractTrait} = flatten(identity, Target, geom)\nflatten(f, ::Type{Target}, geom) where {Target<:GI.AbstractTrait} = _flatten(f, Target, geom)\n\n_flatten(f, ::Type{Target}, geom) where Target = _flatten(f, Target, GI.trait(geom), geom)","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Try to flatten over iterables","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"_flatten(f, ::Type{Target}, ::Nothing, iterable) where Target =\n    Iterators.flatten(Iterators.map(x -> _flatten(f, Target, x), iterable))","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Flatten feature collections","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"function _flatten(f, ::Type{Target}, ::GI.FeatureCollectionTrait, fc) where Target\n    Iterators.map(GI.getfeature(fc)) do feature\n        _flatten(f, Target, feature)\n    end |> Iterators.flatten\nend\n_flatten(f, ::Type{Target}, ::GI.FeatureTrait, feature) where Target =\n    _flatten(f, Target, GI.geometry(feature))","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Apply f to the target geometry","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"_flatten(f, ::Type{Target}, ::Trait, geom) where {Target,Trait<:Target} = (f(geom),)\n_flatten(f, ::Type{Target}, trait, geom) where Target =\n    Iterators.flatten(Iterators.map(g -> _flatten(f, Target, g), GI.getgeom(geom)))","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Fail if we hit PointTrait without running f","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"_flatten(f, ::Type{Target}, trait::GI.PointTrait, geom) where Target =\n    throw(ArgumentError(\"target $Target not found, but reached a `PointTrait` leaf\"))","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Specific cases to avoid method ambiguity","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"_flatten(f, ::Type{<:GI.PointTrait}, ::GI.PointTrait, geom) = (f(geom),)\n_flatten(f, ::Type{<:GI.FeatureTrait}, ::GI.FeatureTrait, feature) = (f(feature),)\n_flatten(f, ::Type{<:GI.FeatureCollectionTrait}, ::GI.FeatureCollectionTrait, fc) = (f(fc),)\n\n\n\"\"\"\n    reconstruct(geom, components)\n\nReconstruct `geom` from an iterable of component objects that match its structure.\n\nAll objects in `components` must have the same `GeoInterface.trait`.\n\nUsusally used in combination with `flatten`.\n\"\"\"\nfunction reconstruct(geom, components)\n    obj, iter = _reconstruct(geom, components)\n    return obj\nend\n\n_reconstruct(geom, components) =\n    _reconstruct(typeof(GI.trait(first(components))), geom, components, 1)\n_reconstruct(::Type{Target}, geom, components, iter) where Target =\n    _reconstruct(Target, GI.trait(geom), geom, components, iter)","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Try to reconstruct over iterables","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"function _reconstruct(::Type{Target}, ::Nothing, iterable, components, iter) where Target\n    vect = map(iterable) do x","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"iter is updated by _reconstruct here","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"        obj, iter = _reconstruct(Target, x, components, iter)\n        obj\n    end\n    return vect, iter\nend","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Reconstruct feature collections","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"function _reconstruct(::Type{Target}, ::GI.FeatureCollectionTrait, fc, components, iter) where Target\n    features = map(GI.getfeature(fc)) do feature","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"iter is updated by _reconstruct here","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"        newfeature, iter = _reconstruct(Target, feature, components, iter)\n        newfeature\n    end\n    return GI.FeatureCollection(features; crs=GI.crs(fc)), iter\nend\nfunction _reconstruct(::Type{Target}, ::GI.FeatureTrait, feature, components, iter) where Target\n    geom, iter = _reconstruct(Target, GI.geometry(feature), components, iter)\n    return GI.Feature(geom; properties=GI.properties(feature), crs=GI.crs(feature)), iter\nend\nfunction _reconstruct(::Type{Target}, trait, geom, components, iter) where Target\n    geoms = map(GI.getgeom(geom)) do subgeom","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"iter is updated by _reconstruct here","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"        subgeom1, iter = _reconstruct(Target, GI.trait(subgeom), subgeom, components, iter)\n        subgeom1\n    end\n    return rebuild(geom, geoms), iter\nend","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Apply f to the target geometry","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"_reconstruct(::Type{Target}, ::Trait, geom, components, iter) where {Target,Trait<:Target} =\n    iterate(components, iter)","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Specific cases to avoid method ambiguity","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"_reconstruct(::Type{<:GI.PointTrait}, ::GI.PointTrait, geom, components, iter) = iterate(components, iter)\n_reconstruct(::Type{<:GI.FeatureTrait}, ::GI.FeatureTrait, feature, components, iter) = iterate(feature, iter)\n_reconstruct(::Type{<:GI.FeatureCollectionTrait}, ::GI.FeatureCollectionTrait, fc, components, iter) = iterate(fc, iter)","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Fail if we hit PointTrait without running f","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"_reconstruct(::Type{Target}, trait::GI.PointTrait, geom, components, iter) where Target =\n    throw(ArgumentError(\"target $Target not found, but reached a `PointTrait` leaf\"))\n\n\nconst BasicsGeoms = Union{GB.AbstractGeometry,GB.AbstractFace,GB.AbstractPoint,GB.AbstractMesh,\n    GB.AbstractPolygon,GB.LineString,GB.MultiPoint,GB.MultiLineString,GB.MultiPolygon,GB.Mesh}\n\n\"\"\"\n    rebuild(geom, child_geoms)\n\nRebuild a geometry from child geometries.\n\nBy default geometries will be rebuilt as a `GeoInterface.Wrappers`\ngeometry, but `rebuild` can have methods added to it to dispatch\non geometries from other packages and specify how to rebuild them.\n\n(Maybe it should go into GeoInterface.jl)\n\"\"\"\nrebuild(geom, child_geoms; kw...) = rebuild(GI.trait(geom), geom, child_geoms; kw...)\nfunction rebuild(trait::GI.AbstractTrait, geom, child_geoms; crs=GI.crs(geom), extent=nothing)\n    T = GI.geointerface_geomtype(trait)\n    if GI.is3d(geom)","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"The Boolean type parameters here indicate 3d-ness and measure coordinate presence respectively.","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"        return T{true,false}(child_geoms; crs, extent)\n    else\n        return T{false,false}(child_geoms; crs, extent)\n    end\nend","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"So that GeometryBasics geoms rebuild as themselves","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"function rebuild(trait::GI.AbstractTrait, geom::BasicsGeoms, child_geoms; crs=nothing)\n    GB.geointerface_geomtype(trait)(child_geoms)\nend\nfunction rebuild(trait::GI.AbstractTrait, geom::Union{GB.LineString,GB.MultiPoint}, child_geoms; crs=nothing)\n    GB.geointerface_geomtype(trait)(GI.convert.(GB.Point, child_geoms))\nend\nfunction rebuild(trait::GI.PolygonTrait, geom::GB.Polygon, child_geoms; crs=nothing)\n    Polygon(child_geoms[1], child_geoms[2:end])\nend\n\nusing Base.Threads: nthreads, @threads, @spawn","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Threading utility, modified Mason Protters threading PSA run f over ntasks, where f recieves an AbstractArray/range of linear indices","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"function _maptasks(f, taskrange; threaded=false)\n    if threaded\n        ntasks = length(taskrange)","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Customize this as needed. More tasks have more overhead, but better load balancing","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"        tasks_per_thread = 2\n        chunk_size = max(1, ntasks ÷ (tasks_per_thread * nthreads()))","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"partition the range into chunks","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"        task_chunks = Iterators.partition(taskrange, chunk_size)","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Map over the chunks","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"        tasks = map(task_chunks) do chunk","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Spawn a task to process this chunk","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"            @spawn begin","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Where we map f over the chunk indices","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"                map(f, chunk)\n            end\n        end","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Finally we join the results into a new vector","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"        return mapreduce(fetch, vcat, tasks)\n    else\n        return map(f, taskrange)\n    end\nend","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Threading utility, modified Mason Protters threading PSA run f over ntasks, where f recieves an AbstractArray/range of linear indices","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"WARNING: this will not work for mean/median - only ops where grouping is possible","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"function _mapreducetasks(f, op, taskrange; threaded=false, init)\n    if threaded\n        ntasks = length(taskrange)","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Customize this as needed. More tasks have more overhead, but better load balancing","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"        tasks_per_thread = 2\n        chunk_size = max(1, ntasks ÷ (tasks_per_thread * nthreads()))","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"partition the range into chunks","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"        task_chunks = Iterators.partition(taskrange, chunk_size)","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Map over the chunks","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"        tasks = map(task_chunks) do chunk","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Spawn a task to process this chunk","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"            @spawn begin","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Where we map f over the chunk indices","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"                mapreduce(f, op, chunk; init)\n            end\n        end","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"Finally we join the results into a new vector","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"        return mapreduce(fetch, op, tasks; init)\n    else\n        return mapreduce(f, op, taskrange; init)\n    end\nend","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"","category":"page"},{"location":"source/primitives/","page":"Primitive functions","title":"Primitive functions","text":"This page was generated using Literate.jl.","category":"page"},{"location":"source/methods/polygonize/#Polygonizing-raster-data","page":"Polygonizing raster data","title":"Polygonizing raster data","text":"","category":"section"},{"location":"source/methods/polygonize/","page":"Polygonizing raster data","title":"Polygonizing raster data","text":"export polygonize","category":"page"},{"location":"source/methods/polygonize/","page":"Polygonizing raster data","title":"Polygonizing raster data","text":"The methods in this file are able to convert a raster image into a set of polygons, by contour detection using a clockwise Moore neighborhood method.","category":"page"},{"location":"source/methods/polygonize/","page":"Polygonizing raster data","title":"Polygonizing raster data","text":"The main entry point is the polygonize function.","category":"page"},{"location":"source/methods/polygonize/","page":"Polygonizing raster data","title":"Polygonizing raster data","text":"polygonize","category":"page"},{"location":"source/methods/polygonize/#Example","page":"Polygonizing raster data","title":"Example","text":"","category":"section"},{"location":"source/methods/polygonize/","page":"Polygonizing raster data","title":"Polygonizing raster data","text":"Here's a basic example, using the Makie.peaks() function.  First, let's investigate the nature of the function:","category":"page"},{"location":"source/methods/polygonize/","page":"Polygonizing raster data","title":"Polygonizing raster data","text":"using Makie, GeometryOps\nn = 49\nxs, ys = LinRange(-3, 3, n), LinRange(-3, 3, n)\nzs = Makie.peaks(n)\nz_max_value = maximum(abs.(extrema(zs)))\nf, a, p = heatmap(\n    xs, ys, zs;\n    axis = (; aspect = DataAspect(), title = \"Exact function\")\n)\ncb = Colorbar(f[1, 2], p; label = \"Z-value\")\nf","category":"page"},{"location":"source/methods/polygonize/","page":"Polygonizing raster data","title":"Polygonizing raster data","text":"Now, we can use the polygonize function to convert the raster data into polygons.","category":"page"},{"location":"source/methods/polygonize/","page":"Polygonizing raster data","title":"Polygonizing raster data","text":"For this particular example, we chose a range of z-values between 0.8 and 3.2, which would provide two distinct polyogns with holes.","category":"page"},{"location":"source/methods/polygonize/","page":"Polygonizing raster data","title":"Polygonizing raster data","text":"polygons = polygonize(xs, ys, 0.8 .< zs .< 3.2)","category":"page"},{"location":"source/methods/polygonize/","page":"Polygonizing raster data","title":"Polygonizing raster data","text":"This returns a list of GeometryBasics.Polygon, which can be plotted immediately, or wrapped directly in a GeometryBasics.MultiPolygon.  Let's see how these look:","category":"page"},{"location":"source/methods/polygonize/","page":"Polygonizing raster data","title":"Polygonizing raster data","text":"f, a, p = poly(polygons; label = \"Polygonized polygons\", axis = (; aspect = DataAspect()))","category":"page"},{"location":"source/methods/polygonize/","page":"Polygonizing raster data","title":"Polygonizing raster data","text":"Finally, let's plot the Makie contour lines on top, to see how well the polygonization worked:","category":"page"},{"location":"source/methods/polygonize/","page":"Polygonizing raster data","title":"Polygonizing raster data","text":"contour!(a, zs; labels = true, levels = [0.8, 3.2], label = \"Contour lines\")\nf","category":"page"},{"location":"source/methods/polygonize/#Implementation","page":"Polygonizing raster data","title":"Implementation","text":"","category":"section"},{"location":"source/methods/polygonize/","page":"Polygonizing raster data","title":"Polygonizing raster data","text":"The implementation follows:","category":"page"},{"location":"source/methods/polygonize/","page":"Polygonizing raster data","title":"Polygonizing raster data","text":"\"\"\"\n    polygonize(A; minpoints=10)\n    polygonize(xs, ys, A; minpoints=10)\n\nConvert matrix `A` to polygons.\n\nIf `xs` and `ys` are passed in they are used as the pixel center points.","category":"page"},{"location":"source/methods/polygonize/","page":"Polygonizing raster data","title":"Polygonizing raster data","text":"Keywords","category":"page"},{"location":"source/methods/polygonize/","page":"Polygonizing raster data","title":"Polygonizing raster data","text":"- `minpoints`: ignore polygons with less than `minpoints` points.\n\"\"\"\npolygonize(A::AbstractMatrix; kw...) = polygonize(axes(A)..., A; kw...)\n\nfunction polygonize(xs, ys, A::AbstractMatrix; minpoints=10)\n    # This function uses a lazy map to get contours.\n    contours = Iterators.map(get_contours(A)) do contour\n        poly = map(contour) do xy\n            x, y = Tuple(xy)\n            Point2f(x + first(xs) - 1, y + first(ys) - 1)\n        end\n    end\n    # If we filter off the minimum points, then it's a hair more efficient\n    # not to convert contours with length < missingpoints to polygons.\n    if minpoints > 1\n        contours = Iterators.filter(contours) do contour\n            length(contour) > minpoints\n        end\n       return map(Polygon, contours)\n    else\n        return map(Polygon, contours)\n    end\nend\n\n# rotate direction clockwise\nrot_clockwise(dir) = (dir) % 8 + 1\n# rotate direction counterclockwise\nrot_counterclockwise(dir) = (dir + 6) % 8 + 1\n\n# move from current pixel to next in given direction\nfunction move(pixel, image, dir, dir_delta)\n    newp = pixel + dir_delta[dir]\n    height, width = size(image)\n    if (0 < newp[1] <= height) && (0 < newp[2] <= width)\n        if image[newp] != 0\n            return newp\n        end\n    end\n    return CartesianIndex(0, 0)\nend\n\n# finds direction between two given pixels\nfunction from_to(from, to, dir_delta)\n    delta = to - from\n    return findall(x -> x == delta, dir_delta)[1]\nend\n\nfunction detect_move(image, p0, p2, nbd, border, done, dir_delta)\n    dir = from_to(p0, p2, dir_delta)\n    moved = rot_clockwise(dir)\n    p1 = CartesianIndex(0, 0)\n    while moved != dir ## 3.1\n        newp = move(p0, image, moved, dir_delta)\n        if newp[1] != 0\n            p1 = newp\n            break\n        end\n        moved = rot_clockwise(moved)\n    end\n\n    if p1 == CartesianIndex(0, 0)\n        return\n    end\n\n    p2 = p1 ## 3.2\n    p3 = p0 ## 3.2\n    done .= false\n    while true\n        dir = from_to(p3, p2, dir_delta)\n        moved = rot_counterclockwise(dir)\n        p4 = CartesianIndex(0, 0)\n        done .= false\n        while true ## 3.3\n            p4 = move(p3, image, moved, dir_delta)\n            if p4[1] != 0\n                break\n            end\n            done[moved] = true\n            moved = rot_counterclockwise(moved)\n        end\n        push!(border, p3) ## 3.4\n        if p3[1] == size(image, 1) || done[3]\n            image[p3] = -nbd\n        elseif image[p3] == 1\n            image[p3] = nbd\n        end\n\n        if (p4 == p0 && p3 == p1) ## 3.5\n            break\n        end\n        p2 = p3\n        p3 = p4\n    end\nend\n\n\"\"\"\n   get_contours(A::AbstractMatrix)\n\nReturns contours as vectors of `CartesianIndex`.\n\"\"\"\nfunction get_contours(image::AbstractMatrix)\n    nbd = 1\n    lnbd = 1\n    image = Float64.(image)\n    contour_list = Vector{typeof(CartesianIndex[])}()\n    done = [false, false, false, false, false, false, false, false]\n\n    # Clockwise Moore neighborhood.\n    dir_delta = (CartesianIndex(-1, 0), CartesianIndex(-1, 1), CartesianIndex(0, 1), CartesianIndex(1, 1),\n                 CartesianIndex(1, 0), CartesianIndex(1, -1), CartesianIndex(0, -1), CartesianIndex(-1, -1))\n\n    height, width = size(image)\n\n    for i = 1:height\n        lnbd = 1\n        for j = 1:width\n            fji = image[i, j]\n            is_outer = (image[i, j] == 1 && (j == 1 || image[i, j-1] == 0)) ## 1 (a)\n            is_hole = (image[i, j] >= 1 && (j == width || image[i, j+1] == 0))\n\n            if is_outer || is_hole\n                # 2\n                border = CartesianIndex[]\n                from = CartesianIndex(i, j)\n\n                if is_outer\n                    nbd += 1\n                    from -= CartesianIndex(0, 1)\n\n                else\n                    nbd += 1\n                    if fji > 1\n                        lnbd = fji\n                    end\n                    from += CartesianIndex(0, 1)\n                end\n\n                p0 = CartesianIndex(i, j)\n                detect_move(image, p0, from, nbd, border, done, dir_delta) ## 3\n                if isempty(border) ##TODO\n                    push!(border, p0)\n                    image[p0] = -nbd\n                end\n                push!(contour_list, border)\n            end\n            if fji != 0 && fji != 1\n                lnbd = abs(fji)\n            end\n\n        end\n    end\n\n    return contour_list\nend","category":"page"},{"location":"source/methods/polygonize/","page":"Polygonizing raster data","title":"Polygonizing raster data","text":"","category":"page"},{"location":"source/methods/polygonize/","page":"Polygonizing raster data","title":"Polygonizing raster data","text":"This page was generated using Literate.jl.","category":"page"},{"location":"source/methods/clipping/union/#Union-Polygon-Clipping","page":"Union Polygon Clipping","title":"Union Polygon Clipping","text":"","category":"section"},{"location":"source/methods/clipping/union/","page":"Union Polygon Clipping","title":"Union Polygon Clipping","text":"export union\n\n\"\"\"\n    union(geom_a, geom_b, [::Type{T}]; target::Type)\n\nReturn the union between two geometries as a list of geometries. Return an empty list if\nnone are found. The type of the list will be constrained as much as possible given the input\ngeometries. Furthermore, the user can provide a `taget` type as a keyword argument and a\nlist of target geometries found in the difference will be returned. The user can also\nprovide a float type 'T' that they would like the points of returned geometries to be.\n\nCalculates the union between two polygons.\n# Example\n\n```jldoctest\nimport GeoInterface as GI, GeometryOps as GO\n\np1 = GI.Polygon([[(0.0, 0.0), (5.0, 5.0), (10.0, 0.0), (5.0, -5.0), (0.0, 0.0)]])\np2 = GI.Polygon([[(3.0, 0.0), (8.0, 5.0), (13.0, 0.0), (8.0, -5.0), (3.0, 0.0)]])\nunion_poly = GO.union(p1, p2; target = GI.PolygonTrait)\nGI.coordinates.(union_poly)","category":"page"},{"location":"source/methods/clipping/union/","page":"Union Polygon Clipping","title":"Union Polygon Clipping","text":"output","category":"page"},{"location":"source/methods/clipping/union/","page":"Union Polygon Clipping","title":"Union Polygon Clipping","text":"1-element Vector{Vector{Vector{Vector{Float64}}}}:\n [[[6.5, 3.5], [5.0, 5.0], [0.0, 0.0], [5.0, -5.0], [6.5, -3.5], [8.0, -5.0], [13.0, 0.0], [8.0, 5.0], [6.5, 3.5]]]\n```\n\"\"\"\nfunction union(\n    geom_a, geom_b, ::Type{T} = Float64; target::Type{Target} = Nothing,\n) where {T <: AbstractFloat, Target <: GI.AbstractTrait}\n    _union(Target, T, GI.trait(geom_a), geom_a, GI.trait(geom_b), geom_b)\nend\n\n#= This 'union' implementation returns the union of two polygons. The algorithm to determine\nthe union was adapted from \"Efficient clipping of efficient polygons,\" by Greiner and\nHormann (1998). DOI: https://doi.org/10.1145/274363.274364 =#\nfunction _union(\n    ::Type{GI.PolygonTrait}, ::Type{T},\n    ::GI.PolygonTrait, poly_a,\n    ::GI.PolygonTrait, poly_b,\n) where T","category":"page"},{"location":"source/methods/clipping/union/","page":"Union Polygon Clipping","title":"Union Polygon Clipping","text":"First, I get the exteriors of the two polygons","category":"page"},{"location":"source/methods/clipping/union/","page":"Union Polygon Clipping","title":"Union Polygon Clipping","text":"    ext_poly_a = GI.getexterior(poly_a)\n    ext_poly_b = GI.getexterior(poly_b)","category":"page"},{"location":"source/methods/clipping/union/","page":"Union Polygon Clipping","title":"Union Polygon Clipping","text":"Then, I get the union of the exteriors","category":"page"},{"location":"source/methods/clipping/union/","page":"Union Polygon Clipping","title":"Union Polygon Clipping","text":"    a_list, b_list, a_idx_list = _build_ab_list(T, ext_poly_a, ext_poly_b)\n    polys = _trace_polynodes(T, a_list, b_list, a_idx_list, (x, y) -> x ? (-1) : 1)","category":"page"},{"location":"source/methods/clipping/union/","page":"Union Polygon Clipping","title":"Union Polygon Clipping","text":"Check if one polygon totally within other and if so, return the larger polygon.","category":"page"},{"location":"source/methods/clipping/union/","page":"Union Polygon Clipping","title":"Union Polygon Clipping","text":"    if isempty(polys)\n        if _point_filled_curve_orientation(a_list[1].point, ext_poly_b) == point_in\n            push!(polys, GI.Polygon([ext_poly_b]))\n        elseif _point_filled_curve_orientation(b_list[1].point, ext_poly_a) == point_in\n            push!(polys,  GI.Polygon([ext_poly_a]))\n        else\n            push!(polys, poly_a)\n            push!(polys, poly_b)\n            return polys\n        end\n    else\n        sort!(polys, by = area, rev = true)\n        polys = [GI.Polygon([GI.getexterior(p) for p in polys])]\n    end\n\n    n_b_holes = GI.nhole(poly_b)\n    if GI.nhole(poly_a) != 0 || n_b_holes != 0\n        new_poly = [GI.getexterior(polys[1]); collect(GI.gethole(polys[1]))]\n        current_poly = GI.Polygon([ext_poly_b])\n        for (i, hole) in enumerate(Iterators.flatten((GI.gethole(poly_a), GI.gethole(poly_b))))","category":"page"},{"location":"source/methods/clipping/union/","page":"Union Polygon Clipping","title":"Union Polygon Clipping","text":"Use extpolyb to not overcount overlapping holes in polya and in polyb","category":"page"},{"location":"source/methods/clipping/union/","page":"Union Polygon Clipping","title":"Union Polygon Clipping","text":"            new_hole = difference(GI.Polygon([hole]), current_poly, T; target = GI.PolygonTrait)\n            for h in new_hole\n                push!(new_poly, GI.getexterior(h))\n            end\n            if i == n_b_holes\n                current_poly = poly_a\n            end\n        end\n        polys[1] = GI.Polygon(new_poly)\n    end\n    return polys\nend","category":"page"},{"location":"source/methods/clipping/union/","page":"Union Polygon Clipping","title":"Union Polygon Clipping","text":"Many type and target combos aren't implemented","category":"page"},{"location":"source/methods/clipping/union/","page":"Union Polygon Clipping","title":"Union Polygon Clipping","text":"function _union(\n    ::Type{Target}, ::Type{T},\n    trait_a::GI.AbstractTrait, geom_a,\n    trait_b::GI.AbstractTrait, geom_b,\n) where {Target, T}\n    throw(ArgumentError(\"Intersection between $trait_a and $trait_b with target $Target isn't implemented yet.\"))\n    return nothing\nend","category":"page"},{"location":"source/methods/clipping/union/","page":"Union Polygon Clipping","title":"Union Polygon Clipping","text":"","category":"page"},{"location":"source/methods/clipping/union/","page":"Union Polygon Clipping","title":"Union Polygon Clipping","text":"This page was generated using Literate.jl.","category":"page"},{"location":"source/methods/clipping/difference/#Difference-Polygon-Clipping","page":"Difference Polygon Clipping","title":"Difference Polygon Clipping","text":"","category":"section"},{"location":"source/methods/clipping/difference/","page":"Difference Polygon Clipping","title":"Difference Polygon Clipping","text":"export difference\n\n\n\"\"\"\n    difference(geom_a, geom_b, [T::Type]; target::Type)\n\nReturn the difference between two geometries as a list of geometries. Return an empty list\nif none are found. The type of the list will be constrained as much as possible given the\ninput geometries. Furthermore, the user can provide a `taget` type as a keyword argument and\na list of target geometries found in the difference will be returned. The user can also\nprovide a float type that they would like the points of returned geometries to be.\n\n# Example\n\n```jldoctest\nimport GeoInterface as GI, GeometryOps as GO\n\npoly1 = GI.Polygon([[[0.0, 0.0], [5.0, 5.0], [10.0, 0.0], [5.0, -5.0], [0.0, 0.0]]])\npoly2 = GI.Polygon([[[3.0, 0.0], [8.0, 5.0], [13.0, 0.0], [8.0, -5.0], [3.0, 0.0]]])\ndiff_poly = GO.difference(poly1, poly2; target = GI.PolygonTrait)\nGI.coordinates.(diff_poly)","category":"page"},{"location":"source/methods/clipping/difference/","page":"Difference Polygon Clipping","title":"Difference Polygon Clipping","text":"output","category":"page"},{"location":"source/methods/clipping/difference/","page":"Difference Polygon Clipping","title":"Difference Polygon Clipping","text":"1-element Vector{Vector{Vector{Vector{Float64}}}}:\n [[[6.5, 3.5], [5.0, 5.0], [0.0, 0.0], [5.0, -5.0], [6.5, -3.5], [3.0, 0.0], [6.5, 3.5]]]\n```\n\"\"\"\nfunction difference(\n    geom_a, geom_b, ::Type{T} = Float64; target::Type{Target} = Nothing,\n) where {T <: AbstractFloat, Target <: GI.AbstractTrait}\n    return _difference(Target, T, GI.trait(geom_a), geom_a, GI.trait(geom_b), geom_b)\nend\n\n#= The 'difference' function returns the difference of two polygons as a list of polygons.\nThe algorithm to determine the difference was adapted from \"Efficient clipping of efficient\npolygons,\" by Greiner and Hormann (1998). DOI: https://doi.org/10.1145/274363.274364 =#\nfunction _difference(\n    ::Type{GI.PolygonTrait}, ::Type{T},\n    ::GI.PolygonTrait, poly_a,\n    ::GI.PolygonTrait, poly_b,\n) where T","category":"page"},{"location":"source/methods/clipping/difference/","page":"Difference Polygon Clipping","title":"Difference Polygon Clipping","text":"Get the exterior of the polygons","category":"page"},{"location":"source/methods/clipping/difference/","page":"Difference Polygon Clipping","title":"Difference Polygon Clipping","text":"    ext_poly_a = GI.getexterior(poly_a)\n    ext_poly_b = GI.getexterior(poly_b)","category":"page"},{"location":"source/methods/clipping/difference/","page":"Difference Polygon Clipping","title":"Difference Polygon Clipping","text":"Find the difference of the exterior of the polygons","category":"page"},{"location":"source/methods/clipping/difference/","page":"Difference Polygon Clipping","title":"Difference Polygon Clipping","text":"    a_list, b_list, a_idx_list = _build_ab_list(T, ext_poly_a, ext_poly_b)\n    polys = _trace_polynodes(T, a_list, b_list, a_idx_list, (x, y) -> (x ⊻ y) ? 1 : (-1))\n    if isempty(polys)\n        if _point_filled_curve_orientation(b_list[1].point, ext_poly_a) == point_in\n            poly_a_b_hole = GI.Polygon([ext_poly_a, ext_poly_b])\n            push!(polys, poly_a_b_hole)\n        elseif _point_filled_curve_orientation(a_list[1].point, ext_poly_b) != point_in","category":"page"},{"location":"source/methods/clipping/difference/","page":"Difference Polygon Clipping","title":"Difference Polygon Clipping","text":"Two polygons don't intersect and are not contained in one another","category":"page"},{"location":"source/methods/clipping/difference/","page":"Difference Polygon Clipping","title":"Difference Polygon Clipping","text":"            push!(polys, GI.Polygon([ext_poly_a]))\n        end\n    end","category":"page"},{"location":"source/methods/clipping/difference/","page":"Difference Polygon Clipping","title":"Difference Polygon Clipping","text":"If the original polygons had holes, take that into account.","category":"page"},{"location":"source/methods/clipping/difference/","page":"Difference Polygon Clipping","title":"Difference Polygon Clipping","text":"    if GI.nhole(poly_a) != 0 || GI.nhole(poly_b) != 0\n        _add_holes_to_polys!(T, polys, GI.gethole(poly_a))\n        for hole in GI.gethole(poly_b)\n            new_polys = intersection(GI.Polygon([hole]), poly_a, T; target = GI.PolygonTrait)\n            if length(new_polys) > 0\n                append!(polys, new_polys)\n            end\n        end\n    end\n    return polys\nend","category":"page"},{"location":"source/methods/clipping/difference/","page":"Difference Polygon Clipping","title":"Difference Polygon Clipping","text":"Many type and target combos aren't implemented","category":"page"},{"location":"source/methods/clipping/difference/","page":"Difference Polygon Clipping","title":"Difference Polygon Clipping","text":"function _difference(\n    ::Type{Target}, ::Type{T},\n    trait_a::GI.AbstractTrait, geom_a,\n    trait_b::GI.AbstractTrait, geom_b,\n) where {Target, T}\n    @assert(\n        false,\n        \"Intersection between $trait_a and $trait_b with target $Target isn't implemented yet.\",\n    )\n    return nothing\nend","category":"page"},{"location":"source/methods/clipping/difference/","page":"Difference Polygon Clipping","title":"Difference Polygon Clipping","text":"","category":"page"},{"location":"source/methods/clipping/difference/","page":"Difference Polygon Clipping","title":"Difference Polygon Clipping","text":"This page was generated using Literate.jl.","category":"page"},{"location":"source/methods/geom_relations/crosses/#Crossing-checks","page":"Crossing checks","title":"Crossing checks","text":"","category":"section"},{"location":"source/methods/geom_relations/crosses/","page":"Crossing checks","title":"Crossing checks","text":"\"\"\"\n     crosses(geom1, geom2)::Bool\n\nReturn `true` if the intersection results in a geometry whose dimension is one less than\nthe maximum dimension of the two source geometries and the intersection set is interior to\nboth source geometries.\n\nTODO: broken\n\n# Examples\n```julia\nimport GeoInterface as GI, GeometryOps as GO","category":"page"},{"location":"source/methods/geom_relations/crosses/","page":"Crossing checks","title":"Crossing checks","text":"TODO: Add working example","category":"page"},{"location":"source/methods/geom_relations/crosses/","page":"Crossing checks","title":"Crossing checks","text":"```\n\"\"\"\ncrosses(g1, g2)::Bool = crosses(trait(g1), g1, trait(g2), g2)::Bool\ncrosses(t1::FeatureTrait, g1, t2, g2)::Bool = crosses(GI.geometry(g1), g2)\ncrosses(t1, g1, t2::FeatureTrait, g2)::Bool = crosses(g1, geometry(g2))\ncrosses(::MultiPointTrait, g1, ::LineStringTrait, g2)::Bool = multipoint_crosses_line(g1, g2)\ncrosses(::MultiPointTrait, g1, ::PolygonTrait, g2)::Bool = multipoint_crosses_poly(g1, g2)\ncrosses(::LineStringTrait, g1, ::MultiPointTrait, g2)::Bool = multipoint_crosses_lines(g2, g1)\ncrosses(::LineStringTrait, g1, ::PolygonTrait, g2)::Bool = line_crosses_poly(g1, g2)\ncrosses(::LineStringTrait, g1, ::LineStringTrait, g2)::Bool = line_crosses_line(g1, g2)\ncrosses(::PolygonTrait, g1, ::MultiPointTrait, g2)::Bool = multipoint_crosses_poly(g2, g1)\ncrosses(::PolygonTrait, g1, ::LineStringTrait, g2)::Bool = line_crosses_poly(g2, g1)\n\nfunction multipoint_crosses_line(geom1, geom2)\n    int_point = false\n    ext_point = false\n    i = 1\n    np2 = GI.npoint(geom2)\n\n    while i < GI.npoint(geom1) && !int_point && !ext_point\n        for j in 1:GI.npoint(geom2) - 1\n            exclude_boundary = (j === 1 || j === np2 - 2) ? :none : :both\n            if _point_on_segment(GI.getpoint(geom1, i), (GI.getpoint(geom2, j), GI.getpoint(geom2, j + 1)); exclude_boundary)\n                int_point = true\n            else\n                ext_point = true\n            end\n        end\n        i += 1\n    end\n    return int_point && ext_point\nend\n\nfunction line_crosses_line(line1, line2)\n    np2 = GI.npoint(line2)\n    if GeometryOps.intersects(line1, line2)\n        for i in 1:GI.npoint(line1) - 1\n            for j in 1:GI.npoint(line2) - 1\n                exclude_boundary = (j === 1 || j === np2 - 2) ? :none : :both\n                pa = GI.getpoint(line1, i)\n                pb = GI.getpoint(line1, i + 1)\n                p = GI.getpoint(line2, j)\n                _point_on_segment(p, (pa, pb); exclude_boundary) && return true\n            end\n        end\n    end\n    return false\nend\n\nfunction line_crosses_poly(line, poly)\n    for l in flatten(AbstractCurveTrait, poly)\n        intersects(line, l) && return true\n    end\n    return false\nend\n\nfunction multipoint_crosses_poly(mp, poly)\n    int_point = false\n    ext_point = false\n\n    for p in GI.getpoint(mp)\n        if _point_polygon_process(\n            p, poly;\n            in_allow = true, on_allow = true, out_allow = false,\n        )\n            int_point = true\n        else\n            ext_point = true\n        end\n        int_point && ext_point && return true\n    end\n    return false\nend\n\n#= TODO: Once crosses is swapped over to use the geom relations workflow, can\ndelete these helpers. =#\n\nfunction _point_on_segment(point, (start, stop); exclude_boundary::Symbol=:none)::Bool\n    x, y = GI.x(point), GI.y(point)\n    x1, y1 = GI.x(start), GI.y(start)\n    x2, y2 = GI.x(stop), GI.y(stop)\n\n    dxc = x - x1\n    dyc = y - y1\n    dx1 = x2 - x1\n    dy1 = y2 - y1","category":"page"},{"location":"source/methods/geom_relations/crosses/","page":"Crossing checks","title":"Crossing checks","text":"TODO use better predicate for crossing here","category":"page"},{"location":"source/methods/geom_relations/crosses/","page":"Crossing checks","title":"Crossing checks","text":"    cross = dxc * dy1 - dyc * dx1\n    cross != 0 && return false","category":"page"},{"location":"source/methods/geom_relations/crosses/","page":"Crossing checks","title":"Crossing checks","text":"Will constprop optimise these away?","category":"page"},{"location":"source/methods/geom_relations/crosses/","page":"Crossing checks","title":"Crossing checks","text":"    if exclude_boundary === :none\n        if abs(dx1) >= abs(dy1)\n            return dx1 > 0 ? x1 <= x && x <= x2 : x2 <= x && x <= x1\n        end\n        return dy1 > 0 ? y1 <= y && y <= y2 : y2 <= y && y <= y1\n    elseif exclude_boundary === :start\n        if abs(dx1) >= abs(dy1)\n             return dx1 > 0 ? x1 < x && x <= x2 : x2 <= x && x < x1\n        end\n        return dy1 > 0 ? y1 < y && y <= y2 : y2 <= y && y < y1\n    elseif exclude_boundary === :end\n        if abs(dx1) >= abs(dy1)\n            return dx1 > 0 ? x1 <= x && x < x2 : x2 < x && x <= x1\n        end\n        return dy1 > 0 ? y1 <= y && y < y2 : y2 < y && y <= y1\n    elseif exclude_boundary === :both\n        if abs(dx1) >= abs(dy1)\n            return dx1 > 0 ? x1 < x && x < x2 : x2 < x && x < x1\n        end\n        return dy1 > 0 ? y1 < y && y < y2 : y2 < y && y < y1\n    end\n    return false\nend","category":"page"},{"location":"source/methods/geom_relations/crosses/","page":"Crossing checks","title":"Crossing checks","text":"","category":"page"},{"location":"source/methods/geom_relations/crosses/","page":"Crossing checks","title":"Crossing checks","text":"This page was generated using Literate.jl.","category":"page"},{"location":"source/methods/geom_relations/touches/#Touches","page":"Touches","title":"Touches","text":"","category":"section"},{"location":"source/methods/geom_relations/touches/","page":"Touches","title":"Touches","text":"export touches","category":"page"},{"location":"source/methods/geom_relations/touches/#What-is-touches?","page":"Touches","title":"What is touches?","text":"","category":"section"},{"location":"source/methods/geom_relations/touches/","page":"Touches","title":"Touches","text":"The touches function checks if one geometry touches another geometry. In other words, the interiors of the two geometries don't interact, but one of the geometries must have a boundary point that interacts with either the other geometies interior or boundary.","category":"page"},{"location":"source/methods/geom_relations/touches/","page":"Touches","title":"Touches","text":"To provide an example, consider these two lines:","category":"page"},{"location":"source/methods/geom_relations/touches/","page":"Touches","title":"Touches","text":"import GeometryOps as GO\nimport GeoInterface as GI\nusing Makie\nusing CairoMakie\n\nl1 = GI.Line([(0.0, 0.0), (1.0, 0.0)])\nl2 = GI.Line([(1.0, 0.0), (1.0, -1.0)])\n\nf, a, p = lines(GI.getpoint(l1))\nlines!(GI.getpoint(l2))\nf","category":"page"},{"location":"source/methods/geom_relations/touches/","page":"Touches","title":"Touches","text":"We can see that these two lines touch only at their endpoints.","category":"page"},{"location":"source/methods/geom_relations/touches/","page":"Touches","title":"Touches","text":"GO.touches(l1, l2)  # true","category":"page"},{"location":"source/methods/geom_relations/touches/#Implementation","page":"Touches","title":"Implementation","text":"","category":"section"},{"location":"source/methods/geom_relations/touches/","page":"Touches","title":"Touches","text":"This is the GeoInterface-compatible implementation.","category":"page"},{"location":"source/methods/geom_relations/touches/","page":"Touches","title":"Touches","text":"First, we implement a wrapper method that dispatches to the correct implementation based on the geometry trait.","category":"page"},{"location":"source/methods/geom_relations/touches/","page":"Touches","title":"Touches","text":"Each of these calls a method in the geomgeomprocessors file. The methods in this file determine if the given geometries meet a set of criteria. For the touches function and arguments g1 and g2, this criteria is as follows:     - points of g1 are not allowed to be in the interior of g2     - points of g1 are allowed to be on the boundary of g2     - points of g1 are allowed to be in the exterior of g2     - no points of g1 are required to be in the interior of g2     - at least one point of g1 is required to be on the boundary of g2     - no points of g1 are required to be in the exterior of g2","category":"page"},{"location":"source/methods/geom_relations/touches/","page":"Touches","title":"Touches","text":"The code for the specific implementations is in the geomgeomprocessors file.","category":"page"},{"location":"source/methods/geom_relations/touches/","page":"Touches","title":"Touches","text":"const TOUCHES_POINT_ALLOWED = (in_allow = false, on_allow = true, out_allow = false)\nconst TOUCHES_CURVE_ALLOWED = (over_allow = false, cross_allow = false, on_allow = true, out_allow = true)\nconst TOUCHES_POLYGON_ALLOWS = (in_allow = false, on_allow = true, out_allow = true)\nconst TOUCHES_REQUIRES = (in_require = false, on_require = true, out_require = false)\n\n\"\"\"\n    touches(geom1, geom2)::Bool\n\nReturn `true` if the first geometry touches the second geometry. In other words,\nthe two interiors cannot interact, but one of the geometries must have a\nboundary point that interacts with either the other geometies interior or\nboundary.\n\n# Examples\n```jldoctest setup=:(using GeometryOps, GeometryBasics)\nimport GeometryOps as GO, GeoInterface as GI\n\nl1 = GI.Line([(0.0, 0.0), (1.0, 0.0)])\nl2 = GI.Line([(1.0, 1.0), (1.0, -1.0)])\n\nGO.touches(l1, l2)","category":"page"},{"location":"source/methods/geom_relations/touches/","page":"Touches","title":"Touches","text":"output","category":"page"},{"location":"source/methods/geom_relations/touches/","page":"Touches","title":"Touches","text":"true\n```\n\"\"\"\ntouches(g1, g2)::Bool = _touches(trait(g1), g1, trait(g2), g2)","category":"page"},{"location":"source/methods/geom_relations/touches/#Convert-features-to-geometries","page":"Touches","title":"Convert features to geometries","text":"","category":"section"},{"location":"source/methods/geom_relations/touches/","page":"Touches","title":"Touches","text":"_touches(::GI.FeatureTrait, g1, ::Any, g2) = touches(GI.geometry(g1), g2)\n_touches(::Any, g1, t2::GI.FeatureTrait, g2) = touches(g1, GI.geometry(g2))\n_touches(::FeatureTrait, g1, ::FeatureTrait, g2) = touches(GI.geometry(g1), GI.geometry(g2))","category":"page"},{"location":"source/methods/geom_relations/touches/#Point-touches-geometries","page":"Touches","title":"Point touches geometries","text":"","category":"section"},{"location":"source/methods/geom_relations/touches/","page":"Touches","title":"Touches","text":"Point cannot touch another point as if they are equal, interiors interact","category":"page"},{"location":"source/methods/geom_relations/touches/","page":"Touches","title":"Touches","text":"_touches(\n    ::GI.PointTrait, g1,\n    ::GI.PointTrait, g2,\n) = false","category":"page"},{"location":"source/methods/geom_relations/touches/","page":"Touches","title":"Touches","text":"Point touches a linestring if it equal to the first of last point of the line","category":"page"},{"location":"source/methods/geom_relations/touches/","page":"Touches","title":"Touches","text":"function _touches(\n    ::GI.PointTrait, g1,\n    ::Union{GI.LineTrait, GI.LineStringTrait}, g2,\n)\n    n = GI.npoint(g2)\n    p1 = GI.getpoint(g2, 1)\n    pn = GI.getpoint(g2, n)\n    equals(p1, pn) && return false\n    return equals(g1, p1) || equals(g1, pn)\nend","category":"page"},{"location":"source/methods/geom_relations/touches/","page":"Touches","title":"Touches","text":"Point cannot 'touch' a linearring given that the ring has no boundary points","category":"page"},{"location":"source/methods/geom_relations/touches/","page":"Touches","title":"Touches","text":"_touches(\n    ::GI.PointTrait, g1,\n    ::GI.LinearRingTrait, g2,\n) = false","category":"page"},{"location":"source/methods/geom_relations/touches/","page":"Touches","title":"Touches","text":"Point touches a polygon if it is on the boundary of that polygon","category":"page"},{"location":"source/methods/geom_relations/touches/","page":"Touches","title":"Touches","text":"_touches(\n    ::GI.PointTrait, g1,\n    ::GI.PolygonTrait, g2,\n) = _point_polygon_process(\n    g1, g2;\n    TOUCHES_POINT_ALLOWED...,\n)\n\n#= Geometry touches a point if the point is on the geometry boundary. =#\n_touches(\n    trait1::Union{GI.AbstractCurveTrait, GI.PolygonTrait}, g1,\n    trait2::GI.PointTrait, g2,\n) = _touches(trait2, g2, trait1, g1)","category":"page"},{"location":"source/methods/geom_relations/touches/#Lines-touching-geometries","page":"Touches","title":"Lines touching geometries","text":"","category":"section"},{"location":"source/methods/geom_relations/touches/","page":"Touches","title":"Touches","text":"#= Linestring touches another line if at least one bounday point interacts with\nthe bounday of interior of the other line, but the interiors don't interact. =#\n_touches(\n    ::Union{GI.LineTrait, GI.LineStringTrait}, g1,\n    ::Union{GI.LineTrait, GI.LineStringTrait}, g2,\n) = _line_curve_process(\n    g1, g2;\n    TOUCHES_CURVE_ALLOWED...,\n    TOUCHES_REQUIRES...,\n    closed_line = false,\n    closed_curve = false,\n)\n\n\n#= Linestring touches a linearring if at least one of the boundary points of the\nline interacts with the linear ring, but their interiors can't interact. =#\n_touches(\n    ::Union{GI.LineTrait, GI.LineStringTrait}, g1,\n    ::GI.LinearRingTrait, g2,\n) = _line_curve_process(\n    g1, g2;\n    TOUCHES_CURVE_ALLOWED...,\n    TOUCHES_REQUIRES...,\n    closed_line = false,\n    closed_curve = true,\n)\n\n#= Linestring touches a polygon if at least one of the boundary points of the\nline interacts with the boundary of the polygon. =#\n_touches(\n    ::Union{GI.LineTrait, GI.LineStringTrait}, g1,\n    ::GI.PolygonTrait, g2,\n) = _line_polygon_process(\n    g1, g2;\n    TOUCHES_POLYGON_ALLOWS...,\n    TOUCHES_REQUIRES...,\n    closed_line = false,\n)","category":"page"},{"location":"source/methods/geom_relations/touches/#Rings-touch-geometries","page":"Touches","title":"Rings touch geometries","text":"","category":"section"},{"location":"source/methods/geom_relations/touches/","page":"Touches","title":"Touches","text":"#= Linearring touches a linestring if at least one of the boundary points of the\nline interacts with the linear ring, but their interiors can't interact. =#\n_touches(\n    trait1::GI.LinearRingTrait, g1,\n    trait2::Union{GI.LineTrait, GI.LineStringTrait}, g2,\n) = _touches(trait2, g2, trait1, g1)\n\n#= Linearring cannot touch another linear ring since they are both exclusively\nmade up of interior points and no bounday points =#\n_touches(\n    ::GI.LinearRingTrait, g1,\n    ::GI.LinearRingTrait, g2,\n) = false\n\n#= Linearring touches a polygon if at least one of the points of the ring\ninteract with the polygon bounday and non are in the polygon interior. =#\n_touches(\n    ::GI.LinearRingTrait, g1,\n    ::GI.PolygonTrait, g2,\n) = _line_polygon_process(\n    g1, g2;\n    TOUCHES_POLYGON_ALLOWS...,\n    TOUCHES_REQUIRES...,\n    closed_line = true,\n)","category":"page"},{"location":"source/methods/geom_relations/touches/#Polygons-touch-geometries","page":"Touches","title":"Polygons touch geometries","text":"","category":"section"},{"location":"source/methods/geom_relations/touches/","page":"Touches","title":"Touches","text":"#= Polygon touches a curve if at least one of the curve bounday points interacts\nwith the polygon's bounday and no curve points interact with the interior.=#\n_touches(\n    trait1::GI.PolygonTrait, g1,\n    trait2::GI.AbstractCurveTrait, g2\n) = _touches(trait2, g2, trait1, g1)\n\n\n#= Polygon touches another polygon if they share at least one boundary point and\nno interior points. =#\n_touches(\n    ::GI.PolygonTrait, g1,\n    ::GI.PolygonTrait, g2,\n) = _polygon_polygon_process(\n    g1, g2;\n    TOUCHES_POLYGON_ALLOWS...,\n    TOUCHES_REQUIRES...,\n)","category":"page"},{"location":"source/methods/geom_relations/touches/#Geometries-touch-multi-geometry/geometry-collections","page":"Touches","title":"Geometries touch multi-geometry/geometry collections","text":"","category":"section"},{"location":"source/methods/geom_relations/touches/","page":"Touches","title":"Touches","text":"#= Geometry touch a multi-geometry or a collection if the geometry touches at\nleast one of the elements of the collection. =#\nfunction _touches(\n    ::Union{GI.PointTrait, GI.AbstractCurveTrait, GI.PolygonTrait}, g1,\n    ::Union{\n        GI.MultiPointTrait, GI.AbstractMultiCurveTrait,\n        GI.MultiPolygonTrait, GI.GeometryCollectionTrait,\n    }, g2,\n)\n    for sub_g2 in GI.getgeom(g2)\n        !touches(g1, sub_g2) && return false\n    end\n    return true\nend","category":"page"},{"location":"source/methods/geom_relations/touches/#Multi-geometry/geometry-collections-cross-geometries","page":"Touches","title":"Multi-geometry/geometry collections cross geometries","text":"","category":"section"},{"location":"source/methods/geom_relations/touches/","page":"Touches","title":"Touches","text":"#= Multi-geometry or a geometry collection touches a geometry if at least one\nelements of the collection touches the geometry. =#\nfunction _touches(\n    ::Union{\n        GI.MultiPointTrait, GI.AbstractMultiCurveTrait,\n        GI.MultiPolygonTrait, GI.GeometryCollectionTrait,\n    }, g1,\n    ::GI.AbstractGeometryTrait, g2,\n)\n    for sub_g1 in GI.getgeom(g1)\n        !touches(sub_g1, g2) && return false\n    end\n    return true\nend","category":"page"},{"location":"source/methods/geom_relations/touches/","page":"Touches","title":"Touches","text":"","category":"page"},{"location":"source/methods/geom_relations/touches/","page":"Touches","title":"Touches","text":"This page was generated using Literate.jl.","category":"page"},{"location":"source/methods/barycentric/#Barycentric-coordinates","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"","category":"section"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"export barycentric_coordinates, barycentric_coordinates!, barycentric_interpolate\nexport MeanValue","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"Generalized barycentric coordinates are a generalization of barycentric coordinates, which are typically used in triangles, to arbitrary polygons.","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"They provide a way to express a point within a polygon as a weighted average of the polygon's vertices.","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"In the case of a triangle, barycentric coordinates are a set of three numbers (λ_1 λ_2 λ_3), each associated with a vertex of the triangle. Any point within the triangle can be expressed as a weighted average of the vertices, where the weights are the barycentric coordinates. The weights sum to 1, and each is non-negative.","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"For a polygon with n vertices, generalized barycentric coordinates are a set of n numbers (λ_1 λ_2  λ_n), each associated with a vertex of the polygon. Any point within the polygon can be expressed as a weighted average of the vertices, where the weights are the generalized barycentric coordinates.","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"As with the triangle case, the weights sum to 1, and each is non-negative.","category":"page"},{"location":"source/methods/barycentric/#Example","page":"Barycentric coordinates","title":"Example","text":"","category":"section"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"This example was taken from this page of CGAL's documentation.","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"using GeometryOps\nusing GeometryOps.GeometryBasics\nusing Makie\nusing CairoMakie\n# Define a polygon\npolygon_points = Point3f[\n(0.03, 0.05, 0.00), (0.07, 0.04, 0.02), (0.10, 0.04, 0.04),\n(0.14, 0.04, 0.06), (0.17, 0.07, 0.08), (0.20, 0.09, 0.10),\n(0.22, 0.11, 0.12), (0.25, 0.11, 0.14), (0.27, 0.10, 0.16),\n(0.30, 0.07, 0.18), (0.31, 0.04, 0.20), (0.34, 0.03, 0.22),\n(0.37, 0.02, 0.24), (0.40, 0.03, 0.26), (0.42, 0.04, 0.28),\n(0.44, 0.07, 0.30), (0.45, 0.10, 0.32), (0.46, 0.13, 0.34),\n(0.46, 0.19, 0.36), (0.47, 0.26, 0.38), (0.47, 0.31, 0.40),\n(0.47, 0.35, 0.42), (0.45, 0.37, 0.44), (0.41, 0.38, 0.46),\n(0.38, 0.37, 0.48), (0.35, 0.36, 0.50), (0.32, 0.35, 0.52),\n(0.30, 0.37, 0.54), (0.28, 0.39, 0.56), (0.25, 0.40, 0.58),\n(0.23, 0.39, 0.60), (0.21, 0.37, 0.62), (0.21, 0.34, 0.64),\n(0.23, 0.32, 0.66), (0.24, 0.29, 0.68), (0.27, 0.24, 0.70),\n(0.29, 0.21, 0.72), (0.29, 0.18, 0.74), (0.26, 0.16, 0.76),\n(0.24, 0.17, 0.78), (0.23, 0.19, 0.80), (0.24, 0.22, 0.82),\n(0.24, 0.25, 0.84), (0.21, 0.26, 0.86), (0.17, 0.26, 0.88),\n(0.12, 0.24, 0.90), (0.07, 0.20, 0.92), (0.03, 0.15, 0.94),\n(0.01, 0.10, 0.97), (0.02, 0.07, 1.00)]\n# Plot it!\n# First, we'll plot the polygon using Makie's rendering:\nf, a1, p1 = poly(\n    polygon_points;\n    color = last.(polygon_points), colormap = cgrad(:jet, 18; categorical = true),\n    axis = (;\n       type = Axis, aspect = DataAspect(), title = \"Makie mesh based polygon rendering\", subtitle = \"CairoMakie\"\n    ),\n    figure = (; size = (800, 400),)\n)\n\nMakie.update_state_before_display!(f) # We have to call this explicitly, to get the axis limits correct\n# Now that we've plotted the first polygon,\n# we can render it using barycentric coordinates.\na1_bbox = a1.finallimits[] # First we get the extent of the axis\next = GeometryOps.GI.Extent(NamedTuple{(:X, :Y)}(zip(minimum(a1_bbox), maximum(a1_bbox))))\n\na2 = Axis(\n        f[1, 2],\n        aspect = DataAspect(),\n        title = \"Barycentric coordinate based polygon rendering\", subtitle = \"GeometryOps\",\n        limits = (ext.X, ext.Y)\n    )\np2box = poly!( # Now, we plot a cropping rectangle around the axis so we only show the polygon\n    a2,\n    GeometryOps.GeometryBasics.Polygon( # This is a rectangle with an internal hole shaped like the polygon.\n        Point2f[(ext.X[1], ext.Y[1]), (ext.X[2], ext.Y[1]), (ext.X[2], ext.Y[2]), (ext.X[1], ext.Y[2]), (ext.X[1], ext.Y[1])],\n        [reverse(Point2f.(polygon_points))]\n    );\n    color = :white, xautolimits = false, yautolimits = false\n)\nhidedecorations!(a1)\nhidedecorations!(a2)\ncb = Colorbar(f[2, :], p1.plots[1]; vertical = false, flipaxis = true)\n# Finally, we perform barycentric interpolation on a grid,\nxrange = LinRange(ext.X..., size(a2.scene)[1] * 4) # 2 rendered pixels per \"physical\" pixel\nyrange = LinRange(ext.Y..., size(a2.scene)[2] * 4) # 2 rendered pixels per \"physical\" pixel\n@time mean_values = barycentric_interpolate.(\n    (MeanValue(),), # The barycentric coordinate algorithm (MeanValue is the only one for now)\n    (Point2f.(polygon_points),), # The polygon points as `Point2f`\n    (last.(polygon_points,),),   # The values per polygon point - can be anything which supports addition and division\n    Point2f.(xrange, yrange')    # The points at which to interpolate\n)\n# and render!\nhm = heatmap!(\n    a2, xrange, yrange, mean_values;\n    colormap = p1.colormap, # Use the same colormap as the original polygon plot\n    colorrange = p1.plots[1].colorrange[], # Access the rendered mesh plot's colorrange directly\n    xautolimits = false, yautolimits = false\n)\ntranslate!(hm, 0, 0, -1) # translate the heatmap behind the cropping polygon!\nf","category":"page"},{"location":"source/methods/barycentric/#Barycentric-coordinate-API","page":"Barycentric coordinates","title":"Barycentric-coordinate API","text":"","category":"section"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"In some cases, we actually want barycentric interpolation, and have no interest in the coordinates themselves.","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"However, the coordinates can be useful for debugging, and when performing 3D rendering, multiple barycentric values (depth, uv) are needed for depth buffering.","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"const _VecTypes = Union{Tuple{Vararg{T, N}}, GeometryBasics.StaticArraysCore.StaticArray{Tuple{N}, T, 1}} where {N, T}\n\n\"\"\"\n    abstract type AbstractBarycentricCoordinateMethod\n\nAbstract supertype for barycentric coordinate methods.\nThe subtypes may serve as dispatch types, or may cache\nsome information about the target polygon.\n\n# API\nThe following methods must be implemented for all subtypes:\n- `barycentric_coordinates!(λs::Vector{<: Real}, method::AbstractBarycentricCoordinateMethod, exterior::Vector{<: Point{2, T1}}, point::Point{2, T2})`\n- `barycentric_interpolate(method::AbstractBarycentricCoordinateMethod, exterior::Vector{<: Point{2, T1}}, values::Vector{V}, point::Point{2, T2})::V`\n- `barycentric_interpolate(method::AbstractBarycentricCoordinateMethod, exterior::Vector{<: Point{2, T1}}, interiors::Vector{<: Vector{<: Point{2, T1}}} values::Vector{V}, point::Point{2, T2})::V`\nThe rest of the methods will be implemented in terms of these, and have efficient dispatches for broadcasting.\n\"\"\"\nabstract type AbstractBarycentricCoordinateMethod end\n\n\nBase.@propagate_inbounds function barycentric_coordinates!(λs::Vector{<: Real}, method::AbstractBarycentricCoordinateMethod, polypoints::AbstractVector{<: Point{N1, T1}}, point::Point{N2, T2}) where {N1, N2, T1 <: Real, T2 <: Real}\n    @boundscheck @assert length(λs) == length(polypoints)\n    @boundscheck @assert length(polypoints) >= 3\n\n    @error(\"Not implemented yet for method $(method).\")\nend\nBase.@propagate_inbounds barycentric_coordinates!(λs::Vector{<: Real}, polypoints::AbstractVector{<: Point{N1, T1}}, point::Point{N2, T2}) where {N1, N2, T1 <: Real, T2 <: Real} = barycentric_coordinates!(λs, MeanValue(), polypoints, point)\n\nBase.@propagate_inbounds function barycentric_coordinates(method::AbstractBarycentricCoordinateMethod, polypoints::AbstractVector{<: Point{N1, T1}}, point::Point{N2, T2}) where {N1, N2, T1 <: Real, T2 <: Real}\n    λs = zeros(promote_type(T1, T2), length(polypoints))\n    barycentric_coordinates!(λs, method, polypoints, point)\n    return λs\nend\nBase.@propagate_inbounds barycentric_coordinates(polypoints::AbstractVector{<: Point{N1, T1}}, point::Point{N2, T2}) where {N1, N2, T1 <: Real, T2 <: Real} = barycentric_coordinates(MeanValue(), polypoints, point)\n\nBase.@propagate_inbounds function barycentric_interpolate(method::AbstractBarycentricCoordinateMethod, polypoints::AbstractVector{<: Point{N, T1}}, values::AbstractVector{V}, point::Point{N, T2}) where {N, T1 <: Real, T2 <: Real, V}\n    @boundscheck @assert length(values) == length(polypoints)\n    @boundscheck @assert length(polypoints) >= 3\n    λs = barycentric_coordinates(method, polypoints, point)\n    return sum(λs .* values)\nend\nBase.@propagate_inbounds barycentric_interpolate(polypoints::AbstractVector{<: Point{N, T1}}, values::AbstractVector{V}, point::Point{N, T2}) where {N, T1 <: Real, T2 <: Real, V} = barycentric_interpolate(MeanValue(), polypoints, values, point)\n\nBase.@propagate_inbounds function barycentric_interpolate(method::AbstractBarycentricCoordinateMethod, exterior::AbstractVector{<: Point{N, T1}}, interiors::AbstractVector{<: Point{N, T1}}, values::AbstractVector{V}, point::Point{N, T2}) where {N, T1 <: Real, T2 <: Real, V}\n    @boundscheck @assert length(values) == length(exterior) + isempty(interiors) ? 0 : sum(length.(interiors))\n    @boundscheck @assert length(exterior) >= 3\n    λs = barycentric_coordinates(method, exterior, interiors, point)\n    return sum(λs .* values)\nend\nBase.@propagate_inbounds barycentric_interpolate(exterior::AbstractVector{<: Point{N, T1}}, interiors::AbstractVector{<: Point{N, T1}}, values::AbstractVector{V}, point::Point{N, T2}) where {N, T1 <: Real, T2 <: Real, V} = barycentric_interpolate(MeanValue(), exterior, interiors, values, point)\n\nBase.@propagate_inbounds function barycentric_interpolate(method::AbstractBarycentricCoordinateMethod, polygon::Polygon{2, T1}, values::AbstractVector{V}, point::Point{2, T2}) where {T1 <: Real, T2 <: Real, V}\n    exterior = decompose(Point{2, promote_type(T1, T2)}, polygon.exterior)\n    if isempty(polygon.interiors)\n        @boundscheck @assert length(values) == length(exterior)\n        return barycentric_interpolate(method, exterior, values, point)\n    else # the poly has interiors\n        interiors = reverse.(decompose.((Point{2, promote_type(T1, T2)},), polygon.interiors))\n        @boundscheck @assert length(values) == length(exterior) + sum(length.(interiors))\n        return barycentric_interpolate(method, exterior, interiors, values, point)\n    end\nend\nBase.@propagate_inbounds barycentric_interpolate(polygon::Polygon{2, T1}, values::AbstractVector{V}, point::Point{2, T2}) where {T1 <: Real, T2 <: Real, V} = barycentric_interpolate(MeanValue(), polygon, values, point)","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"3D polygons are considered to have their vertices in the XY plane, and the Z coordinate must represent some value.  This is to say that the Z coordinate is interpreted as an M coordinate.","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"Base.@propagate_inbounds function barycentric_interpolate(method::AbstractBarycentricCoordinateMethod, polygon::Polygon{3, T1}, point::Point{2, T2}) where {T1 <: Real, T2 <: Real}\n    exterior_point3s = decompose(Point{3, promote_type(T1, T2)}, polygon.exterior)\n    exterior_values = getindex.(exterior_point3s, 3)\n    exterior_points = Point2f.(exterior_point3s)\n    if isempty(polygon.interiors)\n        return barycentric_interpolate(method, exterior_points, exterior_values, point)\n    else # the poly has interiors\n        interior_point3s = decompose.((Point{3, promote_type(T1, T2)},), polygon.interiors)\n        interior_values = collect(Iterators.flatten((getindex.(point3s, 3) for point3s in interior_point3s)))\n        interior_points = map(point3s -> Point2f.(point3s), interior_point3s)\n        return barycentric_interpolate(method, exterior_points, interior_points, vcat(exterior_values, interior_values), point)\n    end\nend\nBase.@propagate_inbounds barycentric_interpolate(polygon::Polygon{3, T1}, point::Point{2, T2}) where {T1 <: Real, T2 <: Real} = barycentric_interpolate(MeanValue(), polygon, point)","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"This method is the one which supports GeoInterface.","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"Base.@propagate_inbounds function barycentric_interpolate(method::AbstractBarycentricCoordinateMethod, polygon, values::AbstractVector{V}, point) where V\n    @assert GeoInterface.trait(polygon) isa GeoInterface.PolygonTrait\n    @assert GeoInterface.trait(point) isa GeoInterface.PointTrait\n    passable_polygon = GeoInterface.convert(GeometryBasics, polygon)\n    @assert passable_polygon isa GeometryBasics.Polygon \"The polygon was converted to a $(typeof(passable_polygon)), which is not a `GeometryBasics.Polygon`.\"\n    # first_poly_point = GeoInterface.getpoint(GeoInterface.getexterior(polygon))\n    passable_point = GeoInterface.convert(GeometryBasics, point)\n    return barycentric_interpolate(method, passable_polygon, Point2(passable_point))\nend\nBase.@propagate_inbounds barycentric_interpolate(polygon, values::AbstractVector{V}, point) where V = barycentric_interpolate(MeanValue(), polygon, values, point)\n\n\"\"\"\n    weighted_mean(weight::Real, x1, x2)\n\nReturns the weighted mean of `x1` and `x2`, where `weight` is the weight of `x1`.\n\nSpecifically, calculates `x1 * weight + x2 * (1 - weight)`.\n\n!!! note\n    The idea for this method is that you can override this for custom types, like Color types, in extension modules.\n\"\"\"\nfunction weighted_mean(weight::WT, x1, x2) where {WT <: Real}\n    return muladd(x1, weight, x2 * (oneunit(WT) - weight))\nend\n\n\n\"\"\"\n    MeanValue() <: AbstractBarycentricCoordinateMethod\n\nThis method calculates barycentric coordinates using the mean value method.\n\n# References\n\n\"\"\"\nstruct MeanValue <: AbstractBarycentricCoordinateMethod\nend","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"Before we go to the actual implementation, there are some quick and simple utility functions that we need to implement.  These are mainly for convenience and code brevity.","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"\"\"\"\n    _det(s1::Point2{T1}, s2::Point2{T2}) where {T1 <: Real, T2 <: Real}\n\nReturns the determinant of the matrix formed by `hcat`'ing two points `s1` and `s2`.\n\nSpecifically, this is:\n```julia\ns1[1] * s2[2] - s1[2] * s2[1]\n```\n\"\"\"\nfunction _det(s1::_VecTypes{2, T1}, s2::_VecTypes{2, T2}) where {T1 <: Real, T2 <: Real}\n    return s1[1] * s2[2] - s1[2] * s2[1]\nend\n\n\"\"\"\n    t_value(sᵢ, sᵢ₊₁, rᵢ, rᵢ₊₁)\n\nReturns the \"T-value\" as described in Hormann's presentation [^HormannPresentation] on how to calculate\nthe mean-value coordinate.\n\nHere, `sᵢ` is the vector from vertex `vᵢ` to the point, and `rᵢ` is the norm (length) of `sᵢ`.\n`s` must be `Point` and `r` must be real numbers.\n\n```math\ntᵢ = \\\\frac{\\\\mathrm{det}\\\\left(sᵢ, sᵢ₊₁\\\\right)}{rᵢ * rᵢ₊₁ + sᵢ ⋅ sᵢ₊₁}\n```\n\n[^HormannPresentation]: K. Hormann and N. Sukumar. Generalized Barycentric Coordinates in Computer Graphics and Computational Mechanics. Taylor & Fancis, CRC Press, 2017.\n```\n\n\"\"\"\nfunction t_value(sᵢ::_VecTypes{N, T1}, sᵢ₊₁::_VecTypes{N, T1}, rᵢ::T2, rᵢ₊₁::T2) where {N, T1 <: Real, T2 <: Real}\n    return _det(sᵢ, sᵢ₊₁) / muladd(rᵢ, rᵢ₊₁, dot(sᵢ, sᵢ₊₁))\nend\n\n\nfunction barycentric_coordinates!(λs::Vector{<: Real}, ::MeanValue, polypoints::AbstractVector{<: Point{2, T1}}, point::Point{2, T2}) where {T1 <: Real, T2 <: Real}\n    @boundscheck @assert length(λs) == length(polypoints)\n    @boundscheck @assert length(polypoints) >= 3\n    n_points = length(polypoints)\n    # Initialize counters and register variables\n    # Points - these are actually vectors from point to vertices\n    #  polypoints[i-1], polypoints[i], polypoints[i+1]\n    sᵢ₋₁ = polypoints[end] - point\n    sᵢ   = polypoints[begin] - point\n    sᵢ₊₁ = polypoints[begin+1] - point\n    # radius / Euclidean distance between points.\n    rᵢ₋₁ = norm(sᵢ₋₁)\n    rᵢ   = norm(sᵢ  )\n    rᵢ₊₁ = norm(sᵢ₊₁)\n    # Perform the first computation explicitly, so we can cut down on\n    # a mod in the loop.\n    λs[1] = (t_value(sᵢ₋₁, sᵢ, rᵢ₋₁, rᵢ) + t_value(sᵢ, sᵢ₊₁, rᵢ, rᵢ₊₁)) / rᵢ\n    # Loop through the rest of the vertices, compute, store in λs\n    for i in 2:n_points\n        # Increment counters + set variables\n        sᵢ₋₁ = sᵢ\n        sᵢ   = sᵢ₊₁\n        sᵢ₊₁ = polypoints[mod1(i+1, n_points)] - point\n        rᵢ₋₁ = rᵢ\n        rᵢ   = rᵢ₊₁\n        rᵢ₊₁ = norm(sᵢ₊₁) # radius / Euclidean distance between points.\n        λs[i] = (t_value(sᵢ₋₁, sᵢ, rᵢ₋₁, rᵢ) + t_value(sᵢ, sᵢ₊₁, rᵢ, rᵢ₊₁)) / rᵢ\n    end\n    # Normalize λs to the 1-norm (sum=1)\n    λs ./= sum(λs)\n    return λs\nend","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"function barycentric_coordinates(::MeanValue, polypoints::NTuple{N, Point{2, T2}}, point::Point{2, T1},) where {N, T1, T2}\n    ## Initialize counters and register variables\n    ## Points - these are actually vectors from point to vertices\n    ##  polypoints[i-1], polypoints[i], polypoints[i+1]\n    sᵢ₋₁ = polypoints[end] - point\n    sᵢ   = polypoints[begin] - point\n    sᵢ₊₁ = polypoints[begin+1] - point\n    ## radius / Euclidean distance between points.\n    rᵢ₋₁ = norm(sᵢ₋₁)\n    rᵢ   = norm(sᵢ  )\n    rᵢ₊₁ = norm(sᵢ₊₁)\n    λ₁ = (t_value(sᵢ₋₁, sᵢ, rᵢ₋₁, rᵢ) + t_value(sᵢ, sᵢ₊₁, rᵢ, rᵢ₊₁)) / rᵢ\n    λs = ntuple(N) do i\n        if i == 1\n            return λ₁\n        end\n        ## Increment counters + set variables\n        sᵢ₋₁ = sᵢ\n        sᵢ   = sᵢ₊₁\n        sᵢ₊₁ = polypoints[mod1(i+1, N)] - point\n        rᵢ₋₁ = rᵢ\n        rᵢ   = rᵢ₊₁\n        rᵢ₊₁ = norm(sᵢ₊₁) # radius / Euclidean distance between points.\n        return (t_value(sᵢ₋₁, sᵢ, rᵢ₋₁, rᵢ) + t_value(sᵢ, sᵢ₊₁, rᵢ, rᵢ₊₁)) / rᵢ\n    end\n\n    ∑λ = sum(λs)\n\n    return ntuple(N) do i\n        λs[i] / ∑λ\n    end\nend","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"This performs an inplace accumulation, using less memory and is faster. That's particularly good if you are using a polygon with a large number of points...","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"function barycentric_interpolate(::MeanValue, polypoints::AbstractVector{<: Point{2, T1}}, values::AbstractVector{V}, point::Point{2, T2}) where {T1 <: Real, T2 <: Real, V}\n    @boundscheck @assert length(values) == length(polypoints)\n    @boundscheck @assert length(polypoints) >= 3\n\n    n_points = length(polypoints)\n    # Initialize counters and register variables\n    # Points - these are actually vectors from point to vertices\n    #  polypoints[i-1], polypoints[i], polypoints[i+1]\n    sᵢ₋₁ = polypoints[end] - point\n    sᵢ   = polypoints[begin] - point\n    sᵢ₊₁ = polypoints[begin+1] - point\n    # radius / Euclidean distance between points.\n    rᵢ₋₁ = norm(sᵢ₋₁)\n    rᵢ   = norm(sᵢ  )\n    rᵢ₊₁ = norm(sᵢ₊₁)\n    # Now, we set the interpolated value to the first point's value, multiplied\n    # by the weight computed relative to the first point in the polygon.\n    wᵢ = (t_value(sᵢ₋₁, sᵢ, rᵢ₋₁, rᵢ) + t_value(sᵢ, sᵢ₊₁, rᵢ, rᵢ₊₁)) / rᵢ\n    wₜₒₜ = wᵢ\n    interpolated_value = values[begin] * wᵢ\n    for i in 2:n_points\n        # Increment counters + set variables\n        sᵢ₋₁ = sᵢ\n        sᵢ   = sᵢ₊₁\n        sᵢ₊₁ = polypoints[mod1(i+1, n_points)] - point\n        rᵢ₋₁ = rᵢ\n        rᵢ   = rᵢ₊₁\n        rᵢ₊₁ = norm(sᵢ₊₁)\n        # Now, we calculate the weight:\n        wᵢ = (t_value(sᵢ₋₁, sᵢ, rᵢ₋₁, rᵢ) + t_value(sᵢ, sᵢ₊₁, rᵢ, rᵢ₊₁)) / rᵢ\n        # perform a weighted sum with the interpolated value:\n        interpolated_value += values[i] * wᵢ\n        # and add the weight to the total weight accumulator.\n        wₜₒₜ += wᵢ\n    end\n    # Return the normalized interpolated value.\n    return interpolated_value / wₜₒₜ\nend","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"When you have holes, then you have to be careful about the order you iterate around points.","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"Specifically, you have to iterate around each linear ring separately and ensure there are no degenerate/repeated points at the start and end!","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"function barycentric_interpolate(::MeanValue, exterior::AbstractVector{<: Point{N, T1}}, interiors::AbstractVector{<: AbstractVector{<: Point{N, T1}}}, values::AbstractVector{V}, point::Point{N, T2}) where {N, T1 <: Real, T2 <: Real, V}\n    # @boundscheck @assert length(values) == (length(exterior) + isempty(interiors) ? 0 : sum(length.(interiors)))\n    # @boundscheck @assert length(exterior) >= 3\n\n    current_index = 1\n    l_exterior = length(exterior)\n\n    sᵢ₋₁ = exterior[end] - point\n    sᵢ   = exterior[begin] - point\n    sᵢ₊₁ = exterior[begin+1] - point\n    rᵢ₋₁ = norm(sᵢ₋₁) # radius / Euclidean distance between points.\n    rᵢ   = norm(sᵢ  ) # radius / Euclidean distance between points.\n    rᵢ₊₁ = norm(sᵢ₊₁) # radius / Euclidean distance between points.","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"Now, we set the interpolated value to the first point's value, multiplied by the weight computed relative to the first point in the polygon.","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"    wᵢ = (t_value(sᵢ₋₁, sᵢ, rᵢ₋₁, rᵢ) + t_value(sᵢ, sᵢ₊₁, rᵢ, rᵢ₊₁)) / rᵢ\n    wₜₒₜ = wᵢ\n    interpolated_value = values[begin] * wᵢ\n\n    for i in 2:l_exterior","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"Increment counters + set variables","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"        sᵢ₋₁ = sᵢ\n        sᵢ   = sᵢ₊₁\n        sᵢ₊₁ = exterior[mod1(i+1, l_exterior)] - point\n        rᵢ₋₁ = rᵢ\n        rᵢ   = rᵢ₊₁\n        rᵢ₊₁ = norm(sᵢ₊₁) # radius / Euclidean distance between points.\n        wᵢ = (t_value(sᵢ₋₁, sᵢ, rᵢ₋₁, rᵢ) + t_value(sᵢ, sᵢ₊₁, rᵢ, rᵢ₊₁)) / rᵢ","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"Updates - first the interpolated value,","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"        interpolated_value += values[current_index] * wᵢ","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"then the accumulators for total weight and current index.","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"        wₜₒₜ += wᵢ\n        current_index += 1\n\n    end\n    for hole in interiors\n        l_hole = length(hole)\n        sᵢ₋₁ = hole[end] - point\n        sᵢ   = hole[begin] - point\n        sᵢ₊₁ = hole[begin+1] - point\n        rᵢ₋₁ = norm(sᵢ₋₁) # radius / Euclidean distance between points.\n        rᵢ   = norm(sᵢ  ) # radius / Euclidean distance between points.\n        rᵢ₊₁ = norm(sᵢ₊₁) # radius / Euclidean distance between points.\n        # Now, we set the interpolated value to the first point's value, multiplied\n        # by the weight computed relative to the first point in the polygon.\n        wᵢ = (t_value(sᵢ₋₁, sᵢ, rᵢ₋₁, rᵢ) + t_value(sᵢ, sᵢ₊₁, rᵢ, rᵢ₊₁)) / rᵢ\n\n        interpolated_value += values[current_index] * wᵢ\n\n        wₜₒₜ += wᵢ\n        current_index += 1\n\n        for i in 2:l_hole\n            # Increment counters + set variables\n            sᵢ₋₁ = sᵢ\n            sᵢ   = sᵢ₊₁\n            sᵢ₊₁ = hole[mod1(i+1, l_hole)] - point\n            rᵢ₋₁ = rᵢ\n            rᵢ   = rᵢ₊₁\n            rᵢ₊₁ = norm(sᵢ₊₁) ## radius / Euclidean distance between points.\n            wᵢ = (t_value(sᵢ₋₁, sᵢ, rᵢ₋₁, rᵢ) + t_value(sᵢ, sᵢ₊₁, rᵢ, rᵢ₊₁)) / rᵢ\n            interpolated_value += values[current_index] * wᵢ\n            wₜₒₜ += wᵢ\n            current_index += 1\n        end\n    end\n    return interpolated_value / wₜₒₜ\n\nend\n\nstruct Wachspress <: AbstractBarycentricCoordinateMethod\nend","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"","category":"page"},{"location":"source/methods/barycentric/","page":"Barycentric coordinates","title":"Barycentric coordinates","text":"This page was generated using Literate.jl.","category":"page"},{"location":"source/transformations/reproject/#Geometry-reprojection","page":"Geometry reprojection","title":"Geometry reprojection","text":"","category":"section"},{"location":"source/transformations/reproject/","page":"Geometry reprojection","title":"Geometry reprojection","text":"export reproject","category":"page"},{"location":"source/transformations/reproject/","page":"Geometry reprojection","title":"Geometry reprojection","text":"This file is pretty simple - it simply reprojects a geometry pointwise from one CRS to another. It uses the Proj package for the transformation, but this could be moved to an extension if needed.","category":"page"},{"location":"source/transformations/reproject/","page":"Geometry reprojection","title":"Geometry reprojection","text":"This works using the apply functionality.","category":"page"},{"location":"source/transformations/reproject/","page":"Geometry reprojection","title":"Geometry reprojection","text":"\"\"\"\n    reproject(geometry; source_crs, target_crs, transform, always_xy, time)\n    reproject(geometry, source_crs, target_crs; always_xy, time)\n    reproject(geometry, transform; always_xy, time)\n\nReproject any GeoInterface.jl compatible `geometry` from `source_crs` to `target_crs`.\n\nThe returned object will be constructed from `GeoInterface.WrapperGeometry`\ngeometries, wrapping views of a `Vector{Proj.Point{D}}`, where `D` is the dimension.\n\n# Arguments\n\n- `geometry`: Any GeoInterface.jl compatible geometries.\n- `source_crs`: the source coordinate referece system, as a GeoFormatTypes.jl object or a string.\n- `target_crs`: the target coordinate referece system, as a GeoFormatTypes.jl object or a string.\n\nIf these a passed as keywords, `transform` will take priority.\nWithout it `target_crs` is always needed, and `source_crs` is\nneeded if it is not retreivable from the geometry with `GeoInterface.crs(geometry)`.\n\n# Keywords\n\n- `always_xy`: force x, y coordinate order, `true` by default.\n    `false` will expect and return points in the crs coordinate order.\n- `time`: the time for the coordinates. `Inf` by default.\n$APPLY_KEYWORDS\n\"\"\"\nfunction reproject(geom;\n    source_crs=nothing, target_crs=nothing, transform=nothing, kw...\n)\n    if isnothing(transform)\n        if isnothing(source_crs)\n            source_crs = if GI.trait(geom) isa Nothing && geom isa AbstractArray\n                GeoInterface.crs(first(geom))\n            else\n                GeoInterface.crs(geom)\n            end\n        end","category":"page"},{"location":"source/transformations/reproject/","page":"Geometry reprojection","title":"Geometry reprojection","text":"If its still nothing, error","category":"page"},{"location":"source/transformations/reproject/","page":"Geometry reprojection","title":"Geometry reprojection","text":"        isnothing(source_crs) && throw(ArgumentError(\"geom has no crs attatched. Pass a `source_crs` keyword\"))","category":"page"},{"location":"source/transformations/reproject/","page":"Geometry reprojection","title":"Geometry reprojection","text":"Otherwise reproject","category":"page"},{"location":"source/transformations/reproject/","page":"Geometry reprojection","title":"Geometry reprojection","text":"        reproject(geom, source_crs, target_crs; kw...)\n    else\n        reproject(geom, transform; kw...)\n    end\nend\nfunction reproject(geom, source_crs, target_crs;\n    time=Inf,\n    always_xy=true,\n    transform=Proj.Transformation(Proj.CRS(source_crs), Proj.CRS(target_crs); always_xy),\n    kw...\n)\n    reproject(geom, transform; time, target_crs, kw...)\nend\nfunction reproject(geom, transform::Proj.Transformation; time=Inf, target_crs=nothing, kw...)\n    if _is3d(geom)\n        return apply(PointTrait, geom; crs=target_crs, kw...) do p\n            transform(GI.x(p), GI.y(p), GI.z(p))\n        end\n    else\n        return apply(PointTrait, geom; crs=target_crs, kw...) do p\n            transform(GI.x(p), GI.y(p))\n        end\n    end\nend","category":"page"},{"location":"source/transformations/reproject/","page":"Geometry reprojection","title":"Geometry reprojection","text":"","category":"page"},{"location":"source/transformations/reproject/","page":"Geometry reprojection","title":"Geometry reprojection","text":"This page was generated using Literate.jl.","category":"page"},{"location":"source/methods/geom_relations/disjoint/#Disjoint","page":"Disjoint","title":"Disjoint","text":"","category":"section"},{"location":"source/methods/geom_relations/disjoint/","page":"Disjoint","title":"Disjoint","text":"export disjoint","category":"page"},{"location":"source/methods/geom_relations/disjoint/#What-is-disjoint?","page":"Disjoint","title":"What is disjoint?","text":"","category":"section"},{"location":"source/methods/geom_relations/disjoint/","page":"Disjoint","title":"Disjoint","text":"The disjoint function checks if one geometry is outside of another geometry, without sharing any boundaries or interiors.","category":"page"},{"location":"source/methods/geom_relations/disjoint/","page":"Disjoint","title":"Disjoint","text":"To provide an example, consider these two lines:","category":"page"},{"location":"source/methods/geom_relations/disjoint/","page":"Disjoint","title":"Disjoint","text":"import GeometryOps as GO\nimport GeoInterface as GI\nusing Makie\nusing CairoMakie\n\nl1 = GI.LineString([(0.0, 0.0), (1.0, 0.0), (0.0, 0.1)])\nl2 = GI.LineString([(2.0, 0.0), (2.75, 0.0)])\nf, a, p = lines(GI.getpoint(l1), color = :blue)\nscatter!(GI.getpoint(l1), color = :blue)\nlines!(GI.getpoint(l2), color = :orange)\nscatter!(GI.getpoint(l2), color = :orange)\nf","category":"page"},{"location":"source/methods/geom_relations/disjoint/","page":"Disjoint","title":"Disjoint","text":"We can see that none of the edges or vertices of l1 interact with l2 so they are disjoint.","category":"page"},{"location":"source/methods/geom_relations/disjoint/","page":"Disjoint","title":"Disjoint","text":"GO.disjoint(l1, l2)  # returns true","category":"page"},{"location":"source/methods/geom_relations/disjoint/#Implementation","page":"Disjoint","title":"Implementation","text":"","category":"section"},{"location":"source/methods/geom_relations/disjoint/","page":"Disjoint","title":"Disjoint","text":"This is the GeoInterface-compatible implementation.","category":"page"},{"location":"source/methods/geom_relations/disjoint/","page":"Disjoint","title":"Disjoint","text":"First, we implement a wrapper method that dispatches to the correct implementation based on the geometry trait.","category":"page"},{"location":"source/methods/geom_relations/disjoint/","page":"Disjoint","title":"Disjoint","text":"Each of these calls a method in the geomgeomprocessors file. The methods in this file determine if the given geometries meet a set of criteria. For the disjoint function and arguments g1 and g2, this criteria is as follows:     - points of g1 are not allowed to be in the interior of g2     - points of g1 are not allowed to be on the boundary of g2     - points of g1 are allowed to be in the exterior of g2     - no points required to be in the interior of g2     - no points of g1 are required to be on the boundary of g2     - no points of g1 are required to be in the exterior of g2","category":"page"},{"location":"source/methods/geom_relations/disjoint/","page":"Disjoint","title":"Disjoint","text":"The code for the specific implementations is in the geomgeomprocessors file.","category":"page"},{"location":"source/methods/geom_relations/disjoint/","page":"Disjoint","title":"Disjoint","text":"const DISJOINT_ALLOWS = (in_allow = false, on_allow = false, out_allow = true)\nconst DISJOINT_CURVE_ALLOWS = (over_allow = false, cross_allow = false, on_allow = false, out_allow = true)\nconst DISJOINT_REQUIRES = (in_require = false, on_require = false, out_require = false)\n\"\"\"\n    disjoint(geom1, geom2)::Bool\n\nReturn `true` if the first geometry is disjoint from the second geometry.\n\nReturn `true` if the first geometry is disjoint from the second geometry. The\ninteriors and boundaries of both geometries must not intersect.\n\n# Examples\n```jldoctest setup=:(using GeometryOps, GeoInterface)\nimport GeometryOps as GO, GeoInterface as GI\n\nline = GI.LineString([(1, 1), (1, 2), (1, 3), (1, 4)])\npoint = (2, 2)\nGO.disjoint(point, line)","category":"page"},{"location":"source/methods/geom_relations/disjoint/","page":"Disjoint","title":"Disjoint","text":"output","category":"page"},{"location":"source/methods/geom_relations/disjoint/","page":"Disjoint","title":"Disjoint","text":"true\n```\n\"\"\"\ndisjoint(g1, g2) = _disjoint(trait(g1), g1, trait(g2), g2)","category":"page"},{"location":"source/methods/geom_relations/disjoint/#Convert-features-to-geometries","page":"Disjoint","title":"Convert features to geometries","text":"","category":"section"},{"location":"source/methods/geom_relations/disjoint/","page":"Disjoint","title":"Disjoint","text":"_disjoint(::FeatureTrait, g1, ::Any, g2) = disjoint(GI.geometry(g1), g2)\n_disjoint(::Any, g1, ::FeatureTrait, g2) = disjoint(g1, geometry(g2))\n_disjoint(::FeatureTrait, g1, ::FeatureTrait, g2) = disjoint(GI.geometry(g1), GI.geometry(g2))","category":"page"},{"location":"source/methods/geom_relations/disjoint/#Point-disjoint-geometries","page":"Disjoint","title":"Point disjoint geometries","text":"","category":"section"},{"location":"source/methods/geom_relations/disjoint/","page":"Disjoint","title":"Disjoint","text":"Point is disjoint from another point if the points are not equal.","category":"page"},{"location":"source/methods/geom_relations/disjoint/","page":"Disjoint","title":"Disjoint","text":"_disjoint(\n    ::GI.PointTrait, g1,\n    ::GI.PointTrait, g2,\n) = !equals(g1, g2)","category":"page"},{"location":"source/methods/geom_relations/disjoint/","page":"Disjoint","title":"Disjoint","text":"Point is disjoint from a linestring if it is not on the line's edges/vertices.","category":"page"},{"location":"source/methods/geom_relations/disjoint/","page":"Disjoint","title":"Disjoint","text":"_disjoint(\n    ::GI.PointTrait, g1,\n    ::Union{GI.LineTrait, GI.LineStringTrait}, g2,\n) = _point_curve_process(\n    g1, g2;\n    DISJOINT_ALLOWS...,\n    closed_curve = false,\n)","category":"page"},{"location":"source/methods/geom_relations/disjoint/","page":"Disjoint","title":"Disjoint","text":"Point is disjoint from a linearring if it is not on the ring's edges/vertices.","category":"page"},{"location":"source/methods/geom_relations/disjoint/","page":"Disjoint","title":"Disjoint","text":"_disjoint(\n    ::GI.PointTrait, g1,\n    ::GI.LinearRingTrait, g2,\n) = _point_curve_process(\n    g1, g2;\n    DISJOINT_ALLOWS...,\n    closed_curve = true,\n)\n\n#= Point is disjoint from a polygon if it is not on any edges, vertices, or\nwithin the polygon's interior. =#\n_disjoint(\n    ::GI.PointTrait, g1,\n    ::GI.PolygonTrait, g2,\n) = _point_polygon_process(\n    g1, g2;\n    DISJOINT_ALLOWS...,\n)\n\n#= Geometry is disjoint from a point if the point is not in the interior or on\nthe boundary of the geometry. =#\n_disjoint(\n    trait1::Union{GI.AbstractCurveTrait, GI.PolygonTrait}, g1,\n    trait2::GI.PointTrait, g2,\n) = _disjoint(trait2, g2, trait1, g1)","category":"page"},{"location":"source/methods/geom_relations/disjoint/#Lines-disjoint-geometries","page":"Disjoint","title":"Lines disjoint geometries","text":"","category":"section"},{"location":"source/methods/geom_relations/disjoint/","page":"Disjoint","title":"Disjoint","text":"#= Linestring is disjoint from another line if they do not share any interior\nedge/vertex points or boundary points. =#\n_disjoint(\n    ::Union{GI.LineTrait, GI.LineStringTrait}, g1,\n    ::Union{GI.LineTrait, GI.LineStringTrait}, g2,\n) = _line_curve_process(\n    g1, g2;\n    DISJOINT_CURVE_ALLOWS...,\n    DISJOINT_REQUIRES...,\n    closed_line = false,\n    closed_curve = false,\n)\n\n#= Linestring is disjoint from a linearring if they do not share any interior\nedge/vertex points or boundary points. =#\n_disjoint(\n    ::Union{GI.LineTrait, GI.LineStringTrait}, g1,\n    ::GI.LinearRingTrait, g2,\n) = _line_curve_process(\n    g1, g2;\n    DISJOINT_CURVE_ALLOWS...,\n    DISJOINT_REQUIRES...,\n    closed_line = false,\n    closed_curve = true,\n)\n\n#= Linestring is disjoint from a polygon if the interior and boundary points of\nthe line are not in the polygon's interior or on the polygon's boundary. =#\n_disjoint(\n    ::Union{GI.LineTrait, GI.LineStringTrait}, g1,\n    ::GI.PolygonTrait, g2,\n) = _line_polygon_process(\n    g1, g2;\n    DISJOINT_ALLOWS...,\n    DISJOINT_REQUIRES...,\n    closed_line = false,\n)\n\n#= Geometry is disjoint from a linestring if the line's interior and boundary\npoints don't intersect with the geometrie's interior and boundary points. =#\n_disjoint(\n    trait1::Union{GI.LinearRingTrait, GI.PolygonTrait}, g1,\n    trait2::Union{GI.LineTrait, GI.LineStringTrait}, g2,\n) = _disjoint(trait2, g2, trait1, g1)","category":"page"},{"location":"source/methods/geom_relations/disjoint/#Rings-disjoint-geometries","page":"Disjoint","title":"Rings disjoint geometries","text":"","category":"section"},{"location":"source/methods/geom_relations/disjoint/","page":"Disjoint","title":"Disjoint","text":"#= Linearrings is disjoint from another linearring if they do not share any\ninterior edge/vertex points or boundary points.=#\n_disjoint(\n    ::GI.LinearRingTrait, g1,\n    ::GI.LinearRingTrait, g2,\n) = _line_curve_process(\n    g1, g2;\n    DISJOINT_CURVE_ALLOWS...,\n    DISJOINT_REQUIRES...,\n    closed_line = true,\n    closed_curve = true,\n)\n\n#= Linearring is disjoint from a polygon if the interior and boundary points of\nthe ring are not in the polygon's interior or on the polygon's boundary. =#\n_disjoint(\n    ::GI.LinearRingTrait, g1,\n    ::GI.PolygonTrait, g2,\n) = _line_polygon_process(\n    g1, g2;\n    DISJOINT_ALLOWS...,\n    DISJOINT_REQUIRES...,\n    closed_line = true,\n)","category":"page"},{"location":"source/methods/geom_relations/disjoint/#Polygon-disjoint-geometries","page":"Disjoint","title":"Polygon disjoint geometries","text":"","category":"section"},{"location":"source/methods/geom_relations/disjoint/","page":"Disjoint","title":"Disjoint","text":"#= Polygon is disjoint from another polygon if they do not share any edges or\nvertices and if their interiors do not intersect, excluding any holes. =#\n_disjoint(\n    ::GI.PolygonTrait, g1,\n    ::GI.PolygonTrait, g2,\n) = _polygon_polygon_process(\n    g1, g2;\n    DISJOINT_ALLOWS...,\n    DISJOINT_REQUIRES...,\n)","category":"page"},{"location":"source/methods/geom_relations/disjoint/#Geometries-disjoint-multi-geometry/geometry-collections","page":"Disjoint","title":"Geometries disjoint multi-geometry/geometry collections","text":"","category":"section"},{"location":"source/methods/geom_relations/disjoint/","page":"Disjoint","title":"Disjoint","text":"#= Geometry is disjoint from a multi-geometry or a collection if all of the\nelements of the collection are disjoint from the geometry. =#\nfunction _disjoint(\n    ::Union{GI.PointTrait, GI.AbstractCurveTrait, GI.PolygonTrait}, g1,\n    ::Union{\n        GI.MultiPointTrait, GI.AbstractMultiCurveTrait,\n        GI.MultiPolygonTrait, GI.GeometryCollectionTrait,\n    }, g2,\n)\n    for sub_g2 in GI.getgeom(g2)\n        !disjoint(g1, sub_g2) && return false\n    end\n    return true\nend","category":"page"},{"location":"source/methods/geom_relations/disjoint/#Multi-geometry/geometry-collections-coveredby-geometries","page":"Disjoint","title":"Multi-geometry/geometry collections coveredby geometries","text":"","category":"section"},{"location":"source/methods/geom_relations/disjoint/","page":"Disjoint","title":"Disjoint","text":"#= Multi-geometry or a geometry collection is covered by a geometry if all\nelements of the collection are covered by the geometry. =#\nfunction _disjoint(\n    ::Union{\n        GI.MultiPointTrait, GI.AbstractMultiCurveTrait,\n        GI.MultiPolygonTrait, GI.GeometryCollectionTrait,\n    }, g1,\n    ::GI.AbstractGeometryTrait, g2,\n)\n    for sub_g1 in GI.getgeom(g1)\n        !disjoint(sub_g1, g2) && return false\n    end\n    return true\nend","category":"page"},{"location":"source/methods/geom_relations/disjoint/","page":"Disjoint","title":"Disjoint","text":"","category":"page"},{"location":"source/methods/geom_relations/disjoint/","page":"Disjoint","title":"Disjoint","text":"This page was generated using Literate.jl.","category":"page"},{"location":"source/methods/geom_relations/overlaps/#Overlaps","page":"Overlaps","title":"Overlaps","text":"","category":"section"},{"location":"source/methods/geom_relations/overlaps/","page":"Overlaps","title":"Overlaps","text":"export overlaps","category":"page"},{"location":"source/methods/geom_relations/overlaps/#What-is-overlaps?","page":"Overlaps","title":"What is overlaps?","text":"","category":"section"},{"location":"source/methods/geom_relations/overlaps/","page":"Overlaps","title":"Overlaps","text":"The overlaps function checks if two geometries overlap. Two geometries can only overlap if they have the same dimension, and if they overlap, but one is not contained, within, or equal to the other.","category":"page"},{"location":"source/methods/geom_relations/overlaps/","page":"Overlaps","title":"Overlaps","text":"Note that this means it is impossible for a single point to overlap with a single point and a line only overlaps with another line if only a section of each line is colinear.","category":"page"},{"location":"source/methods/geom_relations/overlaps/","page":"Overlaps","title":"Overlaps","text":"To provide an example, consider these two lines:","category":"page"},{"location":"source/methods/geom_relations/overlaps/","page":"Overlaps","title":"Overlaps","text":"import GeometryOps as GO\nimport GeoInterface as GI\nusing Makie\nusing CairoMakie\n\nl1 = GI.LineString([(0.0, 0.0), (0.0, 10.0)])\nl2 = GI.LineString([(0.0, -10.0), (0.0, 3.0)])\nf, a, p = lines(GI.getpoint(l1), color = :blue)\nscatter!(GI.getpoint(l1), color = :blue)\nlines!(GI.getpoint(l2), color = :orange)\nscatter!(GI.getpoint(l2), color = :orange)\nf","category":"page"},{"location":"source/methods/geom_relations/overlaps/","page":"Overlaps","title":"Overlaps","text":"We can see that the two lines overlap in the plot:","category":"page"},{"location":"source/methods/geom_relations/overlaps/","page":"Overlaps","title":"Overlaps","text":"GO.overlaps(l1, l2)  # true","category":"page"},{"location":"source/methods/geom_relations/overlaps/#Implementation","page":"Overlaps","title":"Implementation","text":"","category":"section"},{"location":"source/methods/geom_relations/overlaps/","page":"Overlaps","title":"Overlaps","text":"This is the GeoInterface-compatible implementation.","category":"page"},{"location":"source/methods/geom_relations/overlaps/","page":"Overlaps","title":"Overlaps","text":"First, we implement a wrapper method that dispatches to the correct implementation based on the geometry trait. This is also used in the implementation, since it's a lot less work!","category":"page"},{"location":"source/methods/geom_relations/overlaps/","page":"Overlaps","title":"Overlaps","text":"Note that that since only elements of the same dimension can overlap, any two geometries with traits that are of different dimensions autmoatically can return false.","category":"page"},{"location":"source/methods/geom_relations/overlaps/","page":"Overlaps","title":"Overlaps","text":"For geometries with the same trait dimension, we must make sure that they share a point, an edge, or area for points, lines, and polygons/multipolygons respectivly, without being contained.","category":"page"},{"location":"source/methods/geom_relations/overlaps/","page":"Overlaps","title":"Overlaps","text":"\"\"\"\n    overlaps(geom1, geom2)::Bool\n\nCompare two Geometries of the same dimension and return true if their\nintersection set results in a geometry different from both but of the same\ndimension. This means one geometry cannot be within or contain the other and\nthey cannot be equal\n\n# Examples\n```jldoctest\nimport GeometryOps as GO, GeoInterface as GI\npoly1 = GI.Polygon([[(0,0), (0,5), (5,5), (5,0), (0,0)]])\npoly2 = GI.Polygon([[(1,1), (1,6), (6,6), (6,1), (1,1)]])\n\nGO.overlaps(poly1, poly2)","category":"page"},{"location":"source/methods/geom_relations/overlaps/","page":"Overlaps","title":"Overlaps","text":"output","category":"page"},{"location":"source/methods/geom_relations/overlaps/","page":"Overlaps","title":"Overlaps","text":"true\n```\n\"\"\"\noverlaps(geom1, geom2)::Bool = overlaps(\n    GI.trait(geom1),\n    geom1,\n    GI.trait(geom2),\n    geom2,\n)\n\n\"\"\"\n    overlaps(::GI.AbstractTrait, geom1, ::GI.AbstractTrait, geom2)::Bool\n\nFor any non-specified pair, all have non-matching dimensions, return false.\n\"\"\"\noverlaps(::GI.AbstractTrait, geom1, ::GI.AbstractTrait, geom2) = false\n\n\"\"\"\n    overlaps(\n        ::GI.MultiPointTrait, points1,\n        ::GI.MultiPointTrait, points2,\n    )::Bool\n\nIf the multipoints overlap, meaning some, but not all, of the points within the\nmultipoints are shared, return true.\n\"\"\"\nfunction overlaps(\n    ::GI.MultiPointTrait, points1,\n    ::GI.MultiPointTrait, points2,\n)\n    one_diff = false  # assume that all the points are the same\n    one_same = false  # assume that all points are different\n    for p1 in GI.getpoint(points1)\n        match_point = false\n        for p2 in GI.getpoint(points2)\n            if equals(p1, p2)  # Point is shared\n                one_same = true\n                match_point = true\n                break\n            end\n        end\n        one_diff |= !match_point  # Point isn't shared\n        one_same && one_diff && return true\n    end\n    return false\nend\n\n\"\"\"\n    overlaps(::GI.LineTrait, line1, ::GI.LineTrait, line)::Bool\n\nIf the lines overlap, meaning that they are colinear but each have one endpoint\noutside of the other line, return true. Else false.\n\"\"\"\noverlaps(::GI.LineTrait, line1, ::GI.LineTrait, line) =\n    _overlaps((a1, a2), (b1, b2))\n\n\"\"\"\n    overlaps(\n        ::Union{GI.LineStringTrait, GI.LinearRing}, line1,\n        ::Union{GI.LineStringTrait, GI.LinearRing}, line2,\n    )::Bool\n\nIf the curves overlap, meaning that at least one edge of each curve overlaps,\nreturn true. Else false.\n\"\"\"\nfunction overlaps(\n    ::Union{GI.LineStringTrait, GI.LinearRing}, line1,\n    ::Union{GI.LineStringTrait, GI.LinearRing}, line2,\n)\n    edges_a, edges_b = map(sort! ∘ to_edges, (line1, line2))\n    for edge_a in edges_a\n        for edge_b in edges_b\n            _overlaps(edge_a, edge_b) && return true\n        end\n    end\n    return false\nend\n\n\"\"\"\n    overlaps(\n        trait_a::GI.PolygonTrait, poly_a,\n        trait_b::GI.PolygonTrait, poly_b,\n    )::Bool\n\nIf the two polygons intersect with one another, but are not equal, return true.\nElse false.\n\"\"\"\nfunction overlaps(\n    trait_a::GI.PolygonTrait, poly_a,\n    trait_b::GI.PolygonTrait, poly_b,\n)\n    edges_a, edges_b = map(sort! ∘ to_edges, (poly_a, poly_b))\n    return _edge_intersects(edges_a, edges_b) &&\n        !equals(trait_a, poly_a, trait_b, poly_b)\nend\n\n\"\"\"\n    overlaps(\n        ::GI.PolygonTrait, poly1,\n        ::GI.MultiPolygonTrait, polys2,\n    )::Bool\n\nReturn true if polygon overlaps with at least one of the polygons within the\nmultipolygon. Else false.\n\"\"\"\nfunction overlaps(\n    ::GI.PolygonTrait, poly1,\n    ::GI.MultiPolygonTrait, polys2,\n)\n    for poly2 in GI.getgeom(polys2)\n        overlaps(poly1, poly2) && return true\n    end\n    return false\nend\n\n\"\"\"\n    overlaps(\n        ::GI.MultiPolygonTrait, polys1,\n        ::GI.PolygonTrait, poly2,\n    )::Bool\n\nReturn true if polygon overlaps with at least one of the polygons within the\nmultipolygon. Else false.\n\"\"\"\noverlaps(trait1::GI.MultiPolygonTrait, polys1, trait2::GI.PolygonTrait, poly2) =\n    overlaps(trait2, poly2, trait1, polys1)\n\n\"\"\"\n    overlaps(\n        ::GI.MultiPolygonTrait, polys1,\n        ::GI.MultiPolygonTrait, polys2,\n    )::Bool\n\nReturn true if at least one pair of polygons from multipolygons overlap. Else\nfalse.\n\"\"\"\nfunction overlaps(\n    ::GI.MultiPolygonTrait, polys1,\n    ::GI.MultiPolygonTrait, polys2,\n)\n    for poly1 in GI.getgeom(polys1)\n        overlaps(poly1, polys2) && return true\n    end\n    return false\nend\n\n#= If the edges overlap, meaning that they are colinear but each have one endpoint\noutside of the other edge, return true. Else false. =#\nfunction _overlaps(\n    (a1, a2)::Edge,\n    (b1, b2)::Edge\n)","category":"page"},{"location":"source/methods/geom_relations/overlaps/","page":"Overlaps","title":"Overlaps","text":"meets in more than one point","category":"page"},{"location":"source/methods/geom_relations/overlaps/","page":"Overlaps","title":"Overlaps","text":"    on_top = ExactPredicates.meet(a1, a2, b1, b2) == 0","category":"page"},{"location":"source/methods/geom_relations/overlaps/","page":"Overlaps","title":"Overlaps","text":"one end point is outside of other segment","category":"page"},{"location":"source/methods/geom_relations/overlaps/","page":"Overlaps","title":"Overlaps","text":"    a_fully_within = _point_on_seg(a1, b1, b2) && _point_on_seg(a2, b1, b2)\n    b_fully_within = _point_on_seg(b1, a1, a2) && _point_on_seg(b2, a1, a2)\n    return on_top && (!a_fully_within && !b_fully_within)\nend\n\n#= TODO: Once overlaps is swapped over to use the geom relations workflow, can\ndelete these helpers. =#","category":"page"},{"location":"source/methods/geom_relations/overlaps/","page":"Overlaps","title":"Overlaps","text":"Checks it vectors of edges intersect","category":"page"},{"location":"source/methods/geom_relations/overlaps/","page":"Overlaps","title":"Overlaps","text":"function _edge_intersects(\n    edges_a::Vector{Edge},\n    edges_b::Vector{Edge}\n)","category":"page"},{"location":"source/methods/geom_relations/overlaps/","page":"Overlaps","title":"Overlaps","text":"Extents.intersects(toextent(edgesa), toextent(edgesb)) || return false","category":"page"},{"location":"source/methods/geom_relations/overlaps/","page":"Overlaps","title":"Overlaps","text":"    for edge_a in edges_a\n        for edge_b in edges_b\n            _edge_intersects(edge_a, edge_b) && return true\n        end\n    end\n    return false\nend","category":"page"},{"location":"source/methods/geom_relations/overlaps/","page":"Overlaps","title":"Overlaps","text":"Checks if two edges intersect","category":"page"},{"location":"source/methods/geom_relations/overlaps/","page":"Overlaps","title":"Overlaps","text":"function _edge_intersects(edge_a::Edge, edge_b::Edge)\n    meet_type = ExactPredicates.meet(edge_a..., edge_b...)\n    return meet_type == 0 || meet_type == 1\nend","category":"page"},{"location":"source/methods/geom_relations/overlaps/","page":"Overlaps","title":"Overlaps","text":"Checks if point is on a segment","category":"page"},{"location":"source/methods/geom_relations/overlaps/","page":"Overlaps","title":"Overlaps","text":"function _point_on_seg(point, start, stop)","category":"page"},{"location":"source/methods/geom_relations/overlaps/","page":"Overlaps","title":"Overlaps","text":"Parse out points","category":"page"},{"location":"source/methods/geom_relations/overlaps/","page":"Overlaps","title":"Overlaps","text":"    x, y = GI.x(point), GI.y(point)\n    x1, y1 = GI.x(start), GI.y(start)\n    x2, y2 = GI.x(stop), GI.y(stop)\n    Δxl = x2 - x1\n    Δyl = y2 - y1","category":"page"},{"location":"source/methods/geom_relations/overlaps/","page":"Overlaps","title":"Overlaps","text":"Determine if point is on segment","category":"page"},{"location":"source/methods/geom_relations/overlaps/","page":"Overlaps","title":"Overlaps","text":"    cross = (x - x1) * Δyl - (y - y1) * Δxl\n    if cross == 0  # point is on line extending to infinity","category":"page"},{"location":"source/methods/geom_relations/overlaps/","page":"Overlaps","title":"Overlaps","text":"is line between endpoints","category":"page"},{"location":"source/methods/geom_relations/overlaps/","page":"Overlaps","title":"Overlaps","text":"        if abs(Δxl) >= abs(Δyl)  # is line between endpoints\n            return Δxl > 0 ? x1 <= x <= x2 : x2 <= x <= x1\n        else\n            return Δyl > 0 ? y1 <= y <= y2 : y2 <= y <= y1\n        end\n    end\n    return false\nend","category":"page"},{"location":"source/methods/geom_relations/overlaps/","page":"Overlaps","title":"Overlaps","text":"","category":"page"},{"location":"source/methods/geom_relations/overlaps/","page":"Overlaps","title":"Overlaps","text":"This page was generated using Literate.jl.","category":"page"},{"location":"source/methods/angles/#Angles","page":"Angles","title":"Angles","text":"","category":"section"},{"location":"source/methods/angles/","page":"Angles","title":"Angles","text":"export angles","category":"page"},{"location":"source/methods/angles/#What-is-angles?","page":"Angles","title":"What is angles?","text":"","category":"section"},{"location":"source/methods/angles/","page":"Angles","title":"Angles","text":"Angles are the angles formed by a given geometries line segments, if it has line segments.","category":"page"},{"location":"source/methods/angles/","page":"Angles","title":"Angles","text":"To provide an example, consider this rectangle:","category":"page"},{"location":"source/methods/angles/","page":"Angles","title":"Angles","text":"import GeometryOps as GO\nimport GeoInterface as GI\nusing Makie, CairoMakie\n\nrect = GI.Polygon([[(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0)]])\nf, a, p = poly(collect(GI.getpoint(rect)); axis = (; aspect = DataAspect()))","category":"page"},{"location":"source/methods/angles/","page":"Angles","title":"Angles","text":"This is clearly a rectangle, with angles of 90 degrees.","category":"page"},{"location":"source/methods/angles/","page":"Angles","title":"Angles","text":"GO.angles(rect)  # [90, 90, 90, 90]","category":"page"},{"location":"source/methods/angles/#Implementation","page":"Angles","title":"Implementation","text":"","category":"section"},{"location":"source/methods/angles/","page":"Angles","title":"Angles","text":"This is the GeoInterface-compatible implementation. First, we implement a wrapper method that dispatches to the correct implementation based on the geometry trait. This is also used in the implementation, since it's a lot less work!","category":"page"},{"location":"source/methods/angles/","page":"Angles","title":"Angles","text":"const _ANGLE_TARGETS = Union{GI.PolygonTrait,GI.AbstractCurveTrait,GI.MultiPointTrait,GI.PointTrait}\n\n\"\"\"\n    angles(geom, ::Type{T} = Float64)\n\nReturns the angles of a geometry or collection of geometries.\nThis is computed differently for different geometries:\n\n    - The angles of a point is an empty vector.\n    - The angles of a single line segment is an empty vector.\n    - The angles of a linestring or linearring is a vector of angles formed by the curve.\n    - The angles of a polygin is a vector of vectors of angles formed by each ring.\n    - The angles of a multi-geometry collection is a vector of the angles of each of the\n        sub-geometries as defined above.\n\nResult will be a Vector, or nested set of vectors, of type T where an optional argument with\na default value of Float64.\n\"\"\"\nfunction angles(geom, ::Type{T} = Float64; threaded =false) where T <: AbstractFloat\n    applyreduce(vcat, _ANGLE_TARGETS, geom; threaded, init = Vector{T}()) do g\n        _angles(T, GI.trait(g), g)\n    end\nend","category":"page"},{"location":"source/methods/angles/","page":"Angles","title":"Angles","text":"Points and single line segments have no angles","category":"page"},{"location":"source/methods/angles/","page":"Angles","title":"Angles","text":"_angles(::Type{T}, ::Union{GI.PointTrait, GI.MultiPointTrait, GI.LineTrait}, geom) where T = T[]\n\n#= The angles of a linestring are the angles formed by the line. If the first and last point\nare not explicitly repeated, the geom is not considered closed. The angles should all be on\none side of the line, but a particular side is not guaranteed by this function. =#\nfunction _angles(::Type{T}, ::GI.LineStringTrait, geom) where T\n    npoints = GI.npoint(geom)\n    first_last_equal = equals(GI.getpoint(geom, 1), GI.getpoint(geom, npoints))\n    angle_list = Vector{T}(undef, npoints - (first_last_equal ? 1 : 2))\n    _find_angles!(\n        T, angle_list, geom;\n        offset = first_last_equal, close_geom = false,\n    )\n    return angle_list\nend\n\n#= The angles of a linearring are the angles within the closed line and include the angles\nformed by connecting the first and last points of the curve. =#\nfunction _angles(::Type{T}, ::GI.LinearRingTrait, geom; interior = true) where T\n    npoints = GI.npoint(geom)\n    first_last_equal = equals(GI.getpoint(geom, 1), GI.getpoint(geom, npoints))\n    angle_list = Vector{T}(undef, npoints - (first_last_equal ? 1 : 0))\n    _find_angles!(\n        T, angle_list, geom;\n        offset = true, close_geom = !first_last_equal, interior = interior,\n    )\n    return angle_list\nend\n\n#= The angles of a polygon is a vector of polygon angles. Note that if there are holes\nwithin the polyogn, the angles will be listed after the exterior ring angles in order of the\nholes. All angles, including the hole angles, are interior angles of the polygon.=#\nfunction _angles(::Type{T}, ::GI.PolygonTrait, geom) where T\n    angles = _angles(T, GI.LinearRingTrait(), GI.getexterior(geom); interior = true)\n    for h in GI.gethole(geom)\n        append!(angles, _angles(T, GI.LinearRingTrait(), h; interior = false))\n    end\n    return angles\nend","category":"page"},{"location":"source/methods/angles/","page":"Angles","title":"Angles","text":"Find angles of a curve and insert the values into the anglelist. If offset is true, then save space for the angle at the first vertex, as the curve is closed, at the front of anglelist. If closegeom is true, then despite the first and last point not being explicitly repeated, the curve is closed and the angle of the last point should be added to anglelist. If interior is true, then all angles will be on the same side of the line","category":"page"},{"location":"source/methods/angles/","page":"Angles","title":"Angles","text":"function _find_angles!(\n    ::Type{T}, angle_list, geom;\n    offset, close_geom, interior = true,\n) where T\n    local p1, prev_p1_diff, p2_p1_diff\n    local start_point, start_diff\n    local extreem_idx, extreem_x, extreem_y\n    i_offset = offset ? 1 : 0","category":"page"},{"location":"source/methods/angles/","page":"Angles","title":"Angles","text":"Loop through the curve and find each of the angels","category":"page"},{"location":"source/methods/angles/","page":"Angles","title":"Angles","text":"    for (i, p2) in enumerate(GI.getpoint(geom))\n        xp2, yp2 = GI.x(p2), GI.y(p2)\n        #= Find point with smallest x values (and smallest y in case of a tie) as this point\n        is know to be convex. =#\n        if i == 1 || (xp2 < extreem_x || (xp2 == extreem_x && yp2 < extreem_y))\n            extreem_idx = i\n            extreem_x, extreem_y = xp2, yp2\n        end\n        if i > 1\n            p2_p1_diff = (xp2 - GI.x(p1), yp2 - GI.y(p1))\n            if i == 2\n                start_point = p1\n                start_diff = p2_p1_diff\n            else\n                angle_list[i - 2 + i_offset] = _diffs_calc_angle(T, prev_p1_diff, p2_p1_diff)\n            end\n            prev_p1_diff = -1 .* p2_p1_diff\n        end\n        p1 = p2\n    end","category":"page"},{"location":"source/methods/angles/","page":"Angles","title":"Angles","text":"If the last point of geometry should be the same as the first, calculate closing angle","category":"page"},{"location":"source/methods/angles/","page":"Angles","title":"Angles","text":"    if close_geom\n        p2_p1_diff = (GI.x(start_point) - GI.x(p1), GI.y(start_point) - GI.y(p1))\n        angle_list[end] = _diffs_calc_angle(T, prev_p1_diff, p2_p1_diff)\n        prev_p1_diff = -1 .* p2_p1_diff\n    end","category":"page"},{"location":"source/methods/angles/","page":"Angles","title":"Angles","text":"If needed, calculate first angle corresponding to the first point","category":"page"},{"location":"source/methods/angles/","page":"Angles","title":"Angles","text":"    if offset\n        angle_list[1] = _diffs_calc_angle(T, prev_p1_diff, start_diff)\n    end\n    #= Make sure that all of the angles are on the same side of the line and inside of the\n    closed ring if the input geometry is closed. =#\n    inside_sgn = sign(angle_list[extreem_idx]) * (interior ? 1 : -1)\n    for i in eachindex(angle_list)\n        idx_sgn = sign(angle_list[i])\n        if idx_sgn == -1\n            angle_list[i] = abs(angle_list[i])\n        end\n        if idx_sgn != inside_sgn\n            angle_list[i] = 360 - angle_list[i]\n        end\n    end\n    return\nend","category":"page"},{"location":"source/methods/angles/","page":"Angles","title":"Angles","text":"Calculate the angle between two vectors defined by the previous and current Δx and Δys. Angle will have a sign corresponding to the sign of the cross product between the two vectors. All angles of one sign in a given geometry are convex, while those of the other sign are concave. However, the sign corresponding to each of these can vary based on geometry and thus you must compare to an angle that is know to be convex or concave.","category":"page"},{"location":"source/methods/angles/","page":"Angles","title":"Angles","text":"function _diffs_calc_angle(::Type{T}, (Δx_prev, Δy_prev), (Δx_curr, Δy_curr)) where T\n    cross_prod = Δx_prev * Δy_curr - Δy_prev * Δx_curr\n    dot_prod = Δx_prev * Δx_curr + Δy_prev * Δy_curr\n    prev_mag = max(sqrt(Δx_prev^2 + Δy_prev^2), eps(T))\n    curr_mag = max(sqrt(Δx_curr^2 + Δy_curr^2), eps(T))\n    val = clamp(dot_prod / (prev_mag * curr_mag), -one(T), one(T))\n    angle = real(acos(val) * 180 / π)\n    return angle * (cross_prod < 0 ? -1 : 1)\nend","category":"page"},{"location":"source/methods/angles/","page":"Angles","title":"Angles","text":"","category":"page"},{"location":"source/methods/angles/","page":"Angles","title":"Angles","text":"This page was generated using Literate.jl.","category":"page"},{"location":"source/methods/clipping/clipping_processor/#Polygon-clipping-helpers","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"","category":"section"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"This file contains the shared helper functions for the polygon clipping functionalities.","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"#= This is the struct that makes up a_list and b_list. Many values are only used if point is\nan intersection point (ipt). =#\nstruct PolyNode{T <: AbstractFloat}\n    idx::Int           # If ipt, index of point in a_idx_list, else 0\n    point::Tuple{T,T}  # (x, y) values of given point\n    inter::Bool        # If ipt, true, else 0\n    neighbor::Int      # If ipt, index of equivalent point in a_list or b_list, else 0\n    ent_exit::Bool     # If ipt, true if enter and false if exit, else false\n    fracs::Tuple{T,T}  # If ipt, fractions along edges to ipt (a_frac, b_frac), else (0, 0)\nend","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"_build_ab_list(::Type{T}, poly_a, poly_b) -> (a_list, b_list, a_idx_list)","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"This function takes in two polygon rings and calls 'buildalist', 'buildblist', and 'flagentexit' in order to fully form alist and blist. The 'alist' and 'blist' that it returns are the fully updated vectors of PolyNodes that represent the rings 'polya' and 'polyb', respectively. This function also returns 'aidxlist', which at its \"ith\" index stores the index in 'alist' at which the \"ith\" intersection point lies.","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"function _build_ab_list(::Type{T}, poly_a, poly_b) where T","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"Make a list for nodes of each polygon","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"    a_list, a_idx_list = _build_a_list(T, poly_a, poly_b)\n    b_list = _build_b_list(T, a_idx_list, a_list, poly_b)","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"Flag the entry and exits","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"    _flag_ent_exit!(poly_b, a_list)\n    _flag_ent_exit!(poly_a, b_list)\n\n    return a_list, b_list, a_idx_list\nend","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"_build_a_list(::Type{T}, poly_a, poly_b) -> (a_list, a_idx_list)","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"This function take in two polygon rings and creates a vector of PolyNodes to represent polya, including its intersection points with polyb. The information stored in each PolyNode is needed for clipping using the Greiner-Hormann clipping algorithm.","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"Note: After calling this function, alist is not fully formed because the neighboring indicies of the intersection points in blist still need to be updated. Also we still have not update the entry and exit flags for a_list.","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"The aidxlist is a list of the indicies of intersection points in alist. The value at index i of aidxlist is the location in alist where the ith intersection point lies.","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"function _build_a_list(::Type{T}, poly_a, poly_b) where T\n    n_a_edges = _nedge(poly_a)\n    a_list = Vector{PolyNode{T}}(undef, n_a_edges)  # list of points in poly_a\n    a_idx_list = Vector{Int}()  # finds indices of intersection points in a_list\n    intr_count = 0  # number of intersection points found\n    a_count = 0  # number of points added to a_list","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"Loop through points of poly_a","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"    local a_pt1\n    for (i, a_p2) in enumerate(GI.getpoint(poly_a))\n        a_pt2 = (T(GI.x(a_p2)), T(GI.y(a_p2)))\n        if i <= 1\n            a_pt1 = a_pt2\n            continue\n        end","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"Add the first point of the edge to the list of points in a_list","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"        new_point = PolyNode(0, a_pt1, false, 0, false, (zero(T), zero(T)))\n        a_count += 1\n        _add!(a_list, a_count, new_point, n_a_edges)","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"Find intersections with edges of poly_b","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"        local b_pt1\n        prev_counter = intr_count\n        for (j, b_p2) in enumerate(GI.getpoint(poly_b))\n            b_pt2 = _tuple_point(b_p2)\n            if j <=1\n                b_pt1 = b_pt2\n                continue\n            end\n            int_pt, fracs = _intersection_point(T, (a_pt1, a_pt2), (b_pt1, b_pt2))","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"if no intersection point, skip this edge","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"            if !isnothing(int_pt) && all(0 .≤ fracs .≤ 1)","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"Set neighbor field to b edge (j-1) to keep track of intersection","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"                new_intr = PolyNode(intr_count, int_pt, true, j - 1, false, fracs)\n                a_count += 1\n                intr_count += 1\n                _add!(a_list, a_count, new_intr, n_a_edges)\n                push!(a_idx_list, a_count)\n            end\n            b_pt1 = b_pt2\n        end","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"Order intersection points by placement along edge using fracs value","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"        if prev_counter < intr_count\n            Δintrs = intr_count - prev_counter\n            inter_points = @view a_list[(a_count - Δintrs + 1):a_count]\n            sort!(inter_points, by = x -> x.fracs[1])\n            for (i, p) in enumerate(inter_points)\n                inter_points[i] = PolyNode(prev_counter + i, p.point, p.inter, p.neighbor, p.ent_exit, p.fracs)\n            end\n        end\n\n        a_pt1 = a_pt2\n    end\n    return a_list, a_idx_list\nend","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"Add value x at index i to given array - if list isn't long enough, push value to array","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"function _add!(arr, i, x, l = length(arr))\n    if i <= l\n        arr[i] = x\n    else\n        push!(arr, x)\n    end\n    return\nend","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"_build_b_list(::Type{T}, a_idx_list, a_list, poly_b) -> b_list","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"This function takes in the alist and aidxlist build in _buildalist and polyb and creates a vector of PolyNodes to represent poly_b. The information stored in each PolyNode is needed for clipping using the Greiner-Hormann clipping algorithm.","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"Note: after calling this function, blist is not fully updated. The entry/exit flags still need to be updated. However, the neightbor value in alist is now updated.","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"function _build_b_list(::Type{T}, a_idx_list, a_list, poly_b) where T","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"Sort intersection points by insertion order in b_list","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"    sort!(a_idx_list, by = x-> a_list[x].neighbor + a_list[x].fracs[2])","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"Initialize needed values and lists","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"    n_b_edges = _nedge(poly_b)\n    n_intr_pts = length(a_idx_list)\n    b_list = Vector{PolyNode{T}}(undef, n_b_edges + n_intr_pts)\n    intr_curr = 1\n    b_count = 0","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"Loop over points in poly_b and add each point and intersection point","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"    for (i, p) in enumerate(GI.getpoint(poly_b))\n        (i == n_b_edges + 1) && break\n        b_count += 1\n        pt = (T(GI.x(p)), T(GI.y(p)))\n        b_list[b_count] = PolyNode(0, pt, false, 0, false, (zero(T), zero(T)))\n        if intr_curr ≤ n_intr_pts\n            curr_idx = a_idx_list[intr_curr]\n            curr_node = a_list[curr_idx]\n            while curr_node.neighbor == i  # Add all intersection points in current edge\n                b_count += 1\n                b_list[b_count] = PolyNode(curr_node.idx, curr_node.point, true, curr_idx, false, curr_node.fracs)\n                a_list[curr_idx] = PolyNode(curr_node.idx, curr_node.point, curr_node.inter, b_count, curr_node.ent_exit, curr_node.fracs)\n                curr_node = a_list[curr_idx]\n                intr_curr += 1\n                intr_curr > n_intr_pts && break\n                curr_idx = a_idx_list[intr_curr]\n                curr_node = a_list[curr_idx]\n            end\n        end\n    end\n    sort!(a_idx_list)  # return a_idx_list to order of points in a_list\n    return b_list\nend","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"_flag_ent_exit(poly_b, a_list)","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"This function flags all the intersection points as either an 'entry' or 'exit' point in relation to the given polygon.","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"function _flag_ent_exit!(poly, pt_list)\n    local status\n    for ii in eachindex(pt_list)\n        if ii == 1\n            status = !_point_filled_curve_orientation(\n                pt_list[ii].point, poly;\n                in = true, on = false, out = false\n            )\n        elseif pt_list[ii].inter\n            pt_list[ii] = PolyNode(pt_list[ii].idx, pt_list[ii].point, pt_list[ii].inter, pt_list[ii].neighbor, status, pt_list[ii].fracs)\n            status = !status\n        end\n    end\n    return\nend","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"_trace_polynodes(::Type{T}, a_list, b_list, a_idx_list, f_step)::Vector{GI.Polygon}","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"This function takes the outputs of buildablist and traces the lists to determine which polygons are formed as described in Greiner and Hormann. The function fstep determines in which direction the lists are traced.  This function is different for intersection, difference, and union. fstep must take in two arguments: the most recent intersection node's entry/exit status and a boolean that is true if we are currently tracing alist and false if we are tracing b_list. The functions used for each clipping operation are follows:     - Intersection: (x, y) -> x ? 1 : (-1)     - Difference: (x, y) -> (x ⊻ y) ? 1 : (-1)     - Union: (x, y) -> (x ⊻ y) ? 1 : (-1)","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"A list of GeoInterface polygons is returned from this function.","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"function _trace_polynodes(::Type{T}, a_list, b_list, a_idx_list, f_step) where T\n    n_a_pts, n_b_pts = length(a_list), length(b_list)\n    n_intr_pts = length(a_idx_list)\n    return_polys = Vector{_get_poly_type(T)}(undef, 0)","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"Keep track of number of processed intersection points","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"    processed_pts = 0\n    while processed_pts < n_intr_pts\n        curr_list, curr_npoints = a_list, n_a_pts\n        on_a_list = true","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"Find first unprocessed intersecting point in subject polygon","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"        processed_pts += 1\n        first_idx = findnext(x -> x != 0, a_idx_list, processed_pts)\n        idx = a_idx_list[first_idx]\n        a_idx_list[first_idx] = 0\n        start_pt = a_list[idx]","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"Set first point in polygon","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"        curr = curr_list[idx]\n        pt_list = [curr.point]\n\n        curr_not_start = true\n        while curr_not_start\n            step = f_step(curr.ent_exit, on_a_list)\n            curr_not_intr = true\n            while curr_not_intr","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"Traverse polygon either forwards or backwards","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"                idx += step\n                idx = (idx > curr_npoints) ? mod(idx, curr_npoints) : idx\n                idx = (idx == 0) ? curr_npoints : idx","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"Get current node and add to pt_list","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"                curr = curr_list[idx]\n                push!(pt_list, curr.point)\n                if curr.inter","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"Keep track of processed intersection points","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"                    curr_not_start = curr != start_pt && curr != b_list[start_pt.neighbor]\n                    if curr_not_start\n                        processed_pts += 1\n                        a_idx_list[curr.idx] = 0\n                    end\n                    curr_not_intr = false\n                end\n            end","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"Switch to next list and next point","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"            curr_list, curr_npoints = on_a_list ? (b_list, n_b_pts) : (a_list, n_a_pts)\n            on_a_list = !on_a_list\n            idx = curr.neighbor\n            curr = curr_list[idx]\n        end\n        push!(return_polys, GI.Polygon([pt_list]))\n    end\n    return return_polys\nend","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"Get type of polygons that will be made TODO: Increase type options","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"_get_poly_type(::Type{T}) where T =\n    GI.Polygon{false, false, Vector{GI.LinearRing{false, false, Vector{Tuple{T, T}}, Nothing, Nothing}}, Nothing, Nothing}","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"_add_holes_to_polys!(::Type{T}, return_polys, hole_iterator)","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"The holes specified by the hole iterator are added to the polygons in the return_polys list. If this creates more polygon, they are added to the end of the list. If this removes polygons, they are removed from the list","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"function _add_holes_to_polys!(::Type{T}, return_polys, hole_iterator) where T\n    n_polys = length(return_polys)","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"Remove set of holes from all polygons","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"    for i in 1:n_polys\n        n_new_per_poly = 0\n        for hole in hole_iterator  # loop through all holes\n            hole_poly = GI.Polygon([hole])","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"loop through all pieces of original polygon (new pieces added to end of list)","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"            for j in Iterators.flatten((i:i, (n_polys + 1):(n_polys + n_new_per_poly)))\n                if !isnothing(return_polys[j])\n                    new_polys = difference(return_polys[j], hole_poly, T; target = GI.PolygonTrait)\n                    n_new_polys = length(new_polys)\n                    if n_new_polys == 0  # hole covered whole polygon\n                        return_polys[j] = nothing\n                    else\n                        return_polys[j] = new_polys[1]  # replace original\n                        if n_new_polys > 1  # add any extra pieces\n                            append!(return_polys, @view new_polys[2:end])\n                            n_new_per_poly += n_new_polys - 1\n                        end\n                    end\n                end\n            end\n        end\n        n_polys += n_new_per_poly\n    end","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"Remove all polygon that were marked for removal","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"    filter!(!isnothing, return_polys)\n    return\nend","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"","category":"page"},{"location":"source/methods/clipping/clipping_processor/","page":"Polygon clipping helpers","title":"Polygon clipping helpers","text":"This page was generated using Literate.jl.","category":"page"},{"location":"source/methods/centroid/#Centroid","page":"Centroid","title":"Centroid","text":"","category":"section"},{"location":"source/methods/centroid/","page":"Centroid","title":"Centroid","text":"export centroid, centroid_and_length, centroid_and_area","category":"page"},{"location":"source/methods/centroid/#What-is-the-centroid?","page":"Centroid","title":"What is the centroid?","text":"","category":"section"},{"location":"source/methods/centroid/","page":"Centroid","title":"Centroid","text":"The centroid is the geometric center of a line string or area(s). Note that the centroid does not need to be inside of a concave area.","category":"page"},{"location":"source/methods/centroid/","page":"Centroid","title":"Centroid","text":"Further note that by convention a line, or linear ring, is calculated by weighting the line segments by their length, while polygons and multipolygon centroids are calculated by weighting edge's by their 'area components'.","category":"page"},{"location":"source/methods/centroid/","page":"Centroid","title":"Centroid","text":"To provide an example, consider this concave polygon in the shape of a 'C':","category":"page"},{"location":"source/methods/centroid/","page":"Centroid","title":"Centroid","text":"import GeometryOps as GO\nimport GeoInterface as GI\nusing Makie\nusing CairoMakie\n\ncshape = GI.Polygon([[(0,0), (0,3), (3,3), (3,2), (1,2), (1,1), (3,1), (3,0), (0,0)]])\nf, a, p = poly(collect(GI.getpoint(cshape)); axis = (; aspect = DataAspect()))","category":"page"},{"location":"source/methods/centroid/","page":"Centroid","title":"Centroid","text":"Let's see what the centroid looks like (plotted in red):","category":"page"},{"location":"source/methods/centroid/","page":"Centroid","title":"Centroid","text":"cent = GO.centroid(cshape)\nscatter!(GI.x(cent), GI.y(cent), color = :red)\nf","category":"page"},{"location":"source/methods/centroid/#Implementation","page":"Centroid","title":"Implementation","text":"","category":"section"},{"location":"source/methods/centroid/","page":"Centroid","title":"Centroid","text":"This is the GeoInterface-compatible implementation.","category":"page"},{"location":"source/methods/centroid/","page":"Centroid","title":"Centroid","text":"First, we implement a wrapper method that dispatches to the correct implementation based on the geometry trait. This is also used in the implementation, since it's a lot less work!","category":"page"},{"location":"source/methods/centroid/","page":"Centroid","title":"Centroid","text":"Note that if you call centroid on a LineString or LinearRing, the centroidandlength function will be called due to the weighting scheme described above, while centroidandarea is called for polygons and multipolygons. However, centroidandarea can still be called on a LineString or LinearRing when they are closed, for example as the interior hole of a polygon.","category":"page"},{"location":"source/methods/centroid/","page":"Centroid","title":"Centroid","text":"The helper functions centroidandlength and centroidandarea are made availible just in case the user also needs the area or length to decrease repeat computation.","category":"page"},{"location":"source/methods/centroid/","page":"Centroid","title":"Centroid","text":"\"\"\"\n    centroid(geom, [T=Float64])::Tuple{T, T}\n\nReturns the centroid of a given line segment, linear ring, polygon, or\nmutlipolygon.\n\"\"\"\ncentroid(geom, ::Type{T} = Float64; threaded=false) where T =\n    centroid(GI.trait(geom), geom, T; threaded)\nfunction centroid(\n    trait::Union{GI.LineStringTrait, GI.LinearRingTrait}, geom, ::Type{T}=Float64; threaded=false\n) where T\n    centroid_and_length(trait, geom, T)[1]\nend\ncentroid(trait, geom, ::Type{T}; threaded=false) where T =\n    centroid_and_area(geom, T; threaded)[1]\n\n\"\"\"\n    centroid_and_length(geom, [T=Float64])::(::Tuple{T, T}, ::Real)\n\nReturns the centroid and length of a given line/ring. Note this is only valid\nfor line strings and linear rings.\n\"\"\"\ncentroid_and_length(geom, ::Type{T}=Float64) where T =\n    centroid_and_length(GI.trait(geom), geom, T)\nfunction centroid_and_length(\n    ::Union{GI.LineStringTrait, GI.LinearRingTrait}, geom, ::Type{T},\n) where T","category":"page"},{"location":"source/methods/centroid/","page":"Centroid","title":"Centroid","text":"Initialize starting values","category":"page"},{"location":"source/methods/centroid/","page":"Centroid","title":"Centroid","text":"    xcentroid = T(0)\n    ycentroid = T(0)\n    length = T(0)\n    point₁ = GI.getpoint(geom, 1)","category":"page"},{"location":"source/methods/centroid/","page":"Centroid","title":"Centroid","text":"Loop over line segments of line string","category":"page"},{"location":"source/methods/centroid/","page":"Centroid","title":"Centroid","text":"    for point₂ in GI.getpoint(geom)","category":"page"},{"location":"source/methods/centroid/","page":"Centroid","title":"Centroid","text":"Calculate length of line segment","category":"page"},{"location":"source/methods/centroid/","page":"Centroid","title":"Centroid","text":"        length_component = sqrt(\n            (GI.x(point₂) - GI.x(point₁))^2 +\n            (GI.y(point₂) - GI.y(point₁))^2\n        )","category":"page"},{"location":"source/methods/centroid/","page":"Centroid","title":"Centroid","text":"Accumulate the line segment length into length","category":"page"},{"location":"source/methods/centroid/","page":"Centroid","title":"Centroid","text":"        length += length_component","category":"page"},{"location":"source/methods/centroid/","page":"Centroid","title":"Centroid","text":"Weighted average of line segment centroids","category":"page"},{"location":"source/methods/centroid/","page":"Centroid","title":"Centroid","text":"        xcentroid += (GI.x(point₁) + GI.x(point₂)) * (length_component / 2)\n        ycentroid += (GI.y(point₁) + GI.y(point₂)) * (length_component / 2)\n        #centroid = centroid .+ ((point₁ .+ point₂) .* (length_component / 2))","category":"page"},{"location":"source/methods/centroid/","page":"Centroid","title":"Centroid","text":"Advance the point buffer by 1 point to move to next line segment","category":"page"},{"location":"source/methods/centroid/","page":"Centroid","title":"Centroid","text":"        point₁ = point₂\n    end\n    xcentroid /= length\n    ycentroid /= length\n    return (xcentroid, ycentroid), length\nend\n\n\"\"\"\n    centroid_and_area(geom, [T=Float64])::(::Tuple{T, T}, ::Real)\n\nReturns the centroid and area of a given geometry.\n\"\"\"\nfunction centroid_and_area(geom, ::Type{T}=Float64; threaded=false) where T\n    target = Union{GI.PolygonTrait,GI.LineStringTrait,GI.LinearRingTrait}\n    init = (zero(T), zero(T)), zero(T)\n    applyreduce(_combine_centroid_and_area, target, geom; threaded, init) do g\n        _centroid_and_area(GI.trait(g), g, T)\n    end\nend\n\nfunction _centroid_and_area(\n    ::Union{GI.LineStringTrait, GI.LinearRingTrait}, geom, ::Type{T}\n) where T","category":"page"},{"location":"source/methods/centroid/","page":"Centroid","title":"Centroid","text":"Check that the geometry is closed","category":"page"},{"location":"source/methods/centroid/","page":"Centroid","title":"Centroid","text":"    @assert(\n        GI.getpoint(geom, 1) == GI.getpoint(geom, GI.ngeom(geom)),\n        \"centroid_and_area should only be used with closed geometries\"\n    )","category":"page"},{"location":"source/methods/centroid/","page":"Centroid","title":"Centroid","text":"Initialize starting values","category":"page"},{"location":"source/methods/centroid/","page":"Centroid","title":"Centroid","text":"    xcentroid = T(0)\n    ycentroid = T(0)\n    area = T(0)\n    point₁ = GI.getpoint(geom, 1)","category":"page"},{"location":"source/methods/centroid/","page":"Centroid","title":"Centroid","text":"Loop over line segments of linear ring","category":"page"},{"location":"source/methods/centroid/","page":"Centroid","title":"Centroid","text":"    for point₂ in GI.getpoint(geom)\n        area_component = GI.x(point₁) * GI.y(point₂) -\n            GI.x(point₂) * GI.y(point₁)","category":"page"},{"location":"source/methods/centroid/","page":"Centroid","title":"Centroid","text":"Accumulate the area component into area","category":"page"},{"location":"source/methods/centroid/","page":"Centroid","title":"Centroid","text":"        area += area_component","category":"page"},{"location":"source/methods/centroid/","page":"Centroid","title":"Centroid","text":"Weighted average of centroid components","category":"page"},{"location":"source/methods/centroid/","page":"Centroid","title":"Centroid","text":"        xcentroid += (GI.x(point₁) + GI.x(point₂)) * area_component\n        ycentroid += (GI.y(point₁) + GI.y(point₂)) * area_component","category":"page"},{"location":"source/methods/centroid/","page":"Centroid","title":"Centroid","text":"Advance the point buffer by 1 point","category":"page"},{"location":"source/methods/centroid/","page":"Centroid","title":"Centroid","text":"        point₁ = point₂\n    end\n    area /= 2\n    xcentroid /= 6area\n    ycentroid /= 6area\n    return (xcentroid, ycentroid), abs(area)\nend\nfunction _centroid_and_area(::GI.PolygonTrait, geom, ::Type{T}) where T","category":"page"},{"location":"source/methods/centroid/","page":"Centroid","title":"Centroid","text":"Exterior ring's centroid and area","category":"page"},{"location":"source/methods/centroid/","page":"Centroid","title":"Centroid","text":"    (xcentroid, ycentroid), area = centroid_and_area(GI.getexterior(geom), T)","category":"page"},{"location":"source/methods/centroid/","page":"Centroid","title":"Centroid","text":"Weight exterior centroid by area","category":"page"},{"location":"source/methods/centroid/","page":"Centroid","title":"Centroid","text":"    xcentroid *= area\n    ycentroid *= area","category":"page"},{"location":"source/methods/centroid/","page":"Centroid","title":"Centroid","text":"Loop over any holes within the polygon","category":"page"},{"location":"source/methods/centroid/","page":"Centroid","title":"Centroid","text":"    for hole in GI.gethole(geom)","category":"page"},{"location":"source/methods/centroid/","page":"Centroid","title":"Centroid","text":"Hole polygon's centroid and area","category":"page"},{"location":"source/methods/centroid/","page":"Centroid","title":"Centroid","text":"        (xinterior, yinterior), interior_area = centroid_and_area(hole, T)","category":"page"},{"location":"source/methods/centroid/","page":"Centroid","title":"Centroid","text":"Accumulate the area component into area","category":"page"},{"location":"source/methods/centroid/","page":"Centroid","title":"Centroid","text":"        area -= interior_area","category":"page"},{"location":"source/methods/centroid/","page":"Centroid","title":"Centroid","text":"Weighted average of centroid components","category":"page"},{"location":"source/methods/centroid/","page":"Centroid","title":"Centroid","text":"        xcentroid -= xinterior * interior_area\n        ycentroid -= yinterior * interior_area\n    end\n    xcentroid /= area\n    ycentroid /= area\n    return (xcentroid, ycentroid), area\nend","category":"page"},{"location":"source/methods/centroid/","page":"Centroid","title":"Centroid","text":"The op argument for _applyreduce and point / area It combines two (point, area) tuples into one, taking the average of the centroid points weighted by the area of the geom they are from.","category":"page"},{"location":"source/methods/centroid/","page":"Centroid","title":"Centroid","text":"function _combine_centroid_and_area(((x1, y1), area1), ((x2, y2), area2))\n    area = area1 + area2\n    x = (x1 * area1 + x2 * area2) / area\n    y = (y1 * area1 + y2 * area2) / area\n    return (x, y), area\nend","category":"page"},{"location":"source/methods/centroid/","page":"Centroid","title":"Centroid","text":"","category":"page"},{"location":"source/methods/centroid/","page":"Centroid","title":"Centroid","text":"This page was generated using Literate.jl.","category":"page"},{"location":"source/transformations/extent/#Extent-embedding","page":"Extent embedding","title":"Extent embedding","text":"","category":"section"},{"location":"source/transformations/extent/","page":"Extent embedding","title":"Extent embedding","text":"\"\"\"\n    embed_extent(obj)\n\nRecursively wrap the object with a GeoInterface.jl geometry,\ncalculating and adding an `Extents.Extent` to all objects.\n\nThis can improve performance when extents need to be checked multiple times,\nsuch when needing to check if many points are in geometries, and using their extents\nas a quick filter for obviously exterior points.","category":"page"},{"location":"source/transformations/extent/","page":"Extent embedding","title":"Extent embedding","text":"Keywords","category":"page"},{"location":"source/transformations/extent/","page":"Extent embedding","title":"Extent embedding","text":"$THREADED_KEYWORD\n$CRS_KEYWORD\n\"\"\"\nembed_extent(x; threaded=false, crs=nothing) =\n    apply(identity, GI.PointTrait, x; calc_extent=true, threaded, crs)","category":"page"},{"location":"source/transformations/extent/","page":"Extent embedding","title":"Extent embedding","text":"","category":"page"},{"location":"source/transformations/extent/","page":"Extent embedding","title":"Extent embedding","text":"This page was generated using Literate.jl.","category":"page"},{"location":"source/methods/geom_relations/intersects/#Intersection-checks","page":"Intersection checks","title":"Intersection checks","text":"","category":"section"},{"location":"source/methods/geom_relations/intersects/","page":"Intersection checks","title":"Intersection checks","text":"export intersects","category":"page"},{"location":"source/methods/geom_relations/intersects/#What-is-intersects?","page":"Intersection checks","title":"What is intersects?","text":"","category":"section"},{"location":"source/methods/geom_relations/intersects/","page":"Intersection checks","title":"Intersection checks","text":"The intersects function checks if a given geometry intersects with another geometry, or in other words, the either the interiors or boundaries of the two geometries intersect.","category":"page"},{"location":"source/methods/geom_relations/intersects/","page":"Intersection checks","title":"Intersection checks","text":"To provide an example, consider these two lines:","category":"page"},{"location":"source/methods/geom_relations/intersects/","page":"Intersection checks","title":"Intersection checks","text":"import GeometryOps as GO\nimport GeoInterface as GI\nusing Makie\nusing CairoMakie\n\nline1 = GI.Line([(124.584961,-12.768946), (126.738281,-17.224758)])\nline2 = GI.Line([(123.354492,-15.961329), (127.22168,-14.008696)])\nf, a, p = lines(GI.getpoint(line1))\nlines!(GI.getpoint(line2))\nf","category":"page"},{"location":"source/methods/geom_relations/intersects/","page":"Intersection checks","title":"Intersection checks","text":"We can see that they intersect, so we expect intersects to return true, and we can visualize the intersection point in red.","category":"page"},{"location":"source/methods/geom_relations/intersects/","page":"Intersection checks","title":"Intersection checks","text":"GO.intersects(line1, line2)  # true","category":"page"},{"location":"source/methods/geom_relations/intersects/#Implementation","page":"Intersection checks","title":"Implementation","text":"","category":"section"},{"location":"source/methods/geom_relations/intersects/","page":"Intersection checks","title":"Intersection checks","text":"This is the GeoInterface-compatible implementation.","category":"page"},{"location":"source/methods/geom_relations/intersects/","page":"Intersection checks","title":"Intersection checks","text":"Given that intersects is the exact opposite of disjoint, we simply pass the two inputs variables, swapped in order, to disjoint.","category":"page"},{"location":"source/methods/geom_relations/intersects/","page":"Intersection checks","title":"Intersection checks","text":"\"\"\"\n    intersects(geom1, geom2)::Bool\n\nReturn true if the interiors or boundaries of the two geometries interact.\n\n`intersects` returns the exact opposite result of `disjoint`.\n\n# Example\n\n```jldoctest\nimport GeoInterface as GI, GeometryOps as GO\n\nline1 = GI.Line([(124.584961,-12.768946), (126.738281,-17.224758)])\nline2 = GI.Line([(123.354492,-15.961329), (127.22168,-14.008696)])\nGO.intersects(line1, line2)","category":"page"},{"location":"source/methods/geom_relations/intersects/","page":"Intersection checks","title":"Intersection checks","text":"output","category":"page"},{"location":"source/methods/geom_relations/intersects/","page":"Intersection checks","title":"Intersection checks","text":"true\n```\n\"\"\"\nintersects(geom1, geom2) = !disjoint(geom1, geom2)\n\n\n#= Returns true if there is at least one intersection between edges within the\ntwo lists of edges. =#\nfunction _line_intersects(\n    edges_a::Vector{Edge},\n    edges_b::Vector{Edge}\n)","category":"page"},{"location":"source/methods/geom_relations/intersects/","page":"Intersection checks","title":"Intersection checks","text":"Extents.intersects(toextent(edgesa), toextent(edgesb)) || return false","category":"page"},{"location":"source/methods/geom_relations/intersects/","page":"Intersection checks","title":"Intersection checks","text":"    for edge_a in edges_a\n        for edge_b in edges_b\n            _line_intersects(edge_a, edge_b) && return true\n        end\n    end\n    return false\nend","category":"page"},{"location":"source/methods/geom_relations/intersects/","page":"Intersection checks","title":"Intersection checks","text":"Returns true if there is at least one intersection between two edges.","category":"page"},{"location":"source/methods/geom_relations/intersects/","page":"Intersection checks","title":"Intersection checks","text":"function _line_intersects(edge_a::Edge, edge_b::Edge)\n    meet_type = ExactPredicates.meet(edge_a..., edge_b...)\n    return meet_type == 0 || meet_type == 1\nend","category":"page"},{"location":"source/methods/geom_relations/intersects/","page":"Intersection checks","title":"Intersection checks","text":"","category":"page"},{"location":"source/methods/geom_relations/intersects/","page":"Intersection checks","title":"Intersection checks","text":"This page was generated using Literate.jl.","category":"page"},{"location":"source/transformations/flip/#Coordinate-flipping","page":"Coordinate flipping","title":"Coordinate flipping","text":"","category":"section"},{"location":"source/transformations/flip/","page":"Coordinate flipping","title":"Coordinate flipping","text":"This is a simple example of how to use the apply functionality in a function, by flipping the x and y coordinates of a geometry.","category":"page"},{"location":"source/transformations/flip/","page":"Coordinate flipping","title":"Coordinate flipping","text":"\"\"\"\n    flip(obj)\n\nSwap all of the x and y coordinates in obj, otherwise\nkeeping the original structure (but not necessarily the\noriginal type).\n\n# Keywords\n\n$APPLY_KEYWORDS\n\"\"\"\nfunction flip(geom; kw...)\n    if _is3d(geom)\n        return apply(PointTrait, geom; kw...) do p\n            (GI.y(p), GI.x(p), GI.z(p))\n        end\n    else\n        return apply(PointTrait, geom; kw...) do p\n            (GI.y(p), GI.x(p))\n        end\n    end\nend","category":"page"},{"location":"source/transformations/flip/","page":"Coordinate flipping","title":"Coordinate flipping","text":"","category":"page"},{"location":"source/transformations/flip/","page":"Coordinate flipping","title":"Coordinate flipping","text":"This page was generated using Literate.jl.","category":"page"},{"location":"source/methods/clipping/intersection/#Intersection","page":"Intersection","title":"Intersection","text":"","category":"section"},{"location":"source/methods/clipping/intersection/","page":"Intersection","title":"Intersection","text":"export intersection, intersection_points\n\n\n\"\"\"\n    intersection(geom_a, geom_b, [T::Type]; target::Type)\n\nReturn the intersection between two geometries as a list of geometries. Return an empty list\nif none are found. The type of the list will be constrained as much as possible given the\ninput geometries. Furthermore, the user can provide a `taget` type as a keyword argument and\na list of target geometries found in the intersection will be returned. The user can also\nprovide a float type that they would like the points of returned geometries to be.\n\n# Example\n\n```jldoctest\nimport GeoInterface as GI, GeometryOps as GO\n\nline1 = GI.Line([(124.584961,-12.768946), (126.738281,-17.224758)])\nline2 = GI.Line([(123.354492,-15.961329), (127.22168,-14.008696)])\ninter_points = GO.intersection(line1, line2; target = GI.PointTrait)\nGI.coordinates.(inter_points)","category":"page"},{"location":"source/methods/clipping/intersection/","page":"Intersection","title":"Intersection","text":"output","category":"page"},{"location":"source/methods/clipping/intersection/","page":"Intersection","title":"Intersection","text":"1-element Vector{Vector{Float64}}:\n [125.58375366067547, -14.83572303404496]\n```\n\"\"\"\nfunction intersection(\n    geom_a, geom_b, ::Type{T} = Float64; target::Type{Target} = Nothing,\n) where {T <: AbstractFloat, Target <: GI.AbstractTrait}\n    return _intersection(Target, T, GI.trait(geom_a), geom_a, GI.trait(geom_b), geom_b)\nend","category":"page"},{"location":"source/methods/clipping/intersection/","page":"Intersection","title":"Intersection","text":"Curve-Curve Intersections with target Point","category":"page"},{"location":"source/methods/clipping/intersection/","page":"Intersection","title":"Intersection","text":"_intersection(\n    ::Type{GI.PointTrait}, ::Type{T},\n    trait_a::Union{GI.LineTrait, GI.LineStringTrait, GI.LinearRingTrait}, geom_a,\n    trait_b::Union{GI.LineTrait, GI.LineStringTrait, GI.LinearRingTrait}, geom_b,\n) where T = _intersection_points(T, trait_a, geom_a, trait_b, geom_b)\n\n\n#= Polygon-Polygon Intersections with target Polygon\nThe algorithm to determine the intersection was adapted from \"Efficient clipping\nof efficient polygons,\" by Greiner and Hormann (1998).\nDOI: https://doi.org/10.1145/274363.274364 =#\nfunction _intersection(\n    ::Type{GI.PolygonTrait}, ::Type{T},\n    ::GI.PolygonTrait, poly_a,\n    ::GI.PolygonTrait, poly_b,\n) where {T}","category":"page"},{"location":"source/methods/clipping/intersection/","page":"Intersection","title":"Intersection","text":"First we get the exteriors of 'polya' and 'polyb'","category":"page"},{"location":"source/methods/clipping/intersection/","page":"Intersection","title":"Intersection","text":"    ext_poly_a = GI.getexterior(poly_a)\n    ext_poly_b = GI.getexterior(poly_b)","category":"page"},{"location":"source/methods/clipping/intersection/","page":"Intersection","title":"Intersection","text":"Then we find the intersection of the exteriors","category":"page"},{"location":"source/methods/clipping/intersection/","page":"Intersection","title":"Intersection","text":"    a_list, b_list, a_idx_list = _build_ab_list(T, ext_poly_a, ext_poly_b)\n    polys = _trace_polynodes(T, a_list, b_list, a_idx_list, (x, y) -> x ? 1 : (-1))\n\n    if isempty(polys)\n        if _point_filled_curve_orientation(a_list[1].point, ext_poly_b) == point_in\n            push!(polys, GI.Polygon([ext_poly_a]))\n        elseif _point_filled_curve_orientation(b_list[1].point, ext_poly_a) == point_in\n            push!(polys, GI.Polygon([ext_poly_b]))\n        end\n    end","category":"page"},{"location":"source/methods/clipping/intersection/","page":"Intersection","title":"Intersection","text":"If the original polygons had holes, take that into account.","category":"page"},{"location":"source/methods/clipping/intersection/","page":"Intersection","title":"Intersection","text":"    if GI.nhole(poly_a) != 0 || GI.nhole(poly_b) != 0\n        hole_iterator = Iterators.flatten((GI.gethole(poly_a), GI.gethole(poly_b)))\n        _add_holes_to_polys!(T, polys, hole_iterator)\n    end\n    return polys\nend","category":"page"},{"location":"source/methods/clipping/intersection/","page":"Intersection","title":"Intersection","text":"Many type and target combos aren't implemented","category":"page"},{"location":"source/methods/clipping/intersection/","page":"Intersection","title":"Intersection","text":"function _intersection(\n    ::Type{Target}, ::Type{T},\n    trait_a::GI.AbstractTrait, geom_a,\n    trait_b::GI.AbstractTrait, geom_b,\n) where {Target, T}\n    @assert(\n        false,\n        \"Intersection between $trait_a and $trait_b with target $Target isn't implemented yet.\",\n    )\n    return nothing\nend\n\n\"\"\"\n    intersection_points(\n        geom_a,\n        geom_b,\n    )::Union{\n        ::Vector{::Tuple{::Real, ::Real}},\n        ::Nothing,\n    }\n\nReturn a list of intersection points between two geometries of type GI.Point.\nIf no intersection point was possible given geometry extents, returns an empty\nlist.\n\"\"\"\nintersection_points(geom_a, geom_b, ::Type{T} = Float64) where T <: AbstractFloat =\n    _intersection_points(T, GI.trait(geom_a), geom_a, GI.trait(geom_b), geom_b)\n\n\n#= Calculates the list of intersection points between two geometries, inlcuding line\nsegments, line strings, linear rings, polygons, and multipolygons. If no intersection points\nwere possible given geometry extents or if none are found, return an empty list of\nGI.Points. =#\nfunction _intersection_points(::Type{T}, ::GI.AbstractTrait, a, ::GI.AbstractTrait, b) where T","category":"page"},{"location":"source/methods/clipping/intersection/","page":"Intersection","title":"Intersection","text":"Initialize an empty list of points","category":"page"},{"location":"source/methods/clipping/intersection/","page":"Intersection","title":"Intersection","text":"    result = GI.Point[]","category":"page"},{"location":"source/methods/clipping/intersection/","page":"Intersection","title":"Intersection","text":"Check if the geometries extents even overlap","category":"page"},{"location":"source/methods/clipping/intersection/","page":"Intersection","title":"Intersection","text":"    Extents.intersects(GI.extent(a), GI.extent(b)) || return result","category":"page"},{"location":"source/methods/clipping/intersection/","page":"Intersection","title":"Intersection","text":"Create a list of edges from the two input geometries","category":"page"},{"location":"source/methods/clipping/intersection/","page":"Intersection","title":"Intersection","text":"    edges_a, edges_b = map(sort! ∘ to_edges, (a, b))\n    npoints_a, npoints_b  = length(edges_a), length(edges_b)\n    a_closed = npoints_a > 1 && edges_a[1][1] == edges_a[end][1]\n    b_closed = npoints_b > 1 && edges_b[1][1] == edges_b[end][1]\n    if npoints_a > 0 && npoints_b > 0","category":"page"},{"location":"source/methods/clipping/intersection/","page":"Intersection","title":"Intersection","text":"Loop over pairs of edges and add any intersection points to results","category":"page"},{"location":"source/methods/clipping/intersection/","page":"Intersection","title":"Intersection","text":"        for i in eachindex(edges_a), j in eachindex(edges_b)\n            point, fracs = _intersection_point(T, edges_a[i], edges_b[j])\n            if !isnothing(point)\n                #=\n                Determine if point is on edge (all edge endpoints excluded\n                except for the last edge for an open geometry)\n                =#\n                α, β = fracs\n                on_a_edge = (!a_closed && i == npoints_a && 0 <= α <= 1) ||\n                    (0 <= α < 1)\n                on_b_edge = (!b_closed && j == npoints_b && 0 <= β <= 1) ||\n                    (0 <= β < 1)\n                if on_a_edge && on_b_edge\n                    push!(result, GI.Point(point))\n                end\n            end\n        end\n    end\n    return result\nend\n\n#= Calculates the intersection point between two lines if it exists, and as if the line\nextended to infinity, and the fractional component of each line from the initial end point\nto the intersection point.\nInputs:\n    (a1, a2)::Tuple{Tuple{::Real, ::Real}, Tuple{::Real, ::Real}} first line\n    (b1, b2)::Tuple{Tuple{::Real, ::Real}, Tuple{::Real, ::Real}} second line\nOutputs:\n    (x, y)::Tuple{::Real, ::Real} intersection point\n    (t, u)::Tuple{::Real, ::Real} fractional length of lines to intersection\n    Both are ::Nothing if point doesn't exist!\n\nCalculation derivation can be found here:\n    https://stackoverflow.com/questions/563198/\n=#\nfunction _intersection_point(::Type{T}, (a1, a2)::Tuple, (b1, b2)::Tuple) where T","category":"page"},{"location":"source/methods/clipping/intersection/","page":"Intersection","title":"Intersection","text":"First line runs from p to p + r","category":"page"},{"location":"source/methods/clipping/intersection/","page":"Intersection","title":"Intersection","text":"    px, py = GI.x(a1), GI.y(a1)\n    rx, ry = GI.x(a2) - px, GI.y(a2) - py","category":"page"},{"location":"source/methods/clipping/intersection/","page":"Intersection","title":"Intersection","text":"Second line runs from q to q + s","category":"page"},{"location":"source/methods/clipping/intersection/","page":"Intersection","title":"Intersection","text":"    qx, qy = GI.x(b1), GI.y(b1)\n    sx, sy = GI.x(b2) - qx, GI.y(b2) - qy","category":"page"},{"location":"source/methods/clipping/intersection/","page":"Intersection","title":"Intersection","text":"Intersection will be where p + tr = q + us where 0 < t, u < 1 and","category":"page"},{"location":"source/methods/clipping/intersection/","page":"Intersection","title":"Intersection","text":"    r_cross_s = rx * sy - ry * sx\n    if r_cross_s != 0\n        Δqp_x = qx - px\n        Δqp_y = qy - py\n        t = (Δqp_x * sy - Δqp_y * sx) / r_cross_s\n        u = (Δqp_x * ry - Δqp_y * rx) / r_cross_s\n        x = px + t * rx\n        y = py + t * ry\n        return (T(x), T(y)), (T(t), T(u))\n    end\n    return nothing, nothing\nend","category":"page"},{"location":"source/methods/clipping/intersection/","page":"Intersection","title":"Intersection","text":"","category":"page"},{"location":"source/methods/clipping/intersection/","page":"Intersection","title":"Intersection","text":"This page was generated using Literate.jl.","category":"page"},{"location":"source/transformations/transform/","page":"-","title":"-","text":"\"\"\"\n    transform(f, obj)\n\nApply a function `f` to all the points in `obj`.\n\nPoints will be passed to `f` as an `SVector` to allow\nusing CoordinateTransformations.jl and Rotations.jl\nwithout hassle.\n\n`SVector` is also a valid GeoInterface.jl point, so will\nwork in all GeoInterface.jl methods.\n\n# Example\n\n```julia\njulia> import GeoInterface as GI\n\njulia> import GeometryOps as GO\n\njulia> geom = GI.Polygon([GI.LinearRing([(1, 2), (3, 4), (5, 6), (1, 2)]), GI.LinearRing([(3, 4), (5, 6), (6, 7), (3, 4)])]);\n\njulia> f = CoordinateTransformations.Translation(3.5, 1.5)\nTranslation(3.5, 1.5)\n\njulia> GO.transform(f, geom)\nGeoInterface.Wrappers.Polygon{false, false, Vector{GeoInterface.Wrappers.LinearRing{false, false, Vector{StaticArraysCore.SVector{2, Float64}}, Nothing, Nothing}}, Nothing, Nothing}(GeoInterface.Wrappers.Linea\nrRing{false, false, Vector{StaticArraysCore.SVector{2, Float64}}, Nothing, Nothing}[GeoInterface.Wrappers.LinearRing{false, false, Vector{StaticArraysCore.SVector{2, Float64}}, Nothing, Nothing}(StaticArraysCo\nre.SVector{2, Float64}[[4.5, 3.5], [6.5, 5.5], [8.5, 7.5], [4.5, 3.5]], nothing, nothing), GeoInterface.Wrappers.LinearRing{false, false, Vector{StaticArraysCore.SVector{2, Float64}}, Nothing, Nothing}(StaticA\nrraysCore.SVector{2, Float64}[[6.5, 5.5], [8.5, 7.5], [9.5, 8.5], [6.5, 5.5]], nothing, nothing)], nothing, nothing)\n```\n\nWith Rotations.jl you need to actuall multiply the Rotation\nby the `SVector` point, which is easy using an anonymous function.\n\n```julia\njulia> using Rotations\n\njulia> GO.transform(p -> one(RotMatrix{2}) * p, geom)\nGeoInterface.Wrappers.Polygon{false, false, Vector{GeoInterface.Wrappers.LinearRing{false, false, Vector{StaticArraysCore.SVector{2, Int64}}, Nothing, Nothing}}, Nothing, Nothing}(GeoInterface.Wrappers.LinearR\ning{false, false, Vector{StaticArraysCore.SVector{2, Int64}}, Nothing, Nothing}[GeoInterface.Wrappers.LinearRing{false, false, Vector{StaticArraysCore.SVector{2, Int64}}, Nothing, Nothing}(StaticArraysCore.SVe\nctor{2, Int64}[[2, 1], [4, 3], [6, 5], [2, 1]], nothing, nothing), GeoInterface.Wrappers.LinearRing{false, false, Vector{StaticArraysCore.SVector{2, Int64}}, Nothing, Nothing}(StaticArraysCore.SVector{2, Int64\n}[[4, 3], [6, 5], [7, 6], [4, 3]], nothing, nothing)], nothing, nothing)\n```\n\"\"\"\nfunction transform(f, geom; kw...)\n    if _is3d(geom)\n        return apply(PointTrait, geom; kw...) do p\n            f(StaticArrays.SVector{3}((GI.x(p), GI.y(p), GI.z(p))))\n        end\n    else\n        return apply(PointTrait, geom; kw...) do p\n            f(StaticArrays.SVector{2}((GI.x(p), GI.y(p))))\n        end\n    end\nend","category":"page"},{"location":"source/transformations/transform/","page":"-","title":"-","text":"","category":"page"},{"location":"source/transformations/transform/","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"source/methods/geom_relations/covers/#Covers","page":"Covers","title":"Covers","text":"","category":"section"},{"location":"source/methods/geom_relations/covers/","page":"Covers","title":"Covers","text":"export covers","category":"page"},{"location":"source/methods/geom_relations/covers/#What-is-covers?","page":"Covers","title":"What is covers?","text":"","category":"section"},{"location":"source/methods/geom_relations/covers/","page":"Covers","title":"Covers","text":"The covers function checks if a given geometry completly covers another geometry. For this to be true, the \"contained\" geometry's interior and boundaries must be covered by the \"covering\" geometry's interior and boundaries. The interiors do not need to overlap.","category":"page"},{"location":"source/methods/geom_relations/covers/","page":"Covers","title":"Covers","text":"To provide an example, consider these two lines:","category":"page"},{"location":"source/methods/geom_relations/covers/","page":"Covers","title":"Covers","text":"import GeometryOps as GO\nimport GeoInterface as GI\nusing Makie\nusing CairoMakie\n\np1 = (0.0, 0.0)\np2 = (1.0, 1.0)\nl1 = GI.Line([p1, p2])\n\nf, a, p = lines(GI.getpoint(l1))\nscatter!(p1, color = :red)\nf","category":"page"},{"location":"source/methods/geom_relations/covers/","page":"Covers","title":"Covers","text":"GO.covers(l1, p1)  # returns true\nGO.covers(p1, l1)  # returns false","category":"page"},{"location":"source/methods/geom_relations/covers/#Implementation","page":"Covers","title":"Implementation","text":"","category":"section"},{"location":"source/methods/geom_relations/covers/","page":"Covers","title":"Covers","text":"This is the GeoInterface-compatible implementation.","category":"page"},{"location":"source/methods/geom_relations/covers/","page":"Covers","title":"Covers","text":"Given that covers is the exact opposite of coveredby, we simply pass the two inputs variables, swapped in order, to coveredby.","category":"page"},{"location":"source/methods/geom_relations/covers/","page":"Covers","title":"Covers","text":"\"\"\"\n    covers(g1::AbstractGeometry, g2::AbstractGeometry)::Bool\n\nReturn true if the first geometry is completely covers the second geometry,\nThe exterior and boundary of the second geometry must not be outside of the\ninterior and boundary of the first geometry. However, the interiors need not\nintersect.\n\n`covers` returns the exact opposite result of `coveredby`.\n\n# Examples\n\n```jldoctest\nimport GeometryOps as GO, GeoInterface as GI\nl1 = GI.LineString([(1, 1), (1, 2), (1, 3), (1, 4)])\nl2 = GI.LineString([(1, 1), (1, 2)])\n\nGO.covers(l1, l2)","category":"page"},{"location":"source/methods/geom_relations/covers/","page":"Covers","title":"Covers","text":"output","category":"page"},{"location":"source/methods/geom_relations/covers/","page":"Covers","title":"Covers","text":"true\n```\n\"\"\"\ncovers(g1, g2)::Bool = GeometryOps.coveredby(g2, g1)","category":"page"},{"location":"source/methods/geom_relations/covers/","page":"Covers","title":"Covers","text":"","category":"page"},{"location":"source/methods/geom_relations/covers/","page":"Covers","title":"Covers","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"CurrentModule = GeometryOps","category":"page"},{"location":"api/#Full-GeometryOps-API-documentation","page":"API Reference","title":"Full GeometryOps API documentation","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"warning: Warning\nThis page is still very much WIP!","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Documentation for GeometryOps's full API (only for reference!).","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"api/#apply-and-associated-functions","page":"API Reference","title":"apply and associated functions","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"apply\nreproject\ntransform","category":"page"},{"location":"api/#GeometryOps.apply","page":"API Reference","title":"GeometryOps.apply","text":"apply(f, target::Type{<:AbstractTrait}, obj; kw...)\n\nReconstruct a geometry, feature, feature collection, or nested vectors of either using the function f on the target trait.\n\nf(target_geom) => x where x also has the target trait, or a trait that can be substituted. For example, swapping PolgonTrait to MultiPointTrait will fail if the outer object has MultiPolygonTrait, but should work if it has FeatureTrait.\n\nObjects \"shallower\" than the target trait are always completely rebuilt, like a Vector of FeatureCollectionTrait of FeatureTrait when the target has PolygonTrait and is held in the features. But \"deeper\" objects may remain unchanged - such as points and linear rings if the target is the same PolygonTrait.\n\nThe result is a functionally similar geometry with values depending on f\n\nthreaded: true or false. Whether to use multithreading. Defaults to false.\ncrs: The CRS to attach to geometries. Defaults to nothing.\ncalc_extent: true or false. Whether to calculate the extent. Defaults to false.\n\nExample\n\nFlipped point the order in any feature or geometry, or iterables of either:\n\n```julia import GeoInterface as GI import GeometryOps as GO geom = GI.Polygon([GI.LinearRing([(1, 2), (3, 4), (5, 6), (1, 2)]),                    GI.LinearRing([(3, 4), (5, 6), (6, 7), (3, 4)])])\n\nflipped_geom = GO.apply(GI.PointTrait, geom) do p     (GI.y(p), GI.x(p)) end\n\n\n\n\n\n","category":"function"},{"location":"api/#GeometryOps.reproject","page":"API Reference","title":"GeometryOps.reproject","text":"reproject(geometry; source_crs, target_crs, transform, always_xy, time)\nreproject(geometry, source_crs, target_crs; always_xy, time)\nreproject(geometry, transform; always_xy, time)\n\nReproject any GeoInterface.jl compatible geometry from source_crs to target_crs.\n\nThe returned object will be constructed from GeoInterface.WrapperGeometry geometries, wrapping views of a Vector{Proj.Point{D}}, where D is the dimension.\n\nArguments\n\ngeometry: Any GeoInterface.jl compatible geometries.\nsource_crs: the source coordinate referece system, as a GeoFormatTypes.jl object or a string.\ntarget_crs: the target coordinate referece system, as a GeoFormatTypes.jl object or a string.\n\nIf these a passed as keywords, transform will take priority. Without it target_crs is always needed, and source_crs is needed if it is not retreivable from the geometry with GeoInterface.crs(geometry).\n\nKeywords\n\nalways_xy: force x, y coordinate order, true by default.   false will expect and return points in the crs coordinate order.\ntime: the time for the coordinates. Inf by default.\nthreaded: true or false. Whether to use multithreading. Defaults to false.\ncrs: The CRS to attach to geometries. Defaults to nothing.\ncalc_extent: true or false. Whether to calculate the extent. Defaults to false.\n\n\n\n\n\n","category":"function"},{"location":"api/#GeometryOps.transform","page":"API Reference","title":"GeometryOps.transform","text":"transform(f, obj)\n\nApply a function f to all the points in obj.\n\nPoints will be passed to f as an SVector to allow using CoordinateTransformations.jl and Rotations.jl  without hassle.\n\nSVector is also a valid GeoInterface.jl point, so will work in all GeoInterface.jl methods.\n\nExample\n\njulia> import GeoInterface as GI\n\njulia> import GeometryOps as GO\n\njulia> geom = GI.Polygon([GI.LinearRing([(1, 2), (3, 4), (5, 6), (1, 2)]), GI.LinearRing([(3, 4), (5, 6), (6, 7), (3, 4)])]);\n\njulia> f = CoordinateTransformations.Translation(3.5, 1.5)\nTranslation(3.5, 1.5)\n\njulia> GO.transform(f, geom)\nGeoInterface.Wrappers.Polygon{false, false, Vector{GeoInterface.Wrappers.LinearRing{false, false, Vector{StaticArraysCore.SVector{2, Float64}}, Nothing, Nothing}}, Nothing, Nothing}(GeoInterface.Wrappers.Linea\nrRing{false, false, Vector{StaticArraysCore.SVector{2, Float64}}, Nothing, Nothing}[GeoInterface.Wrappers.LinearRing{false, false, Vector{StaticArraysCore.SVector{2, Float64}}, Nothing, Nothing}(StaticArraysCo\nre.SVector{2, Float64}[[4.5, 3.5], [6.5, 5.5], [8.5, 7.5], [4.5, 3.5]], nothing, nothing), GeoInterface.Wrappers.LinearRing{false, false, Vector{StaticArraysCore.SVector{2, Float64}}, Nothing, Nothing}(StaticA\nrraysCore.SVector{2, Float64}[[6.5, 5.5], [8.5, 7.5], [9.5, 8.5], [6.5, 5.5]], nothing, nothing)], nothing, nothing)\n\nWith Rotations.jl you need to actuall multiply the Rotation by the SVector point, which is easy using an anonymous function.\n\njulia> using Rotations\n\njulia> GO.transform(p -> one(RotMatrix{2}) * p, geom)\nGeoInterface.Wrappers.Polygon{false, false, Vector{GeoInterface.Wrappers.LinearRing{false, false, Vector{StaticArraysCore.SVector{2, Int64}}, Nothing, Nothing}}, Nothing, Nothing}(GeoInterface.Wrappers.LinearR\ning{false, false, Vector{StaticArraysCore.SVector{2, Int64}}, Nothing, Nothing}[GeoInterface.Wrappers.LinearRing{false, false, Vector{StaticArraysCore.SVector{2, Int64}}, Nothing, Nothing}(StaticArraysCore.SVe\nctor{2, Int64}[[2, 1], [4, 3], [6, 5], [2, 1]], nothing, nothing), GeoInterface.Wrappers.LinearRing{false, false, Vector{StaticArraysCore.SVector{2, Int64}}, Nothing, Nothing}(StaticArraysCore.SVector{2, Int64\n}[[4, 3], [6, 5], [7, 6], [4, 3]], nothing, nothing)], nothing, nothing)\n\n\n\n\n\n","category":"function"},{"location":"api/#General-geometry-methods","page":"API Reference","title":"General geometry methods","text":"","category":"section"},{"location":"api/#OGC-methods","page":"API Reference","title":"OGC methods","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"GeometryOps.contains\ncoveredby\ncovers\ncrosses\ndisjoint\nintersects\noverlaps\ntouches\nwithin","category":"page"},{"location":"api/#GeometryOps.contains","page":"API Reference","title":"GeometryOps.contains","text":"contains(g1::AbstractGeometry, g2::AbstractGeometry)::Bool\n\nReturn true if the second geometry is completely contained by the first geometry. The interiors of both geometries must intersect and the interior and boundary of the secondary (g2) must not intersect the exterior of the first (g1).\n\ncontains returns the exact opposite result of within.\n\nExamples\n\nimport GeometryOps as GO, GeoInterface as GI\nline = GI.LineString([(1, 1), (1, 2), (1, 3), (1, 4)])\npoint = GI.Point((1, 2))\n\nGO.contains(line, point)\n# output\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#GeometryOps.coveredby","page":"API Reference","title":"GeometryOps.coveredby","text":"coveredby(g1, g2)::Bool\n\nReturn true if the first geometry is completely covered by the second geometry. The interior and boundary of the primary geometry (g1) must not intersect the exterior of the secondary geometry (g2).\n\nFurthermore, coveredby returns the exact opposite result of covers. They are equivalent with the order of the arguments swapped.\n\nExamples\n\nimport GeometryOps as GO, GeoInterface as GI\np1 = GI.Point(0.0, 0.0)\np2 = GI.Point(1.0, 1.0)\nl1 = GI.Line([p1, p2])\n\nGO.coveredby(p1, l1)\n# output\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#GeometryOps.covers","page":"API Reference","title":"GeometryOps.covers","text":"covers(g1::AbstractGeometry, g2::AbstractGeometry)::Bool\n\nReturn true if the first geometry is completely covers the second geometry,  The exterior and boundary of the second geometry must not be outside of the interior and boundary of the first geometry. However, the interiors need not intersect.\n\ncovers returns the exact opposite result of coveredby.\n\nExamples\n\nimport GeometryOps as GO, GeoInterface as GI\nl1 = GI.LineString([(1, 1), (1, 2), (1, 3), (1, 4)])\nl2 = GI.LineString([(1, 1), (1, 2)])\n\nGO.covers(l1, l2)\n# output\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#GeometryOps.crosses","page":"API Reference","title":"GeometryOps.crosses","text":" crosses(geom1, geom2)::Bool\n\nReturn true if the intersection results in a geometry whose dimension is one less than the maximum dimension of the two source geometries and the intersection set is interior to both source geometries.\n\nTODO: broken\n\nExamples\n\nimport GeoInterface as GI, GeometryOps as GO\n# TODO: Add working example\n\n\n\n\n\n","category":"function"},{"location":"api/#GeometryOps.disjoint","page":"API Reference","title":"GeometryOps.disjoint","text":"disjoint(geom1, geom2)::Bool\n\nReturn true if the first geometry is disjoint from the second geometry.\n\nReturn true if the first geometry is disjoint from the second geometry. The interiors and boundaries of both geometries must not intersect.\n\nExamples\n\nimport GeometryOps as GO, GeoInterface as GI\n\nline = GI.LineString([(1, 1), (1, 2), (1, 3), (1, 4)])\npoint = (2, 2)\nGO.disjoint(point, line)\n\n# output\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#GeometryOps.intersects","page":"API Reference","title":"GeometryOps.intersects","text":"intersects(geom1, geom2)::Bool\n\nReturn true if the interiors or boundaries of the two geometries interact.\n\nintersects returns the exact opposite result of disjoint.\n\nExample\n\nimport GeoInterface as GI, GeometryOps as GO\n\nline1 = GI.Line([(124.584961,-12.768946), (126.738281,-17.224758)])\nline2 = GI.Line([(123.354492,-15.961329), (127.22168,-14.008696)])\nGO.intersects(line1, line2)\n\n# output\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#GeometryOps.overlaps","page":"API Reference","title":"GeometryOps.overlaps","text":"overlaps(geom1, geom2)::Bool\n\nCompare two Geometries of the same dimension and return true if their intersection set results in a geometry different from both but of the same dimension. This means one geometry cannot be within or contain the other and they cannot be equal\n\nExamples\n\nimport GeometryOps as GO, GeoInterface as GI\npoly1 = GI.Polygon([[(0,0), (0,5), (5,5), (5,0), (0,0)]])\npoly2 = GI.Polygon([[(1,1), (1,6), (6,6), (6,1), (1,1)]])\n\nGO.overlaps(poly1, poly2)\n# output\ntrue\n\n\n\n\n\noverlaps(::GI.AbstractTrait, geom1, ::GI.AbstractTrait, geom2)::Bool\n\nFor any non-specified pair, all have non-matching dimensions, return false.\n\n\n\n\n\noverlaps(\n    ::GI.MultiPointTrait, points1,\n    ::GI.MultiPointTrait, points2,\n)::Bool\n\nIf the multipoints overlap, meaning some, but not all, of the points within the multipoints are shared, return true.\n\n\n\n\n\noverlaps(::GI.LineTrait, line1, ::GI.LineTrait, line)::Bool\n\nIf the lines overlap, meaning that they are colinear but each have one endpoint outside of the other line, return true. Else false.\n\n\n\n\n\noverlaps(\n    ::Union{GI.LineStringTrait, GI.LinearRing}, line1,\n    ::Union{GI.LineStringTrait, GI.LinearRing}, line2,\n)::Bool\n\nIf the curves overlap, meaning that at least one edge of each curve overlaps, return true. Else false.\n\n\n\n\n\noverlaps(\n    trait_a::GI.PolygonTrait, poly_a,\n    trait_b::GI.PolygonTrait, poly_b,\n)::Bool\n\nIf the two polygons intersect with one another, but are not equal, return true. Else false.\n\n\n\n\n\noverlaps(\n    ::GI.PolygonTrait, poly1,\n    ::GI.MultiPolygonTrait, polys2,\n)::Bool\n\nReturn true if polygon overlaps with at least one of the polygons within the multipolygon. Else false.\n\n\n\n\n\noverlaps(\n    ::GI.MultiPolygonTrait, polys1,\n    ::GI.PolygonTrait, poly2,\n)::Bool\n\nReturn true if polygon overlaps with at least one of the polygons within the multipolygon. Else false.\n\n\n\n\n\noverlaps(\n    ::GI.MultiPolygonTrait, polys1,\n    ::GI.MultiPolygonTrait, polys2,\n)::Bool\n\nReturn true if at least one pair of polygons from multipolygons overlap. Else false.\n\n\n\n\n\n","category":"function"},{"location":"api/#GeometryOps.touches","page":"API Reference","title":"GeometryOps.touches","text":"touches(geom1, geom2)::Bool\n\nReturn true if the first geometry touches the second geometry. In other words, the two interiors cannot interact, but one of the geometries must have a boundary point that interacts with either the other geometies interior or boundary.\n\nExamples\n\nimport GeometryOps as GO, GeoInterface as GI\n\nl1 = GI.Line([(0.0, 0.0), (1.0, 0.0)])\nl2 = GI.Line([(1.0, 1.0), (1.0, -1.0)])\n\nGO.touches(l1, l2)\n# output\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#GeometryOps.within","page":"API Reference","title":"GeometryOps.within","text":"within(geom1, geom2)::Bool\n\nReturn true if the first geometry is completely within the second geometry. The interiors of both geometries must intersect and the interior and boundary of the primary geometry (geom1) must not intersect the exterior of the secondary geometry (geom2).\n\nFurthermore, within returns the exact opposite result of contains.\n\nExamples\n\nimport GeometryOps as GO, GeoInterface as GI\n\nline = GI.LineString([(1, 1), (1, 2), (1, 3), (1, 4)])\npoint = (1, 2)\nGO.within(point, line)\n\n# output\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Other-general-methods","page":"API Reference","title":"Other general methods","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"equals\ncentroid\ndistance\nsigned_distance\narea\nsigned_area\nangles\nembed_extent","category":"page"},{"location":"api/#GeometryOps.equals","page":"API Reference","title":"GeometryOps.equals","text":"equals(geom1, geom2)::Bool\n\nCompare two Geometries return true if they are the same geometry.\n\nExamples\n\nimport GeometryOps as GO, GeoInterface as GI\npoly1 = GI.Polygon([[(0,0), (0,5), (5,5), (5,0), (0,0)]])\npoly2 = GI.Polygon([[(0,0), (0,5), (5,5), (5,0), (0,0)]])\n\nGO.equals(poly1, poly2)\n# output\ntrue\n\n\n\n\n\nequals(::T, geom_a, ::T, geom_b)::Bool\n\nTwo geometries of the same type, which don't have a equals function to dispatch off of should throw an error.\n\n\n\n\n\nequals(trait_a, geom_a, trait_b, geom_b)\n\nTwo geometries which are not of the same type cannot be equal so they always return false.\n\n\n\n\n\nequals(::GI.PointTrait, p1, ::GI.PointTrait, p2)::Bool\n\nTwo points are the same if they have the same x and y (and z if 3D) coordinates.\n\n\n\n\n\nequals(::GI.PointTrait, p1, ::GI.MultiPointTrait, mp2)::Bool\n\nA point and a multipoint are equal if the multipoint is composed of a single point that is equivalent to the given point.\n\n\n\n\n\nequals(::GI.MultiPointTrait, mp1, ::GI.PointTrait, p2)::Bool\n\nA point and a multipoint are equal if the multipoint is composed of a single point that is equivalent to the given point.\n\n\n\n\n\nequals(::GI.MultiPointTrait, mp1, ::GI.MultiPointTrait, mp2)::Bool\n\nTwo multipoints are equal if they share the same set of points.\n\n\n\n\n\nequals(\n    ::Union{GI.LineTrait, GI.LineStringTrait}, l1,\n    ::Union{GI.LineTrait, GI.LineStringTrait}, l2,\n)::Bool\n\nTwo lines/linestrings are equal if they share the same set of points going along the curve. Note that lines/linestrings aren't closed by defintion.\n\n\n\n\n\nequals(\n    ::Union{GI.LineTrait, GI.LineStringTrait}, l1,\n    ::GI.LinearRingTrait, l2,\n)::Bool\n\nA line/linestring and a linear ring are equal if they share the same set of points going along the curve. Note that lines aren't closed by defintion, but rings are, so the line must have a repeated last point to be equal\n\n\n\n\n\nequals(\n    ::GI.LinearRingTrait, l1,\n    ::Union{GI.LineTrait, GI.LineStringTrait}, l2,\n)::Bool\n\nA linear ring and a line/linestring are equal if they share the same set of points going along the curve. Note that lines aren't closed by defintion, but rings are, so the line must have a repeated last point to be equal\n\n\n\n\n\nequals(\n    ::GI.LinearRingTrait, l1,\n    ::GI.LinearRingTrait, l2,\n)::Bool\n\nTwo linear rings are equal if they share the same set of points going along the curve. Note that rings are closed by definition, so they can have, but don't need, a repeated last point to be equal.\n\n\n\n\n\nequals(::GI.PolygonTrait, geom_a, ::GI.PolygonTrait, geom_b)::Bool\n\nTwo polygons are equal if they share the same exterior edge and holes.\n\n\n\n\n\nequals(::GI.PolygonTrait, geom_a, ::GI.MultiPolygonTrait, geom_b)::Bool\n\nA polygon and a multipolygon are equal if the multipolygon is composed of a single polygon that is equivalent to the given polygon.\n\n\n\n\n\nequals(::GI.MultiPolygonTrait, geom_a, ::GI.PolygonTrait, geom_b)::Bool\n\nA polygon and a multipolygon are equal if the multipolygon is composed of a single polygon that is equivalent to the given polygon.\n\n\n\n\n\nequals(::GI.PolygonTrait, geom_a, ::GI.PolygonTrait, geom_b)::Bool\n\nTwo multipolygons are equal if they share the same set of polygons.\n\n\n\n\n\n","category":"function"},{"location":"api/#GeometryOps.centroid","page":"API Reference","title":"GeometryOps.centroid","text":"centroid(geom, [T=Float64])::Tuple{T, T}\n\nReturns the centroid of a given line segment, linear ring, polygon, or mutlipolygon.\n\n\n\n\n\n","category":"function"},{"location":"api/#GeometryOps.distance","page":"API Reference","title":"GeometryOps.distance","text":"distance(point, geom, ::Type{T} = Float64)::T\n\nCalculates the  ditance from the geometry g1 to the point. The distance will always be positive or zero.\n\nThe method will differ based on the type of the geometry provided:     - The distance from a point to a point is just the Euclidean distance     between the points.     - The distance from a point to a line is the minimum distance from the point     to the closest point on the given line.     - The distance from a point to a linestring is the minimum distance from the     point to the closest segment of the linestring.     - The distance from a point to a linear ring is the minimum distance from     the point to the closest segment of the linear ring.     - The distance from a point to a polygon is zero if the point is within the     polygon and otherwise is the minimum distance from the point to an edge of     the polygon. This includes edges created by holes.     - The distance from a point to a multigeometry or a geometry collection is     the minimum distance between the point and any of the sub-geometries.\n\nResult will be of type T, where T is an optional argument with a default value of Float64.\n\n\n\n\n\n","category":"function"},{"location":"api/#GeometryOps.signed_distance","page":"API Reference","title":"GeometryOps.signed_distance","text":"signed_distance(point, geom, ::Type{T} = Float64)::T\n\nCalculates the signed distance from the geometry geom to the given point. Points within geom have a negative signed distance, and points outside of geom have a positive signed distance.     - The signed distance from a point to a point, line, linestring, or linear     ring is equal to the distance between the two.     - The signed distance from a point to a polygon is negative if the point is     within the polygon and is positive otherwise. The value of the distance is     the minimum distance from the point to an edge of the polygon. This includes     edges created by holes.     - The signed distance from a point to a multigeometry or a geometry     collection is the minimum signed distance between the point and any of the     sub-geometries.\n\nResult will be of type T, where T is an optional argument with a default value of Float64.\n\n\n\n\n\n","category":"function"},{"location":"api/#GeometryOps.area","page":"API Reference","title":"GeometryOps.area","text":"area(geom, ::Type{T} = Float64)::T\n\nReturns the area of a geometry or collection of geometries.  This is computed slightly differently for different geometries:\n\n- The area of a point/multipoint is always zero.\n- The area of a curve/multicurve is always zero.\n- The area of a polygon is the absolute value of the signed area.\n- The area multi-polygon is the sum of the areas of all of the sub-polygons.\n- The area of a geometry collection, feature collection of array/iterable \n    is the sum of the areas of all of the sub-geometries.\n\nResult will be of type T, where T is an optional argument with a default value of Float64.\n\n\n\n\n\n","category":"function"},{"location":"api/#GeometryOps.signed_area","page":"API Reference","title":"GeometryOps.signed_area","text":"signed_area(geom, ::Type{T} = Float64)::T\n\nReturns the signed area of a single geometry, based on winding order.  This is computed slighly differently for different geometries:\n\n- The signed area of a point is always zero.\n- The signed area of a curve is always zero.\n- The signed area of a polygon is computed with the shoelace formula and is\npositive if the polygon coordinates wind clockwise and negative if\ncounterclockwise.\n- You cannot compute the signed area of a multipolygon as it doesn't have a\nmeaning as each sub-polygon could have a different winding order.\n\nResult will be of type T, where T is an optional argument with a default value of Float64.\n\n\n\n\n\n","category":"function"},{"location":"api/#GeometryOps.angles","page":"API Reference","title":"GeometryOps.angles","text":"angles(geom, ::Type{T} = Float64)\n\nReturns the angles of a geometry or collection of geometries.  This is computed differently for different geometries:\n\n- The angles of a point is an empty vector.\n- The angles of a single line segment is an empty vector.\n- The angles of a linestring or linearring is a vector of angles formed by the curve.\n- The angles of a polygin is a vector of vectors of angles formed by each ring.\n- The angles of a multi-geometry collection is a vector of the angles of each of the\n    sub-geometries as defined above.\n\nResult will be a Vector, or nested set of vectors, of type T where an optional argument with a default value of Float64.\n\n\n\n\n\n","category":"function"},{"location":"api/#GeometryOps.embed_extent","page":"API Reference","title":"GeometryOps.embed_extent","text":"embed_extent(obj)\n\nRecursively wrap the object with a GeoInterface.jl geometry, calculating and adding an Extents.Extent to all objects.\n\nThis can improve performance when extents need to be checked multiple times, such when needing to check if many points are in geometries, and using their extents as a quick filter for obviously exterior points.\n\nKeywords\n\nthreaded: true or false. Whether to use multithreading. Defaults to false.\ncrs: The CRS to attach to geometries. Defaults to nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/#Barycentric-coordinates","page":"API Reference","title":"Barycentric coordinates","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"barycentric_coordinates\nbarycentric_coordinates!\nbarycentric_interpolate","category":"page"},{"location":"api/#Other-methods","page":"API Reference","title":"Other methods","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [GeometryOps]","category":"page"},{"location":"api/#GeometryOps.AbstractBarycentricCoordinateMethod","page":"API Reference","title":"GeometryOps.AbstractBarycentricCoordinateMethod","text":"abstract type AbstractBarycentricCoordinateMethod\n\nAbstract supertype for barycentric coordinate methods.   The subtypes may serve as dispatch types, or may cache  some information about the target polygon.  \n\nAPI\n\nThe following methods must be implemented for all subtypes:\n\nbarycentric_coordinates!(λs::Vector{<: Real}, method::AbstractBarycentricCoordinateMethod, exterior::Vector{<: Point{2, T1}}, point::Point{2, T2})\nbarycentric_interpolate(method::AbstractBarycentricCoordinateMethod, exterior::Vector{<: Point{2, T1}}, values::Vector{V}, point::Point{2, T2})::V\nbarycentric_interpolate(method::AbstractBarycentricCoordinateMethod, exterior::Vector{<: Point{2, T1}}, interiors::Vector{<: Vector{<: Point{2, T1}}} values::Vector{V}, point::Point{2, T2})::V\n\nThe rest of the methods will be implemented in terms of these, and have efficient dispatches for broadcasting.\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryOps.DouglasPeucker","page":"API Reference","title":"GeometryOps.DouglasPeucker","text":"DouglasPeucker <: SimplifyAlg\n\nDouglasPeucker(; number, ratio, tol)\n\nSimplifies geometries by removing points below tol distance from the line between its neighboring points.\n\nKeywords\n\nratio: the fraction of points that should remain after simplify.    Useful as it will generalise for large collections of objects.\nnumber: the number of points that should remain after simplify.   Less useful for large collections of mixed size objects.\ntol: the minimum distance a point will be from the line   joining its neighboring points.\n\nNote: user input tol is squared to avoid uneccesary computation in algorithm.\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryOps.LineOrientation","page":"API Reference","title":"GeometryOps.LineOrientation","text":"Enum LineOrientation\n\nEnum for the orientation of a line with respect to a curve. A line can be line_cross (crossing over the curve), line_hinge (crossing the endpoint of the curve), line_over (colinear with the curve), or line_out (not interacting with the curve).\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryOps.MeanValue","page":"API Reference","title":"GeometryOps.MeanValue","text":"MeanValue() <: AbstractBarycentricCoordinateMethod\n\nThis method calculates barycentric coordinates using the mean value method.\n\nReferences\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryOps.PointOrientation","page":"API Reference","title":"GeometryOps.PointOrientation","text":"Enum PointOrientation\n\nEnum for the orientation of a point with respect to a curve. A point can be point_in the curve, point_on the curve, or point_out of the curve.\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryOps.RadialDistance","page":"API Reference","title":"GeometryOps.RadialDistance","text":"RadialDistance <: SimplifyAlg\n\nSimplifies geometries by removing points less than tol distance from the line between its neighboring points.\n\nKeywords\n\nratio: the fraction of points that should remain after simplify.    Useful as it will generalise for large collections of objects.\nnumber: the number of points that should remain after simplify.   Less useful for large collections of mixed size objects.\ntol: the minimum distance between points.\n\nNote: user input tol is squared to avoid uneccesary computation in algorithm.\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryOps.SimplifyAlg","page":"API Reference","title":"GeometryOps.SimplifyAlg","text":"abstract type SimplifyAlg\n\nAbstract type for simplification algorithms.\n\nAPI\n\nFor now, the algorithm must hold the number, ratio and tol properties.  \n\nSimplification algorithm types can hook into the interface by implementing  the _simplify(trait, alg, geom) methods for whichever traits are necessary.\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryOps.VisvalingamWhyatt","page":"API Reference","title":"GeometryOps.VisvalingamWhyatt","text":"VisvalingamWhyatt <: SimplifyAlg\n\nVisvalingamWhyatt(; kw...)\n\nSimplifies geometries by removing points below tol distance from the line between its neighboring points.\n\nKeywords\n\nratio: the fraction of points that should remain after simplify.    Useful as it will generalise for large collections of objects.\nnumber: the number of points that should remain after simplify.   Less useful for large collections of mixed size objects.\ntol: the minimum area of a triangle made with a point and   its neighboring points.\n\nNote: user input tol is doubled to avoid uneccesary computation in algorithm.\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryOps._det-Union{Tuple{T2}, Tuple{T1}, Tuple{Union{Tuple{T1, T1}, StaticArraysCore.StaticArray{Tuple{2}, T1, 1}}, Union{Tuple{T2, T2}, StaticArraysCore.StaticArray{Tuple{2}, T2, 1}}}} where {T1<:Real, T2<:Real}","page":"API Reference","title":"GeometryOps._det","text":"_det(s1::Point2{T1}, s2::Point2{T2}) where {T1 <: Real, T2 <: Real}\n\nReturns the determinant of the matrix formed by hcat'ing two points s1 and s2.\n\nSpecifically, this is: \n\ns1[1] * s2[2] - s1[2] * s2[1]\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps._equals_curves-NTuple{4, Any}","page":"API Reference","title":"GeometryOps._equals_curves","text":"_equals_curves(c1, c2, closed_type1, closed_type2)::Bool\n\nTwo curves are equal if they share the same set of point, representing the same geometry. Both curves must must be composed of the same set of points, however, they do not have to wind in the same direction, or start on the same point to be equivalent. Inputs:     c1 first geometry     c2 second geometry     closedtype1::Bool true if c1 is closed by definition (polygon, linear ring)     closedtype2::Bool true if c2 is closed by definition (polygon, linear ring)\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.angles-Union{Tuple{Any}, Tuple{T}, Tuple{Any, Type{T}}} where T<:AbstractFloat","page":"API Reference","title":"GeometryOps.angles","text":"angles(geom, ::Type{T} = Float64)\n\nReturns the angles of a geometry or collection of geometries.  This is computed differently for different geometries:\n\n- The angles of a point is an empty vector.\n- The angles of a single line segment is an empty vector.\n- The angles of a linestring or linearring is a vector of angles formed by the curve.\n- The angles of a polygin is a vector of vectors of angles formed by each ring.\n- The angles of a multi-geometry collection is a vector of the angles of each of the\n    sub-geometries as defined above.\n\nResult will be a Vector, or nested set of vectors, of type T where an optional argument with a default value of Float64.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.apply-Union{Tuple{Target}, Tuple{Any, Type{Target}, Any}} where Target","page":"API Reference","title":"GeometryOps.apply","text":"apply(f, target::Type{<:AbstractTrait}, obj; kw...)\n\nReconstruct a geometry, feature, feature collection, or nested vectors of either using the function f on the target trait.\n\nf(target_geom) => x where x also has the target trait, or a trait that can be substituted. For example, swapping PolgonTrait to MultiPointTrait will fail if the outer object has MultiPolygonTrait, but should work if it has FeatureTrait.\n\nObjects \"shallower\" than the target trait are always completely rebuilt, like a Vector of FeatureCollectionTrait of FeatureTrait when the target has PolygonTrait and is held in the features. But \"deeper\" objects may remain unchanged - such as points and linear rings if the target is the same PolygonTrait.\n\nThe result is a functionally similar geometry with values depending on f\n\nthreaded: true or false. Whether to use multithreading. Defaults to false.\ncrs: The CRS to attach to geometries. Defaults to nothing.\ncalc_extent: true or false. Whether to calculate the extent. Defaults to false.\n\nExample\n\nFlipped point the order in any feature or geometry, or iterables of either:\n\n```julia import GeoInterface as GI import GeometryOps as GO geom = GI.Polygon([GI.LinearRing([(1, 2), (3, 4), (5, 6), (1, 2)]),                    GI.LinearRing([(3, 4), (5, 6), (6, 7), (3, 4)])])\n\nflipped_geom = GO.apply(GI.PointTrait, geom) do p     (GI.y(p), GI.x(p)) end\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.applyreduce","page":"API Reference","title":"GeometryOps.applyreduce","text":"applyreduce(f, op, target::Type{<:AbstractTrait}, obj; threaded)\n\nApply function f to all objects with the target trait, and reduce the result with an op like +. \n\nThe order and grouping of application of op is not guaranteed.\n\nIf threaded==true threads will be used over arrays and iterables,  feature collections and nested geometries.\n\n\n\n\n\n","category":"function"},{"location":"api/#GeometryOps.area-Union{Tuple{Any}, Tuple{T}, Tuple{Any, Type{T}}} where T<:AbstractFloat","page":"API Reference","title":"GeometryOps.area","text":"area(geom, ::Type{T} = Float64)::T\n\nReturns the area of a geometry or collection of geometries.  This is computed slightly differently for different geometries:\n\n- The area of a point/multipoint is always zero.\n- The area of a curve/multicurve is always zero.\n- The area of a polygon is the absolute value of the signed area.\n- The area multi-polygon is the sum of the areas of all of the sub-polygons.\n- The area of a geometry collection, feature collection of array/iterable \n    is the sum of the areas of all of the sub-geometries.\n\nResult will be of type T, where T is an optional argument with a default value of Float64.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.centroid-Union{Tuple{Any}, Tuple{T}, Tuple{Any, Type{T}}} where T","page":"API Reference","title":"GeometryOps.centroid","text":"centroid(geom, [T=Float64])::Tuple{T, T}\n\nReturns the centroid of a given line segment, linear ring, polygon, or mutlipolygon.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.centroid_and_area-Union{Tuple{Any}, Tuple{T}, Tuple{Any, Type{T}}} where T","page":"API Reference","title":"GeometryOps.centroid_and_area","text":"centroid_and_area(geom, [T=Float64])::(::Tuple{T, T}, ::Real)\n\nReturns the centroid and area of a given geometry.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.centroid_and_length-Union{Tuple{Any}, Tuple{T}, Tuple{Any, Type{T}}} where T","page":"API Reference","title":"GeometryOps.centroid_and_length","text":"centroid_and_length(geom, [T=Float64])::(::Tuple{T, T}, ::Real)\n\nReturns the centroid and length of a given line/ring. Note this is only valid for line strings and linear rings.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.contains-Tuple{Any, Any}","page":"API Reference","title":"GeometryOps.contains","text":"contains(g1::AbstractGeometry, g2::AbstractGeometry)::Bool\n\nReturn true if the second geometry is completely contained by the first geometry. The interiors of both geometries must intersect and the interior and boundary of the secondary (g2) must not intersect the exterior of the first (g1).\n\ncontains returns the exact opposite result of within.\n\nExamples\n\nimport GeometryOps as GO, GeoInterface as GI\nline = GI.LineString([(1, 1), (1, 2), (1, 3), (1, 4)])\npoint = GI.Point((1, 2))\n\nGO.contains(line, point)\n# output\ntrue\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.coveredby-Tuple{Any, Any}","page":"API Reference","title":"GeometryOps.coveredby","text":"coveredby(g1, g2)::Bool\n\nReturn true if the first geometry is completely covered by the second geometry. The interior and boundary of the primary geometry (g1) must not intersect the exterior of the secondary geometry (g2).\n\nFurthermore, coveredby returns the exact opposite result of covers. They are equivalent with the order of the arguments swapped.\n\nExamples\n\nimport GeometryOps as GO, GeoInterface as GI\np1 = GI.Point(0.0, 0.0)\np2 = GI.Point(1.0, 1.0)\nl1 = GI.Line([p1, p2])\n\nGO.coveredby(p1, l1)\n# output\ntrue\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.covers-Tuple{Any, Any}","page":"API Reference","title":"GeometryOps.covers","text":"covers(g1::AbstractGeometry, g2::AbstractGeometry)::Bool\n\nReturn true if the first geometry is completely covers the second geometry,  The exterior and boundary of the second geometry must not be outside of the interior and boundary of the first geometry. However, the interiors need not intersect.\n\ncovers returns the exact opposite result of coveredby.\n\nExamples\n\nimport GeometryOps as GO, GeoInterface as GI\nl1 = GI.LineString([(1, 1), (1, 2), (1, 3), (1, 4)])\nl2 = GI.LineString([(1, 1), (1, 2)])\n\nGO.covers(l1, l2)\n# output\ntrue\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.crosses-Tuple{Any, Any}","page":"API Reference","title":"GeometryOps.crosses","text":" crosses(geom1, geom2)::Bool\n\nReturn true if the intersection results in a geometry whose dimension is one less than the maximum dimension of the two source geometries and the intersection set is interior to both source geometries.\n\nTODO: broken\n\nExamples\n\nimport GeoInterface as GI, GeometryOps as GO\n# TODO: Add working example\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.difference-Union{Tuple{Target}, Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where {T<:AbstractFloat, Target<:GeoInterface.AbstractTrait}","page":"API Reference","title":"GeometryOps.difference","text":"difference(geom_a, geom_b, [T::Type]; target::Type)\n\nReturn the difference between two geometries as a list of geometries. Return an empty list if none are found. The type of the list will be constrained as much as possible given the input geometries. Furthermore, the user can provide a taget type as a keyword argument and a list of target geometries found in the difference will be returned. The user can also provide a float type that they would like the points of returned geometries to be. \n\nExample\n\nimport GeoInterface as GI, GeometryOps as GO\n\npoly1 = GI.Polygon([[[0.0, 0.0], [5.0, 5.0], [10.0, 0.0], [5.0, -5.0], [0.0, 0.0]]])\npoly2 = GI.Polygon([[[3.0, 0.0], [8.0, 5.0], [13.0, 0.0], [8.0, -5.0], [3.0, 0.0]]])\ndiff_poly = GO.difference(poly1, poly2; target = GI.PolygonTrait)\nGI.coordinates.(diff_poly)\n\n# output\n1-element Vector{Vector{Vector{Vector{Float64}}}}:\n [[[6.5, 3.5], [5.0, 5.0], [0.0, 0.0], [5.0, -5.0], [6.5, -3.5], [3.0, 0.0], [6.5, 3.5]]]\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.disjoint-Tuple{Any, Any}","page":"API Reference","title":"GeometryOps.disjoint","text":"disjoint(geom1, geom2)::Bool\n\nReturn true if the first geometry is disjoint from the second geometry.\n\nReturn true if the first geometry is disjoint from the second geometry. The interiors and boundaries of both geometries must not intersect.\n\nExamples\n\nimport GeometryOps as GO, GeoInterface as GI\n\nline = GI.LineString([(1, 1), (1, 2), (1, 3), (1, 4)])\npoint = (2, 2)\nGO.disjoint(point, line)\n\n# output\ntrue\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.distance-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T<:AbstractFloat","page":"API Reference","title":"GeometryOps.distance","text":"distance(point, geom, ::Type{T} = Float64)::T\n\nCalculates the  ditance from the geometry g1 to the point. The distance will always be positive or zero.\n\nThe method will differ based on the type of the geometry provided:     - The distance from a point to a point is just the Euclidean distance     between the points.     - The distance from a point to a line is the minimum distance from the point     to the closest point on the given line.     - The distance from a point to a linestring is the minimum distance from the     point to the closest segment of the linestring.     - The distance from a point to a linear ring is the minimum distance from     the point to the closest segment of the linear ring.     - The distance from a point to a polygon is zero if the point is within the     polygon and otherwise is the minimum distance from the point to an edge of     the polygon. This includes edges created by holes.     - The distance from a point to a multigeometry or a geometry collection is     the minimum distance between the point and any of the sub-geometries.\n\nResult will be of type T, where T is an optional argument with a default value of Float64.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.embed_extent-Tuple{Any}","page":"API Reference","title":"GeometryOps.embed_extent","text":"embed_extent(obj)\n\nRecursively wrap the object with a GeoInterface.jl geometry, calculating and adding an Extents.Extent to all objects.\n\nThis can improve performance when extents need to be checked multiple times, such when needing to check if many points are in geometries, and using their extents as a quick filter for obviously exterior points.\n\nKeywords\n\nthreaded: true or false. Whether to use multithreading. Defaults to false.\ncrs: The CRS to attach to geometries. Defaults to nothing.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.equals-NTuple{4, Any}","page":"API Reference","title":"GeometryOps.equals","text":"equals(trait_a, geom_a, trait_b, geom_b)\n\nTwo geometries which are not of the same type cannot be equal so they always return false.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.equals-Tuple{Any, Any}","page":"API Reference","title":"GeometryOps.equals","text":"equals(geom1, geom2)::Bool\n\nCompare two Geometries return true if they are the same geometry.\n\nExamples\n\nimport GeometryOps as GO, GeoInterface as GI\npoly1 = GI.Polygon([[(0,0), (0,5), (5,5), (5,0), (0,0)]])\npoly2 = GI.Polygon([[(0,0), (0,5), (5,5), (5,0), (0,0)]])\n\nGO.equals(poly1, poly2)\n# output\ntrue\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.equals-Tuple{GeoInterface.LinearRingTrait, Any, GeoInterface.LinearRingTrait, Any}","page":"API Reference","title":"GeometryOps.equals","text":"equals(\n    ::GI.LinearRingTrait, l1,\n    ::GI.LinearRingTrait, l2,\n)::Bool\n\nTwo linear rings are equal if they share the same set of points going along the curve. Note that rings are closed by definition, so they can have, but don't need, a repeated last point to be equal.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.equals-Tuple{GeoInterface.LinearRingTrait, Any, Union{GeoInterface.LineStringTrait, GeoInterface.LineTrait}, Any}","page":"API Reference","title":"GeometryOps.equals","text":"equals(\n    ::GI.LinearRingTrait, l1,\n    ::Union{GI.LineTrait, GI.LineStringTrait}, l2,\n)::Bool\n\nA linear ring and a line/linestring are equal if they share the same set of points going along the curve. Note that lines aren't closed by defintion, but rings are, so the line must have a repeated last point to be equal\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.equals-Tuple{GeoInterface.MultiPointTrait, Any, GeoInterface.MultiPointTrait, Any}","page":"API Reference","title":"GeometryOps.equals","text":"equals(::GI.MultiPointTrait, mp1, ::GI.MultiPointTrait, mp2)::Bool\n\nTwo multipoints are equal if they share the same set of points.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.equals-Tuple{GeoInterface.MultiPointTrait, Any, GeoInterface.PointTrait, Any}","page":"API Reference","title":"GeometryOps.equals","text":"equals(::GI.MultiPointTrait, mp1, ::GI.PointTrait, p2)::Bool\n\nA point and a multipoint are equal if the multipoint is composed of a single point that is equivalent to the given point.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.equals-Tuple{GeoInterface.MultiPolygonTrait, Any, GeoInterface.MultiPolygonTrait, Any}","page":"API Reference","title":"GeometryOps.equals","text":"equals(::GI.PolygonTrait, geom_a, ::GI.PolygonTrait, geom_b)::Bool\n\nTwo multipolygons are equal if they share the same set of polygons.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.equals-Tuple{GeoInterface.MultiPolygonTrait, Any, GeoInterface.PolygonTrait, Any}","page":"API Reference","title":"GeometryOps.equals","text":"equals(::GI.MultiPolygonTrait, geom_a, ::GI.PolygonTrait, geom_b)::Bool\n\nA polygon and a multipolygon are equal if the multipolygon is composed of a single polygon that is equivalent to the given polygon.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.equals-Tuple{GeoInterface.PointTrait, Any, GeoInterface.MultiPointTrait, Any}","page":"API Reference","title":"GeometryOps.equals","text":"equals(::GI.PointTrait, p1, ::GI.MultiPointTrait, mp2)::Bool\n\nA point and a multipoint are equal if the multipoint is composed of a single point that is equivalent to the given point.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.equals-Tuple{GeoInterface.PointTrait, Any, GeoInterface.PointTrait, Any}","page":"API Reference","title":"GeometryOps.equals","text":"equals(::GI.PointTrait, p1, ::GI.PointTrait, p2)::Bool\n\nTwo points are the same if they have the same x and y (and z if 3D) coordinates.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.equals-Tuple{GeoInterface.PolygonTrait, Any, GeoInterface.MultiPolygonTrait, Any}","page":"API Reference","title":"GeometryOps.equals","text":"equals(::GI.PolygonTrait, geom_a, ::GI.MultiPolygonTrait, geom_b)::Bool\n\nA polygon and a multipolygon are equal if the multipolygon is composed of a single polygon that is equivalent to the given polygon.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.equals-Tuple{GeoInterface.PolygonTrait, Any, GeoInterface.PolygonTrait, Any}","page":"API Reference","title":"GeometryOps.equals","text":"equals(::GI.PolygonTrait, geom_a, ::GI.PolygonTrait, geom_b)::Bool\n\nTwo polygons are equal if they share the same exterior edge and holes.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.equals-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.LineTrait}, Any, GeoInterface.LinearRingTrait, Any}","page":"API Reference","title":"GeometryOps.equals","text":"equals(\n    ::Union{GI.LineTrait, GI.LineStringTrait}, l1,\n    ::GI.LinearRingTrait, l2,\n)::Bool\n\nA line/linestring and a linear ring are equal if they share the same set of points going along the curve. Note that lines aren't closed by defintion, but rings are, so the line must have a repeated last point to be equal\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.equals-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.LineTrait}, Any, Union{GeoInterface.LineStringTrait, GeoInterface.LineTrait}, Any}","page":"API Reference","title":"GeometryOps.equals","text":"equals(\n    ::Union{GI.LineTrait, GI.LineStringTrait}, l1,\n    ::Union{GI.LineTrait, GI.LineStringTrait}, l2,\n)::Bool\n\nTwo lines/linestrings are equal if they share the same set of points going along the curve. Note that lines/linestrings aren't closed by defintion.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.equals-Union{Tuple{T}, Tuple{T, Any, T, Any}} where T","page":"API Reference","title":"GeometryOps.equals","text":"equals(::T, geom_a, ::T, geom_b)::Bool\n\nTwo geometries of the same type, which don't have a equals function to dispatch off of should throw an error.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.flatten-Union{Tuple{Target}, Tuple{Type{Target}, Any}} where Target<:GeoInterface.AbstractTrait","page":"API Reference","title":"GeometryOps.flatten","text":"flatten(target::Type{<:GI.AbstractTrait}, obj)\nflatten(f, target::Type{<:GI.AbstractTrait}, obj)\n\nLazily flatten any AbstractArray, iterator, FeatureCollectionTrait, FeatureTrait or AbstractGeometryTrait object obj, so that objects with the target trait are returned by the iterator.\n\nIf f is passed in it will be applied to the target geometries.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.flip-Tuple{Any}","page":"API Reference","title":"GeometryOps.flip","text":"flip(obj)\n\nSwap all of the x and y coordinates in obj, otherwise keeping the original structure (but not necessarily the original type).\n\nKeywords\n\nthreaded: true or false. Whether to use multithreading. Defaults to false.\ncrs: The CRS to attach to geometries. Defaults to nothing.\ncalc_extent: true or false. Whether to calculate the extent. Defaults to false.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.get_contours-Tuple{AbstractMatrix}","page":"API Reference","title":"GeometryOps.get_contours","text":"get_contours(A::AbstractMatrix)\n\nReturns contours as vectors of CartesianIndex.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.intersection-Union{Tuple{Target}, Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where {T<:AbstractFloat, Target<:GeoInterface.AbstractTrait}","page":"API Reference","title":"GeometryOps.intersection","text":"intersection(geom_a, geom_b, [T::Type]; target::Type)\n\nReturn the intersection between two geometries as a list of geometries. Return an empty list if none are found. The type of the list will be constrained as much as possible given the input geometries. Furthermore, the user can provide a taget type as a keyword argument and a list of target geometries found in the intersection will be returned. The user can also provide a float type that they would like the points of returned geometries to be. \n\nExample\n\nimport GeoInterface as GI, GeometryOps as GO\n\nline1 = GI.Line([(124.584961,-12.768946), (126.738281,-17.224758)])\nline2 = GI.Line([(123.354492,-15.961329), (127.22168,-14.008696)])\ninter_points = GO.intersection(line1, line2; target = GI.PointTrait)\nGI.coordinates.(inter_points)\n\n# output\n1-element Vector{Vector{Float64}}:\n [125.58375366067547, -14.83572303404496]\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.intersection_points-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T<:AbstractFloat","page":"API Reference","title":"GeometryOps.intersection_points","text":"intersection_points(\n    geom_a,\n    geom_b,\n)::Union{\n    ::Vector{::Tuple{::Real, ::Real}},\n    ::Nothing,\n}\n\nReturn a list of intersection points between two geometries of type GI.Point. If no intersection point was possible given geometry extents, returns an empty list.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.intersects-Tuple{Any, Any}","page":"API Reference","title":"GeometryOps.intersects","text":"intersects(geom1, geom2)::Bool\n\nReturn true if the interiors or boundaries of the two geometries interact.\n\nintersects returns the exact opposite result of disjoint.\n\nExample\n\nimport GeoInterface as GI, GeometryOps as GO\n\nline1 = GI.Line([(124.584961,-12.768946), (126.738281,-17.224758)])\nline2 = GI.Line([(123.354492,-15.961329), (127.22168,-14.008696)])\nGO.intersects(line1, line2)\n\n# output\ntrue\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.isclockwise-Tuple{Any}","page":"API Reference","title":"GeometryOps.isclockwise","text":"isclockwise(line::Union{LineString, Vector{Position}})::Bool\n\nTake a ring and return true or false whether or not the ring is clockwise or counter-clockwise.\n\nExample\n\nimport GeoInterface as GI, GeometryOps as GO\n\nring = GI.LinearRing([(0, 0), (1, 1), (1, 0), (0, 0)])\nGO.isclockwise(ring)\n\n# output\ntrue\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.isconcave-Tuple{Any}","page":"API Reference","title":"GeometryOps.isconcave","text":"isconcave(poly::Polygon)::Bool\n\nTake a polygon and return true or false as to whether it is concave or not.\n\nExamples\n\nimport GeoInterface as GI, GeometryOps as GO\n\npoly = GI.Polygon([[(0, 0), (0, 1), (1, 1), (1, 0), (0, 0)]])\nGO.isconcave(poly)\n\n# output\nfalse\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.overlaps-Tuple{Any, Any}","page":"API Reference","title":"GeometryOps.overlaps","text":"overlaps(geom1, geom2)::Bool\n\nCompare two Geometries of the same dimension and return true if their intersection set results in a geometry different from both but of the same dimension. This means one geometry cannot be within or contain the other and they cannot be equal\n\nExamples\n\nimport GeometryOps as GO, GeoInterface as GI\npoly1 = GI.Polygon([[(0,0), (0,5), (5,5), (5,0), (0,0)]])\npoly2 = GI.Polygon([[(1,1), (1,6), (6,6), (6,1), (1,1)]])\n\nGO.overlaps(poly1, poly2)\n# output\ntrue\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.overlaps-Tuple{GeoInterface.AbstractTrait, Any, GeoInterface.AbstractTrait, Any}","page":"API Reference","title":"GeometryOps.overlaps","text":"overlaps(::GI.AbstractTrait, geom1, ::GI.AbstractTrait, geom2)::Bool\n\nFor any non-specified pair, all have non-matching dimensions, return false.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.overlaps-Tuple{GeoInterface.LineTrait, Any, GeoInterface.LineTrait, Any}","page":"API Reference","title":"GeometryOps.overlaps","text":"overlaps(::GI.LineTrait, line1, ::GI.LineTrait, line)::Bool\n\nIf the lines overlap, meaning that they are colinear but each have one endpoint outside of the other line, return true. Else false.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.overlaps-Tuple{GeoInterface.MultiPointTrait, Any, GeoInterface.MultiPointTrait, Any}","page":"API Reference","title":"GeometryOps.overlaps","text":"overlaps(\n    ::GI.MultiPointTrait, points1,\n    ::GI.MultiPointTrait, points2,\n)::Bool\n\nIf the multipoints overlap, meaning some, but not all, of the points within the multipoints are shared, return true.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.overlaps-Tuple{GeoInterface.MultiPolygonTrait, Any, GeoInterface.MultiPolygonTrait, Any}","page":"API Reference","title":"GeometryOps.overlaps","text":"overlaps(\n    ::GI.MultiPolygonTrait, polys1,\n    ::GI.MultiPolygonTrait, polys2,\n)::Bool\n\nReturn true if at least one pair of polygons from multipolygons overlap. Else false.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.overlaps-Tuple{GeoInterface.MultiPolygonTrait, Any, GeoInterface.PolygonTrait, Any}","page":"API Reference","title":"GeometryOps.overlaps","text":"overlaps(\n    ::GI.MultiPolygonTrait, polys1,\n    ::GI.PolygonTrait, poly2,\n)::Bool\n\nReturn true if polygon overlaps with at least one of the polygons within the multipolygon. Else false.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.overlaps-Tuple{GeoInterface.PolygonTrait, Any, GeoInterface.MultiPolygonTrait, Any}","page":"API Reference","title":"GeometryOps.overlaps","text":"overlaps(\n    ::GI.PolygonTrait, poly1,\n    ::GI.MultiPolygonTrait, polys2,\n)::Bool\n\nReturn true if polygon overlaps with at least one of the polygons within the multipolygon. Else false.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.overlaps-Tuple{GeoInterface.PolygonTrait, Any, GeoInterface.PolygonTrait, Any}","page":"API Reference","title":"GeometryOps.overlaps","text":"overlaps(\n    trait_a::GI.PolygonTrait, poly_a,\n    trait_b::GI.PolygonTrait, poly_b,\n)::Bool\n\nIf the two polygons intersect with one another, but are not equal, return true. Else false.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.overlaps-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.Wrappers.LinearRing}, Any, Union{GeoInterface.LineStringTrait, GeoInterface.Wrappers.LinearRing}, Any}","page":"API Reference","title":"GeometryOps.overlaps","text":"overlaps(\n    ::Union{GI.LineStringTrait, GI.LinearRing}, line1,\n    ::Union{GI.LineStringTrait, GI.LinearRing}, line2,\n)::Bool\n\nIf the curves overlap, meaning that at least one edge of each curve overlaps, return true. Else false.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.polygon_to_line-Tuple{Any}","page":"API Reference","title":"GeometryOps.polygon_to_line","text":"polygon_to_line(poly::Polygon)\n\nConverts a Polygon to LineString or MultiLineString\n\nExamples\n\nimport GeometryOps as GO, GeoInterface as GI\n\npoly = GI.Polygon([[(-2.275543, 53.464547), (-2.275543, 53.489271), (-2.215118, 53.489271), (-2.215118, 53.464547), (-2.275543, 53.464547)]])\nGO.polygon_to_line(poly)\n# output\nGeoInterface.Wrappers.LineString{false, false, Vector{Tuple{Float64, Float64}}, Nothing, Nothing}([(-2.275543, 53.464547), (-2.275543, 53.489271), (-2.215118, 53.489271), (-2.215118, 53.464547), (-2.275543, 53.464547)], nothing, nothing)\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.polygonize-Tuple{AbstractMatrix}","page":"API Reference","title":"GeometryOps.polygonize","text":"polygonize(A; minpoints=10)\npolygonize(xs, ys, A; minpoints=10)\n\nConvert matrix A to polygons.\n\nIf xs and ys are passed in they are used as the pixel center points.\n\nKeywords\n\nminpoints: ignore polygons with less than minpoints points. \n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.rebuild-Tuple{Any, Any}","page":"API Reference","title":"GeometryOps.rebuild","text":"rebuild(geom, child_geoms)\n\nRebuild a geometry from child geometries.\n\nBy default geometries will be rebuilt as a GeoInterface.Wrappers geometry, but rebuild can have methods added to it to dispatch on geometries from other packages and specify how to rebuild them.\n\n(Maybe it should go into GeoInterface.jl)\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.reconstruct-Tuple{Any, Any}","page":"API Reference","title":"GeometryOps.reconstruct","text":"reconstruct(geom, components)\n\nReconstruct geom from an iterable of component objects that match its structure.\n\nAll objects in components must have the same GeoInterface.trait.\n\nUsusally used in combination with flatten.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.reproject-Tuple{Any}","page":"API Reference","title":"GeometryOps.reproject","text":"reproject(geometry; source_crs, target_crs, transform, always_xy, time)\nreproject(geometry, source_crs, target_crs; always_xy, time)\nreproject(geometry, transform; always_xy, time)\n\nReproject any GeoInterface.jl compatible geometry from source_crs to target_crs.\n\nThe returned object will be constructed from GeoInterface.WrapperGeometry geometries, wrapping views of a Vector{Proj.Point{D}}, where D is the dimension.\n\nArguments\n\ngeometry: Any GeoInterface.jl compatible geometries.\nsource_crs: the source coordinate referece system, as a GeoFormatTypes.jl object or a string.\ntarget_crs: the target coordinate referece system, as a GeoFormatTypes.jl object or a string.\n\nIf these a passed as keywords, transform will take priority. Without it target_crs is always needed, and source_crs is needed if it is not retreivable from the geometry with GeoInterface.crs(geometry).\n\nKeywords\n\nalways_xy: force x, y coordinate order, true by default.   false will expect and return points in the crs coordinate order.\ntime: the time for the coordinates. Inf by default.\nthreaded: true or false. Whether to use multithreading. Defaults to false.\ncrs: The CRS to attach to geometries. Defaults to nothing.\ncalc_extent: true or false. Whether to calculate the extent. Defaults to false.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.signed_area-Union{Tuple{Any}, Tuple{T}, Tuple{Any, Type{T}}} where T<:AbstractFloat","page":"API Reference","title":"GeometryOps.signed_area","text":"signed_area(geom, ::Type{T} = Float64)::T\n\nReturns the signed area of a single geometry, based on winding order.  This is computed slighly differently for different geometries:\n\n- The signed area of a point is always zero.\n- The signed area of a curve is always zero.\n- The signed area of a polygon is computed with the shoelace formula and is\npositive if the polygon coordinates wind clockwise and negative if\ncounterclockwise.\n- You cannot compute the signed area of a multipolygon as it doesn't have a\nmeaning as each sub-polygon could have a different winding order.\n\nResult will be of type T, where T is an optional argument with a default value of Float64.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.signed_distance-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T<:AbstractFloat","page":"API Reference","title":"GeometryOps.signed_distance","text":"signed_distance(point, geom, ::Type{T} = Float64)::T\n\nCalculates the signed distance from the geometry geom to the given point. Points within geom have a negative signed distance, and points outside of geom have a positive signed distance.     - The signed distance from a point to a point, line, linestring, or linear     ring is equal to the distance between the two.     - The signed distance from a point to a polygon is negative if the point is     within the polygon and is positive otherwise. The value of the distance is     the minimum distance from the point to an edge of the polygon. This includes     edges created by holes.     - The signed distance from a point to a multigeometry or a geometry     collection is the minimum signed distance between the point and any of the     sub-geometries.\n\nResult will be of type T, where T is an optional argument with a default value of Float64.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.simplify-Tuple{GeometryOps.SimplifyAlg, Any}","page":"API Reference","title":"GeometryOps.simplify","text":"simplify(obj; kw...)\nsimplify(::SimplifyAlg, obj; kw...)\n\nSimplify a geometry, feature, feature collection,  or nested vectors or a table of these.\n\nRadialDistance, DouglasPeucker, or  VisvalingamWhyatt algorithms are available,  listed in order of increasing quality but decreaseing performance.\n\nPoinTrait and MultiPointTrait are returned unchanged.\n\nThe default behaviour is simplify(DouglasPeucker(; kw...), obj). Pass in other SimplifyAlg to use other algorithms.\n\nKeywords\n\nprefilter_alg: SimplifyAlg algorithm used to pre-filter object before   using primary filtering algorithm.\nthreaded: true or false. Whether to use multithreading. Defaults to false.\ncrs: The CRS to attach to geometries. Defaults to nothing.\ncalc_extent: true or false. Whether to calculate the extent. Defaults to false.\n\nKeywords for DouglasPeucker are allowed when no algorithm is specified:\n\nKeywords\n\nratio: the fraction of points that should remain after simplify.    Useful as it will generalise for large collections of objects.\nnumber: the number of points that should remain after simplify.   Less useful for large collections of mixed size objects.\ntol: the minimum distance a point will be from the line   joining its neighboring points.\n\nExample\n\nSimplify a polygon to have six points:\n\nimport GeoInterface as GI\nimport GeometryOps as GO\n\npoly = GI.Polygon([[\n    [-70.603637, -33.399918],\n    [-70.614624, -33.395332],\n    [-70.639343, -33.392466],\n    [-70.659942, -33.394759],\n    [-70.683975, -33.404504],\n    [-70.697021, -33.419406],\n    [-70.701141, -33.434306],\n    [-70.700454, -33.446339],\n    [-70.694274, -33.458369],\n    [-70.682601, -33.465816],\n    [-70.668869, -33.472117],\n    [-70.646209, -33.473835],\n    [-70.624923, -33.472117],\n    [-70.609817, -33.468107],\n    [-70.595397, -33.458369],\n    [-70.587158, -33.442901],\n    [-70.587158, -33.426283],\n    [-70.590591, -33.414248],\n    [-70.594711, -33.406224],\n    [-70.603637, -33.399918]]])\n\nsimple = GO.simplify(poly; number=6)\nGI.npoint(simple)\n\n# output\n6\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.t_value-Union{Tuple{T2}, Tuple{T1}, Tuple{N}, Tuple{Union{Tuple{Vararg{T1, N}}, StaticArraysCore.StaticArray{Tuple{N}, T1, 1}}, Union{Tuple{Vararg{T1, N}}, StaticArraysCore.StaticArray{Tuple{N}, T1, 1}}, T2, T2}} where {N, T1<:Real, T2<:Real}","page":"API Reference","title":"GeometryOps.t_value","text":"t_value(sᵢ, sᵢ₊₁, rᵢ, rᵢ₊₁)\n\nReturns the \"T-value\" as described in Hormann's presentation [HormannPresentation] on how to calculate the mean-value coordinate.  \n\nHere, sᵢ is the vector from vertex vᵢ to the point, and rᵢ is the norm (length) of sᵢ. s must be Point and r must be real numbers.\n\ntᵢ = fracmathrmdetleft(sᵢ sᵢ₁right)rᵢ * rᵢ₁ + sᵢ  sᵢ₁\n\n[HormannPresentation]: K. Hormann and N. Sukumar. Generalized Barycentric Coordinates in Computer Graphics and Computational Mechanics. Taylor & Fancis, CRC Press, 2017.\n\n```\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.to_edges-Tuple{Any}","page":"API Reference","title":"GeometryOps.to_edges","text":"to_edges()\n\nConvert any geometry or collection of geometries into a flat  vector of Tuple{Tuple{Float64,Float64},Tuple{Float64,Float64}} edges.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.touches-Tuple{Any, Any}","page":"API Reference","title":"GeometryOps.touches","text":"touches(geom1, geom2)::Bool\n\nReturn true if the first geometry touches the second geometry. In other words, the two interiors cannot interact, but one of the geometries must have a boundary point that interacts with either the other geometies interior or boundary.\n\nExamples\n\nimport GeometryOps as GO, GeoInterface as GI\n\nl1 = GI.Line([(0.0, 0.0), (1.0, 0.0)])\nl2 = GI.Line([(1.0, 1.0), (1.0, -1.0)])\n\nGO.touches(l1, l2)\n# output\ntrue\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.transform-Tuple{Any, Any}","page":"API Reference","title":"GeometryOps.transform","text":"transform(f, obj)\n\nApply a function f to all the points in obj.\n\nPoints will be passed to f as an SVector to allow using CoordinateTransformations.jl and Rotations.jl  without hassle.\n\nSVector is also a valid GeoInterface.jl point, so will work in all GeoInterface.jl methods.\n\nExample\n\njulia> import GeoInterface as GI\n\njulia> import GeometryOps as GO\n\njulia> geom = GI.Polygon([GI.LinearRing([(1, 2), (3, 4), (5, 6), (1, 2)]), GI.LinearRing([(3, 4), (5, 6), (6, 7), (3, 4)])]);\n\njulia> f = CoordinateTransformations.Translation(3.5, 1.5)\nTranslation(3.5, 1.5)\n\njulia> GO.transform(f, geom)\nGeoInterface.Wrappers.Polygon{false, false, Vector{GeoInterface.Wrappers.LinearRing{false, false, Vector{StaticArraysCore.SVector{2, Float64}}, Nothing, Nothing}}, Nothing, Nothing}(GeoInterface.Wrappers.Linea\nrRing{false, false, Vector{StaticArraysCore.SVector{2, Float64}}, Nothing, Nothing}[GeoInterface.Wrappers.LinearRing{false, false, Vector{StaticArraysCore.SVector{2, Float64}}, Nothing, Nothing}(StaticArraysCo\nre.SVector{2, Float64}[[4.5, 3.5], [6.5, 5.5], [8.5, 7.5], [4.5, 3.5]], nothing, nothing), GeoInterface.Wrappers.LinearRing{false, false, Vector{StaticArraysCore.SVector{2, Float64}}, Nothing, Nothing}(StaticA\nrraysCore.SVector{2, Float64}[[6.5, 5.5], [8.5, 7.5], [9.5, 8.5], [6.5, 5.5]], nothing, nothing)], nothing, nothing)\n\nWith Rotations.jl you need to actuall multiply the Rotation by the SVector point, which is easy using an anonymous function.\n\njulia> using Rotations\n\njulia> GO.transform(p -> one(RotMatrix{2}) * p, geom)\nGeoInterface.Wrappers.Polygon{false, false, Vector{GeoInterface.Wrappers.LinearRing{false, false, Vector{StaticArraysCore.SVector{2, Int64}}, Nothing, Nothing}}, Nothing, Nothing}(GeoInterface.Wrappers.LinearR\ning{false, false, Vector{StaticArraysCore.SVector{2, Int64}}, Nothing, Nothing}[GeoInterface.Wrappers.LinearRing{false, false, Vector{StaticArraysCore.SVector{2, Int64}}, Nothing, Nothing}(StaticArraysCore.SVe\nctor{2, Int64}[[2, 1], [4, 3], [6, 5], [2, 1]], nothing, nothing), GeoInterface.Wrappers.LinearRing{false, false, Vector{StaticArraysCore.SVector{2, Int64}}, Nothing, Nothing}(StaticArraysCore.SVector{2, Int64\n}[[4, 3], [6, 5], [7, 6], [4, 3]], nothing, nothing)], nothing, nothing)\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.tuples-Tuple{Any}","page":"API Reference","title":"GeometryOps.tuples","text":"tuples(obj)\n\nConvert all points in obj to Tuples, wherever the are nested.\n\nReturns a similar object or collection of objects using GeoInterface.jl geometries wrapping Tuple points.\n\nKeywords\n\nthreaded: true or false. Whether to use multithreading. Defaults to false.\ncrs: The CRS to attach to geometries. Defaults to nothing.\ncalc_extent: true or false. Whether to calculate the extent. Defaults to false.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.union-Union{Tuple{Target}, Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where {T<:AbstractFloat, Target<:GeoInterface.AbstractTrait}","page":"API Reference","title":"GeometryOps.union","text":"union(geom_a, geom_b, [::Type{T}]; target::Type)\n\nReturn the union between two geometries as a list of geometries. Return an empty list if none are found. The type of the list will be constrained as much as possible given the input geometries. Furthermore, the user can provide a taget type as a keyword argument and a list of target geometries found in the difference will be returned. The user can also provide a float type 'T' that they would like the points of returned geometries to be. \n\nCalculates the union between two polygons.\n\nExample\n\nimport GeoInterface as GI, GeometryOps as GO\n\np1 = GI.Polygon([[(0.0, 0.0), (5.0, 5.0), (10.0, 0.0), (5.0, -5.0), (0.0, 0.0)]])\np2 = GI.Polygon([[(3.0, 0.0), (8.0, 5.0), (13.0, 0.0), (8.0, -5.0), (3.0, 0.0)]])\nunion_poly = GO.union(p1, p2; target = GI.PolygonTrait)\nGI.coordinates.(union_poly)\n\n# output\n1-element Vector{Vector{Vector{Vector{Float64}}}}:\n [[[6.5, 3.5], [5.0, 5.0], [0.0, 0.0], [5.0, -5.0], [6.5, -3.5], [8.0, -5.0], [13.0, 0.0], [8.0, 5.0], [6.5, 3.5]]]\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.unwrap","page":"API Reference","title":"GeometryOps.unwrap","text":"unwrap(target::Type{<:AbstractTrait}, obj)\nunwrap(f, target::Type{<:AbstractTrait}, obj)\n\nUnwrap the object to vectors, down to the target trait.\n\nIf f is passed in it will be applied to the target geometries as they are found.\n\n\n\n\n\n","category":"function"},{"location":"api/#GeometryOps.weighted_mean-Union{Tuple{WT}, Tuple{WT, Any, Any}} where WT<:Real","page":"API Reference","title":"GeometryOps.weighted_mean","text":"weighted_mean(weight::Real, x1, x2)\n\nReturns the weighted mean of x1 and x2, where weight is the weight of x1.\n\nSpecifically, calculates x1 * weight + x2 * (1 - weight).\n\nnote: Note\nThe idea for this method is that you can override this for custom types, like Color types, in extension modules.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryOps.within-Tuple{Any, Any}","page":"API Reference","title":"GeometryOps.within","text":"within(geom1, geom2)::Bool\n\nReturn true if the first geometry is completely within the second geometry. The interiors of both geometries must intersect and the interior and boundary of the primary geometry (geom1) must not intersect the exterior of the secondary geometry (geom2).\n\nFurthermore, within returns the exact opposite result of contains.\n\nExamples\n\nimport GeometryOps as GO, GeoInterface as GI\n\nline = GI.LineString([(1, 1), (1, 2), (1, 3), (1, 4)])\npoint = (1, 2)\nGO.within(point, line)\n\n# output\ntrue\n\n\n\n\n\n","category":"method"},{"location":"source/transformations/simplify/#Geometry-simplification","page":"Geometry simplification","title":"Geometry simplification","text":"","category":"section"},{"location":"source/transformations/simplify/","page":"Geometry simplification","title":"Geometry simplification","text":"This file holds implementations for the RadialDistance, Douglas-Peucker, and Visvalingam-Whyatt algorithms for simplifying geometries (specifically for polygons and lines).","category":"page"},{"location":"source/transformations/simplify/","page":"Geometry simplification","title":"Geometry simplification","text":"export simplify, VisvalingamWhyatt, DouglasPeucker, RadialDistance\n\nconst MIN_POINTS = 3\nconst SIMPLIFY_ALG_KEYWORDS = \"\"\"\n# Keywords\n\n- `ratio`: the fraction of points that should remain after `simplify`.\n    Useful as it will generalise for large collections of objects.\n- `number`: the number of points that should remain after `simplify`.\n    Less useful for large collections of mixed size objects.\n\"\"\"\nconst DOUGLAS_PEUCKER_KEYWORDS = \"\"\"\n$SIMPLIFY_ALG_KEYWORDS\n- `tol`: the minimum distance a point will be from the line\n    joining its neighboring points.\n\"\"\"\n\n\"\"\"\n    abstract type SimplifyAlg\n\nAbstract type for simplification algorithms.\n\n# API\n\nFor now, the algorithm must hold the `number`, `ratio` and `tol` properties.\n\nSimplification algorithm types can hook into the interface by implementing\nthe `_simplify(trait, alg, geom)` methods for whichever traits are necessary.\n\"\"\"\nabstract type SimplifyAlg end\n\n\"\"\"\n    simplify(obj; kw...)\n    simplify(::SimplifyAlg, obj; kw...)\n\nSimplify a geometry, feature, feature collection,\nor nested vectors or a table of these.\n\n`RadialDistance`, `DouglasPeucker`, or\n`VisvalingamWhyatt` algorithms are available,\nlisted in order of increasing quality but decreaseing performance.\n\n`PoinTrait` and `MultiPointTrait` are returned unchanged.\n\nThe default behaviour is `simplify(DouglasPeucker(; kw...), obj)`.\nPass in other `SimplifyAlg` to use other algorithms.","category":"page"},{"location":"source/transformations/simplify/","page":"Geometry simplification","title":"Geometry simplification","text":"Keywords","category":"page"},{"location":"source/transformations/simplify/","page":"Geometry simplification","title":"Geometry simplification","text":"- `prefilter_alg`: `SimplifyAlg` algorithm used to pre-filter object before\n    using primary filtering algorithm.\n$APPLY_KEYWORDS\n\n\nKeywords for DouglasPeucker are allowed when no algorithm is specified:\n\n$DOUGLAS_PEUCKER_KEYWORDS","category":"page"},{"location":"source/transformations/simplify/","page":"Geometry simplification","title":"Geometry simplification","text":"Example","category":"page"},{"location":"source/transformations/simplify/","page":"Geometry simplification","title":"Geometry simplification","text":"Simplify a polygon to have six points:\n\n```jldoctest\nimport GeoInterface as GI\nimport GeometryOps as GO\n\npoly = GI.Polygon([[\n    [-70.603637, -33.399918],\n    [-70.614624, -33.395332],\n    [-70.639343, -33.392466],\n    [-70.659942, -33.394759],\n    [-70.683975, -33.404504],\n    [-70.697021, -33.419406],\n    [-70.701141, -33.434306],\n    [-70.700454, -33.446339],\n    [-70.694274, -33.458369],\n    [-70.682601, -33.465816],\n    [-70.668869, -33.472117],\n    [-70.646209, -33.473835],\n    [-70.624923, -33.472117],\n    [-70.609817, -33.468107],\n    [-70.595397, -33.458369],\n    [-70.587158, -33.442901],\n    [-70.587158, -33.426283],\n    [-70.590591, -33.414248],\n    [-70.594711, -33.406224],\n    [-70.603637, -33.399918]]])\n\nsimple = GO.simplify(poly; number=6)\nGI.npoint(simple)","category":"page"},{"location":"source/transformations/simplify/","page":"Geometry simplification","title":"Geometry simplification","text":"output","category":"page"},{"location":"source/transformations/simplify/","page":"Geometry simplification","title":"Geometry simplification","text":"6\n```\n\"\"\"\nsimplify(alg::SimplifyAlg, data; kw...) = _simplify(alg, data; kw...)","category":"page"},{"location":"source/transformations/simplify/","page":"Geometry simplification","title":"Geometry simplification","text":"Default algorithm is DouglasPeucker","category":"page"},{"location":"source/transformations/simplify/","page":"Geometry simplification","title":"Geometry simplification","text":"simplify(\n    data; prefilter_alg = nothing,\n    calc_extent=false, threaded=false, crs=nothing, kw...,\n ) = _simplify(DouglasPeucker(; kw...), data; prefilter_alg, calc_extent, threaded, crs)\n\n#= For each algorithm, apply simplication to all curves, multipoints, and\npoints, reconstructing everything else around them. =#\nfunction _simplify(alg::SimplifyAlg, data; prefilter_alg = nothing, kw...)\n    simplifier(geom) = _simplify(GI.trait(geom), alg, geom; prefilter_alg = prefilter_alg)\n    return apply(\n        simplifier,\n        Union{GI.PolygonTrait, GI.AbstractCurveTrait, GI.MultiPointTrait, GI.PointTrait},\n        data;\n        kw...,\n    )\nend\n\n\n# For Point and MultiPoint traits we do nothing\n_simplify(::GI.PointTrait, alg, geom; kw...) = geom\n_simplify(::GI.MultiPointTrait, alg, geom; kw...) = geom\n\n# For curves, rings, and polygon we simplify\nfunction _simplify(\n    ::GI.AbstractCurveTrait, alg, geom;\n    prefilter_alg, preserve_endpoint = true,\n)\n    points = if isnothing(prefilter_alg)\n        tuple_points(geom)\n    else\n        _simplify(prefilter_alg, tuple_points(geom), preserve_endpoint)\n    end\n    return rebuild(geom, _simplify(alg, points, preserve_endpoint))\nend\n\nfunction _simplify(::GI.PolygonTrait, alg, geom;  kw...)\n    # Force treating children as LinearRing\n    simplifier(g) = _simplify(\n        GI.LinearRingTrait(), alg, g;\n        kw..., preserve_endpoint = false,\n    )\n    rebuilder(g) = rebuild(g, simplifier(g))\n    lrs = map(rebuilder, GI.getgeom(geom))\n    return rebuild(geom, lrs)\nend","category":"page"},{"location":"source/transformations/simplify/#Simplify-with-RadialDistance-Algorithm","page":"Geometry simplification","title":"Simplify with RadialDistance Algorithm","text":"","category":"section"},{"location":"source/transformations/simplify/","page":"Geometry simplification","title":"Geometry simplification","text":"\"\"\"\n    RadialDistance <: SimplifyAlg\n\nSimplifies geometries by removing points less than\n`tol` distance from the line between its neighboring points.\n\n$SIMPLIFY_ALG_KEYWORDS\n- `tol`: the minimum distance between points.\n\nNote: user input `tol` is squared to avoid uneccesary computation in algorithm.\n\"\"\"\n@kwdef struct RadialDistance <: SimplifyAlg\n    number::Union{Int64,Nothing} = nothing\n    ratio::Union{Float64,Nothing} = nothing\n    tol::Union{Float64,Nothing} = nothing\n\n    function RadialDistance(number, ratio, tol)\n        _checkargs(number, ratio, tol)","category":"page"},{"location":"source/transformations/simplify/","page":"Geometry simplification","title":"Geometry simplification","text":"square tolerance for reduced computation","category":"page"},{"location":"source/transformations/simplify/","page":"Geometry simplification","title":"Geometry simplification","text":"        tol = isnothing(tol) ? tol : tol^2\n        new(number, ratio, tol)\n    end\nend\n\nfunction _simplify(alg::RadialDistance, points::Vector, _)\n    previous = first(points)\n    distances = Array{Float64}(undef, length(points))\n    for i in eachindex(points)\n        point = points[i]\n        distances[i] = _squared_euclid_distance(Float64, point, previous)\n        previous = point\n    end\n    # Never remove the end points\n    distances[begin] = distances[end] = Inf\n    return _get_points(alg, points, distances)\nend","category":"page"},{"location":"source/transformations/simplify/#Simplify-with-DouglasPeucker-Algorithm","page":"Geometry simplification","title":"Simplify with DouglasPeucker Algorithm","text":"","category":"section"},{"location":"source/transformations/simplify/","page":"Geometry simplification","title":"Geometry simplification","text":"\"\"\"\n    DouglasPeucker <: SimplifyAlg\n\n    DouglasPeucker(; number, ratio, tol)\n\nSimplifies geometries by removing points below `tol`\ndistance from the line between its neighboring points.\n\n$DOUGLAS_PEUCKER_KEYWORDS\nNote: user input `tol` is squared to avoid uneccesary computation in algorithm.\n\"\"\"\n@kwdef struct DouglasPeucker <: SimplifyAlg\n    number::Union{Int64,Nothing} = nothing\n    ratio::Union{Float64,Nothing} = nothing\n    tol::Union{Float64,Nothing} = nothing\n\n    function DouglasPeucker(number, ratio, tol)\n        _checkargs(number, ratio, tol)","category":"page"},{"location":"source/transformations/simplify/","page":"Geometry simplification","title":"Geometry simplification","text":"square tolerance for reduced computation","category":"page"},{"location":"source/transformations/simplify/","page":"Geometry simplification","title":"Geometry simplification","text":"        tol = isnothing(tol) ? tol : tol^2\n        return new(number, ratio, tol)\n    end\nend\n\n#= Simplify using the DouglasPeucker algorithm - nice gif of process on wikipedia:\n(https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm). =#\nfunction _simplify(alg::DouglasPeucker, points::Vector, preserve_endpoint)\n    npoints = length(points)\n    npoints <= MIN_POINTS && return points","category":"page"},{"location":"source/transformations/simplify/","page":"Geometry simplification","title":"Geometry simplification","text":"Determine stopping critetia","category":"page"},{"location":"source/transformations/simplify/","page":"Geometry simplification","title":"Geometry simplification","text":"    max_points = if !isnothing(alg.tol)\n        npoints\n    else\n        npts = !isnothing(alg.number) ? alg.number : max(3, round(Int, alg.ratio * npoints))\n        npts ≥ npoints && return points\n        npts\n    end\n    max_tol = !isnothing(alg.tol) ? alg.tol : zero(Float64)","category":"page"},{"location":"source/transformations/simplify/","page":"Geometry simplification","title":"Geometry simplification","text":"Set up queue","category":"page"},{"location":"source/transformations/simplify/","page":"Geometry simplification","title":"Geometry simplification","text":"    queue = Vector{Tuple{Int, Int, Int, Float64}}()\n    queue_idx, queue_dist = 0, zero(Float64)\n    len_queue = 0","category":"page"},{"location":"source/transformations/simplify/","page":"Geometry simplification","title":"Geometry simplification","text":"Set up results vector","category":"page"},{"location":"source/transformations/simplify/","page":"Geometry simplification","title":"Geometry simplification","text":"    results = Vector{Int}(undef, max_points + (preserve_endpoint ? 0 : 1))\n    results[1], results[2] = 1, npoints","category":"page"},{"location":"source/transformations/simplify/","page":"Geometry simplification","title":"Geometry simplification","text":"Loop through points until stopping criteria are fulfilled","category":"page"},{"location":"source/transformations/simplify/","page":"Geometry simplification","title":"Geometry simplification","text":"    i = 2  # already have first and last point added\n    start_idx, end_idx = 1, npoints\n    max_idx, max_dist = _find_max_squared_dist(points, start_idx, end_idx)\n    while i ≤ min(MIN_POINTS + 1, max_points) || (i < max_points && max_dist > max_tol)","category":"page"},{"location":"source/transformations/simplify/","page":"Geometry simplification","title":"Geometry simplification","text":"Add next point to results","category":"page"},{"location":"source/transformations/simplify/","page":"Geometry simplification","title":"Geometry simplification","text":"        i += 1\n        results[i] = max_idx","category":"page"},{"location":"source/transformations/simplify/","page":"Geometry simplification","title":"Geometry simplification","text":"Determine which point to add next by checking left and right of point","category":"page"},{"location":"source/transformations/simplify/","page":"Geometry simplification","title":"Geometry simplification","text":"        left_idx, left_dist = _find_max_squared_dist(points, start_idx, max_idx)\n        right_idx, right_dist = _find_max_squared_dist(points, max_idx, end_idx)\n        left_vals = (start_idx, left_idx, max_idx, left_dist)\n        right_vals = (max_idx, right_idx, end_idx, right_dist)","category":"page"},{"location":"source/transformations/simplify/","page":"Geometry simplification","title":"Geometry simplification","text":"Add and remove values from queue","category":"page"},{"location":"source/transformations/simplify/","page":"Geometry simplification","title":"Geometry simplification","text":"        if queue_dist > left_dist && queue_dist > right_dist","category":"page"},{"location":"source/transformations/simplify/","page":"Geometry simplification","title":"Geometry simplification","text":"Value in queue is next value to add to results","category":"page"},{"location":"source/transformations/simplify/","page":"Geometry simplification","title":"Geometry simplification","text":"            start_idx, max_idx, end_idx, max_dist = queue[queue_idx]","category":"page"},{"location":"source/transformations/simplify/","page":"Geometry simplification","title":"Geometry simplification","text":"Add left and/or right values to queue or delete used queue value","category":"page"},{"location":"source/transformations/simplify/","page":"Geometry simplification","title":"Geometry simplification","text":"            if left_dist > 0\n                queue[queue_idx] = left_vals\n                if right_dist > 0\n                    push!(queue, right_vals)\n                    len_queue += 1\n                end\n            elseif right_dist > 0\n                queue[queue_idx] = right_vals\n            else\n                deleteat!(queue, queue_idx)\n                len_queue -= 1\n            end","category":"page"},{"location":"source/transformations/simplify/","page":"Geometry simplification","title":"Geometry simplification","text":"Determine new maximum queue value","category":"page"},{"location":"source/transformations/simplify/","page":"Geometry simplification","title":"Geometry simplification","text":"            queue_dist, queue_idx = !isempty(queue) ?\n                findmax(x -> x[4], queue) : (zero(Float64), 0)\n        elseif left_dist > right_dist  # use left value as next value to add to results\n            push!(queue, right_vals)  # add right value to queue\n            len_queue += 1\n            if right_dist > queue_dist\n                queue_dist = right_dist\n                queue_idx = len_queue\n            end\n            start_idx, max_idx, end_idx, max_dist = left_vals\n        else  # use right value as next value to add to results\n            push!(queue, left_vals)  # add left value to queue\n            len_queue += 1\n            if left_dist > queue_dist\n                queue_dist = left_dist\n                queue_idx = len_queue\n            end\n            start_idx, max_idx, end_idx, max_dist = right_vals\n        end\n    end\n    sorted_results = sort!(@view results[1:i])\n    if !preserve_endpoint && i > 3\n        endpt_dist = _squared_distance_line(Float64, points[1], points[end - 1], points[2])\n        if !isnothing(alg.tol)\n            if endpt_dist < max_tol\n                results[i] = results[2]\n                sorted_results = @view results[2:i]\n            end\n        else\n            if endpt_dist < max_dist\n                insert!(results, searchsortedfirst(sorted_results, max_idx), max_idx)\n                results[i+1] = results[2]\n                sorted_results = @view results[2:i+1]\n            end\n        end\n    end\n    return points[sorted_results]\nend\n\n#= find maximum distance of any point between the start_idx and end_idx to the line formed\nby conencting the points at start_idx and end_idx. Note that the first index of maximum\nvalue will be used, which might cause differences in results from other algorithms.=#\nfunction _find_max_squared_dist(points, start_idx, end_idx)\n    max_idx = start_idx\n    max_dist = zero(Float64)\n    for i in (start_idx + 1):(end_idx - 1)\n        d = _squared_distance_line(Float64, points[i], points[start_idx], points[end_idx])\n        if d > max_dist\n            max_dist = d\n            max_idx = i\n        end\n    end\n    return max_idx, max_dist\nend","category":"page"},{"location":"source/transformations/simplify/#Simplify-with-VisvalingamWhyatt-Algorithm","page":"Geometry simplification","title":"Simplify with VisvalingamWhyatt Algorithm","text":"","category":"section"},{"location":"source/transformations/simplify/","page":"Geometry simplification","title":"Geometry simplification","text":"\"\"\"\n    VisvalingamWhyatt <: SimplifyAlg\n\n    VisvalingamWhyatt(; kw...)\n\nSimplifies geometries by removing points below `tol`\ndistance from the line between its neighboring points.\n\n$SIMPLIFY_ALG_KEYWORDS\n- `tol`: the minimum area of a triangle made with a point and\n    its neighboring points.\nNote: user input `tol` is doubled to avoid uneccesary computation in algorithm.\n\"\"\"\n@kwdef struct VisvalingamWhyatt <: SimplifyAlg\n    number::Union{Int,Nothing} = nothing\n    ratio::Union{Float64,Nothing} = nothing\n    tol::Union{Float64,Nothing} = nothing\n\n    function VisvalingamWhyatt(number, ratio, tol)\n        _checkargs(number, ratio, tol)","category":"page"},{"location":"source/transformations/simplify/","page":"Geometry simplification","title":"Geometry simplification","text":"double tolerance for reduced computation","category":"page"},{"location":"source/transformations/simplify/","page":"Geometry simplification","title":"Geometry simplification","text":"        tol = isnothing(tol) ? tol : tol*2\n        return new(number, ratio, tol)\n    end\nend\n\nfunction _simplify(alg::VisvalingamWhyatt, points::Vector, _)\n    length(points) <= MIN_POINTS && return points\n    areas = _build_tolerances(_triangle_double_area, points)\n    return _get_points(alg, points, areas)\nend","category":"page"},{"location":"source/transformations/simplify/","page":"Geometry simplification","title":"Geometry simplification","text":"Calculates double the area of a triangle given its vertices","category":"page"},{"location":"source/transformations/simplify/","page":"Geometry simplification","title":"Geometry simplification","text":"_triangle_double_area(p1, p2, p3) =\n    abs(p1[1] * (p2[2] - p3[2]) + p2[1] * (p3[2] - p1[2]) + p3[1] * (p1[2] - p2[2]))","category":"page"},{"location":"source/transformations/simplify/#Shared-utils","page":"Geometry simplification","title":"Shared utils","text":"","category":"section"},{"location":"source/transformations/simplify/","page":"Geometry simplification","title":"Geometry simplification","text":"function _build_tolerances(f, points)\n    nmax = length(points)\n    real_tolerances = _flat_tolerances(f, points)\n\n    tolerances = copy(real_tolerances)\n    i = collect(1:nmax)\n\n    min_vert = argmin(tolerances)\n    this_tolerance = tolerances[min_vert]\n    _remove!(tolerances, min_vert)\n    deleteat!(i, min_vert)\n\n    while this_tolerance < Inf\n        skip = false\n\n        if min_vert < length(i)\n            right_tolerance = f(\n                points[i[min_vert - 1]],\n                points[i[min_vert]],\n                points[i[min_vert + 1]],\n            )\n            if right_tolerance <= this_tolerance\n                right_tolerance = this_tolerance\n                skip = min_vert == 1\n            end\n\n            real_tolerances[i[min_vert]] = right_tolerance\n            tolerances[min_vert] = right_tolerance\n        end\n\n        if min_vert > 2\n            left_tolerance = f(\n                points[i[min_vert - 2]],\n                points[i[min_vert - 1]],\n                points[i[min_vert]],\n            )\n            if left_tolerance <= this_tolerance\n                left_tolerance = this_tolerance\n                skip = min_vert == 2\n            end\n            real_tolerances[i[min_vert - 1]] = left_tolerance\n            tolerances[min_vert - 1] = left_tolerance\n        end\n\n        if !skip\n            min_vert = argmin(tolerances)\n        end\n        deleteat!(i, min_vert)\n        this_tolerance = tolerances[min_vert]\n        _remove!(tolerances, min_vert)\n    end\n\n    return real_tolerances\nend\n\nfunction tuple_points(geom)\n    points = Array{Tuple{Float64,Float64}}(undef, GI.npoint(geom))\n    for (i, p) in enumerate(GI.getpoint(geom))\n        points[i] = (GI.x(p), GI.y(p))\n    end\n    return points\nend\n\nfunction _get_points(alg, points, tolerances)\n    # This assumes that `alg` has the properties\n    # `tol`, `number`, and `ratio` available...\n    tol = alg.tol\n    number = alg.number\n    ratio = alg.ratio\n    bit_indices = if !isnothing(tol)\n        _tol_indices(alg.tol::Float64, points, tolerances)\n    elseif !isnothing(number)\n        _number_indices(alg.number::Int64, points, tolerances)\n    else\n        _ratio_indices(alg.ratio::Float64, points, tolerances)\n    end\n    return points[bit_indices]\nend\n\nfunction _tol_indices(tol, points, tolerances)\n    tolerances .>= tol\nend\n\nfunction _number_indices(n, points, tolerances)\n    tol = partialsort(tolerances, length(points) - n + 1)\n    bit_indices = _tol_indices(tol, points, tolerances)\n    nselected = sum(bit_indices)\n    # If there are multiple values exactly at `tol` we will get\n    # the wrong output length. So we need to remove some.\n    while nselected > n\n        min_tol = Inf\n        min_i = 0\n        for i in eachindex(bit_indices)\n            bit_indices[i] || continue\n            if tolerances[i] < min_tol\n                min_tol = tolerances[i]\n                min_i = i\n            end\n        end\n        nselected -= 1\n        bit_indices[min_i] = false\n    end\n    return bit_indices\nend\n\nfunction _ratio_indices(r, points, tolerances)\n    n = max(3, round(Int, r * length(points)))\n    return _number_indices(n, points, tolerances)\nend\n\nfunction _flat_tolerances(f, points)\n    result = Array{Float64}(undef, length(points))\n    result[1] = result[end] = Inf\n\n    for i in 2:length(result) - 1\n        result[i] = f(points[i-1], points[i], points[i+1])\n    end\n    return result\nend\n\n_remove!(s, i) = s[i:end-1] .= s[i+1:end]","category":"page"},{"location":"source/transformations/simplify/","page":"Geometry simplification","title":"Geometry simplification","text":"Check SimplifyAlgs inputs to make sure they are valid for below algorithms","category":"page"},{"location":"source/transformations/simplify/","page":"Geometry simplification","title":"Geometry simplification","text":"function _checkargs(number, ratio, tol)\n    count(isnothing, (number, ratio, tol)) == 2 ||\n        error(\"Must provide one of `number`, `ratio` or `tol` keywords\")\n    if !isnothing(number)\n        if number < MIN_POINTS\n            error(\"`number` must be $MIN_POINTS or larger. Got $number\")\n        end\n    elseif !isnothing(ratio)\n        if ratio <= 0 || ratio > 1\n            error(\"`ratio` must be 0 < ratio <= 1. Got $ratio\")\n        end\n    else  # !isnothing(tol)\n        if tol ≤ 0\n            error(\"`tol` must be a positive number. Got $tol\")\n        end\n    end\n    return nothing\nend","category":"page"},{"location":"source/transformations/simplify/","page":"Geometry simplification","title":"Geometry simplification","text":"","category":"page"},{"location":"source/transformations/simplify/","page":"Geometry simplification","title":"Geometry simplification","text":"This page was generated using Literate.jl.","category":"page"},{"location":"source/methods/geom_relations/within/#Within","page":"Within","title":"Within","text":"","category":"section"},{"location":"source/methods/geom_relations/within/","page":"Within","title":"Within","text":"export within","category":"page"},{"location":"source/methods/geom_relations/within/#What-is-within?","page":"Within","title":"What is within?","text":"","category":"section"},{"location":"source/methods/geom_relations/within/","page":"Within","title":"Within","text":"The within function checks if one geometry is inside another geometry. This requires that the two interiors intersect and that the interior and boundary of the first geometry is not in the exterior of the second geometry.","category":"page"},{"location":"source/methods/geom_relations/within/","page":"Within","title":"Within","text":"To provide an example, consider these two lines:","category":"page"},{"location":"source/methods/geom_relations/within/","page":"Within","title":"Within","text":"import GeometryOps as GO\nimport GeoInterface as GI\nusing Makie\nusing CairoMakie\n\nl1 = GI.LineString([(0.0, 0.0), (1.0, 0.0), (0.0, 0.1)])\nl2 = GI.LineString([(0.25, 0.0), (0.75, 0.0)])\nf, a, p = lines(GI.getpoint(l1), color = :blue)\nscatter!(GI.getpoint(l1), color = :blue)\nlines!(GI.getpoint(l2), color = :orange)\nscatter!(GI.getpoint(l2), color = :orange)\nf","category":"page"},{"location":"source/methods/geom_relations/within/","page":"Within","title":"Within","text":"We can see that all of the points and edges of l2 are within l1, so l2 is within l1, but l1 is not within l2","category":"page"},{"location":"source/methods/geom_relations/within/","page":"Within","title":"Within","text":"GO.within(l1, l2)  # false\nGO.within(l2, l1)  # true","category":"page"},{"location":"source/methods/geom_relations/within/#Implementation","page":"Within","title":"Implementation","text":"","category":"section"},{"location":"source/methods/geom_relations/within/","page":"Within","title":"Within","text":"This is the GeoInterface-compatible implementation.","category":"page"},{"location":"source/methods/geom_relations/within/","page":"Within","title":"Within","text":"First, we implement a wrapper method that dispatches to the correct implementation based on the geometry trait.","category":"page"},{"location":"source/methods/geom_relations/within/","page":"Within","title":"Within","text":"Each of these calls a method in the geomgeomprocessors file. The methods in this file determine if the given geometries meet a set of criteria. For the within function and arguments g1 and g2, this criteria is as follows:     - points of g1 are allowed to be in the interior of g2 (either through     overlap or crossing for lines)     - points of g1 are allowed to be on the boundary of g2     - points of g1 are not allowed to be in the exterior of g2     - at least one point of g1 is required to be in the interior of g2     - no points of g1 are required to be on the boundary of g2     - no points of g1 are required to be in the exterior of g2","category":"page"},{"location":"source/methods/geom_relations/within/","page":"Within","title":"Within","text":"The code for the specific implementations is in the geomgeomprocessors file.","category":"page"},{"location":"source/methods/geom_relations/within/","page":"Within","title":"Within","text":"const WITHIN_POINT_ALLOWS = (in_allow = true, on_allow = false, out_allow = false)\nconst WITHIN_CURVE_ALLOWS = (over_allow = true, cross_allow = true, on_allow = true, out_allow = false)\nconst WITHIN_POLYGON_ALLOWS = (in_allow = true, on_allow = true, out_allow = false)\nconst WITHIN_REQUIRES = (in_require = true, on_require = false, out_require = false)\n\n\"\"\"\n    within(geom1, geom2)::Bool\n\nReturn `true` if the first geometry is completely within the second geometry.\nThe interiors of both geometries must intersect and the interior and boundary of\nthe primary geometry (geom1) must not intersect the exterior of the secondary\ngeometry (geom2).\n\nFurthermore, `within` returns the exact opposite result of `contains`.\n\n# Examples\n```jldoctest setup=:(using GeometryOps, GeometryBasics)\nimport GeometryOps as GO, GeoInterface as GI\n\nline = GI.LineString([(1, 1), (1, 2), (1, 3), (1, 4)])\npoint = (1, 2)\nGO.within(point, line)","category":"page"},{"location":"source/methods/geom_relations/within/","page":"Within","title":"Within","text":"output","category":"page"},{"location":"source/methods/geom_relations/within/","page":"Within","title":"Within","text":"true\n```\n\"\"\"\nwithin(g1, g2) = _within(trait(g1), g1, trait(g2), g2)","category":"page"},{"location":"source/methods/geom_relations/within/#Convert-features-to-geometries","page":"Within","title":"Convert features to geometries","text":"","category":"section"},{"location":"source/methods/geom_relations/within/","page":"Within","title":"Within","text":"_within(::GI.FeatureTrait, g1, ::Any, g2) = within(GI.geometry(g1), g2)\n_within(::Any, g1, t2::GI.FeatureTrait, g2) = within(g1, GI.geometry(g2))\n_within(::FeatureTrait, g1, ::FeatureTrait, g2) = within(GI.geometry(g1), GI.geometry(g2))","category":"page"},{"location":"source/methods/geom_relations/within/#Points-within-geometries","page":"Within","title":"Points within geometries","text":"","category":"section"},{"location":"source/methods/geom_relations/within/","page":"Within","title":"Within","text":"Point is within another point if those points are equal.","category":"page"},{"location":"source/methods/geom_relations/within/","page":"Within","title":"Within","text":"_within(\n    ::GI.PointTrait, g1,\n    ::GI.PointTrait, g2,\n) = equals(g1, g2)\n\n#= Point is within a linestring if it is on a vertex or an edge of that line,\nexcluding the start and end vertex if the line is not closed. =#\n_within(\n    ::GI.PointTrait, g1,\n    ::Union{GI.LineTrait, GI.LineStringTrait}, g2,\n) = _point_curve_process(\n    g1, g2;\n    WITHIN_POINT_ALLOWS...,\n    closed_curve = false,\n)","category":"page"},{"location":"source/methods/geom_relations/within/","page":"Within","title":"Within","text":"Point is within a linearring if it is on a vertex or an edge of that ring.","category":"page"},{"location":"source/methods/geom_relations/within/","page":"Within","title":"Within","text":"_within(\n    ::GI.PointTrait, g1,\n    ::GI.LinearRingTrait, g2,\n) = _point_curve_process(\n    g1, g2;\n    WITHIN_POINT_ALLOWS...,\n    closed_curve = true,\n)\n\n#= Point is within a polygon if it is inside of that polygon, excluding edges,\nvertices, and holes. =#\n_within(\n    ::GI.PointTrait, g1,\n    ::GI.PolygonTrait, g2,\n) = _point_polygon_process(\n    g1, g2;\n    WITHIN_POINT_ALLOWS...,\n)","category":"page"},{"location":"source/methods/geom_relations/within/","page":"Within","title":"Within","text":"No geometries other than points can be within points","category":"page"},{"location":"source/methods/geom_relations/within/","page":"Within","title":"Within","text":"_within(\n    ::Union{GI.AbstractCurveTrait, GI.PolygonTrait}, g1,\n    ::GI.PointTrait, g2,\n) = false","category":"page"},{"location":"source/methods/geom_relations/within/#Lines-within-geometries","page":"Within","title":"Lines within geometries","text":"","category":"section"},{"location":"source/methods/geom_relations/within/","page":"Within","title":"Within","text":"#= Linestring is within another linestring if their interiors intersect and no\npoints of the first line are in the exterior of the second line. =#\n_within(\n    ::Union{GI.LineTrait, GI.LineStringTrait}, g1,\n    ::Union{GI.LineTrait, GI.LineStringTrait}, g2,\n) = _line_curve_process(\n    g1, g2;\n    WITHIN_CURVE_ALLOWS...,\n    WITHIN_REQUIRES...,\n    closed_line = false,\n    closed_curve = false,\n)\n\n#= Linestring is within a linear ring if their interiors intersect and no points\nof the line are in the exterior of the ring. =#\n_within(\n    ::Union{GI.LineTrait, GI.LineStringTrait}, g1,\n    ::GI.LinearRingTrait, g2,\n) = _line_curve_process(\n    g1, g2;\n    WITHIN_CURVE_ALLOWS...,\n    WITHIN_REQUIRES...,\n    closed_line = false,\n    closed_curve = true,\n)\n\n#= Linestring is within a polygon if their interiors intersect and no points of\nthe line are in the exterior of the polygon, although they can be on an edge. =#\n_within(\n    ::Union{GI.LineTrait, GI.LineStringTrait}, g1,\n    ::GI.PolygonTrait, g2,\n) = _line_polygon_process(\n    g1, g2;\n    WITHIN_POLYGON_ALLOWS...,\n    WITHIN_REQUIRES...,\n    closed_line = false,\n)","category":"page"},{"location":"source/methods/geom_relations/within/#Rings-covered-by-geometries","page":"Within","title":"Rings covered by geometries","text":"","category":"section"},{"location":"source/methods/geom_relations/within/","page":"Within","title":"Within","text":"#= Linearring is within a linestring if their interiors intersect and no points\nof the ring are in the exterior of the line. =#\n_within(\n    ::GI.LinearRingTrait, g1,\n    ::Union{GI.LineTrait, GI.LineStringTrait}, g2,\n) = _line_curve_process(\n    g1, g2;\n    WITHIN_CURVE_ALLOWS...,\n    WITHIN_REQUIRES...,\n    closed_line = true,\n    closed_curve = false,\n)\n\n#= Linearring is within another linearring if their interiors intersect and no\npoints of the first ring are in the exterior of the second ring. =#\n_within(\n    ::GI.LinearRingTrait, g1,\n    ::GI.LinearRingTrait, g2,\n) = _line_curve_process(\n    g1, g2;\n    WITHIN_CURVE_ALLOWS...,\n    WITHIN_REQUIRES...,\n    closed_line = true,\n    closed_curve = true,\n)\n\n#= Linearring is within a polygon if their interiors intersect and no points of\nthe ring are in the exterior of the polygon, although they can be on an edge. =#\n_within(\n    ::GI.LinearRingTrait, g1,\n    ::GI.PolygonTrait, g2,\n) = _line_polygon_process(\n    g1, g2;\n    WITHIN_POLYGON_ALLOWS...,\n    WITHIN_REQUIRES...,\n    closed_line = true,\n)","category":"page"},{"location":"source/methods/geom_relations/within/#Polygons-within-geometries","page":"Within","title":"Polygons within geometries","text":"","category":"section"},{"location":"source/methods/geom_relations/within/","page":"Within","title":"Within","text":"#= Polygon is within another polygon if the interior of the first polygon\nintersects with the interior of the second and no points of the first polygon\nare outside of the second polygon. =#\n_within(\n    ::GI.PolygonTrait, g1,\n    ::GI.PolygonTrait, g2,\n) = _polygon_polygon_process(\n    g1, g2;\n    WITHIN_POLYGON_ALLOWS...,\n    WITHIN_REQUIRES...,\n)","category":"page"},{"location":"source/methods/geom_relations/within/","page":"Within","title":"Within","text":"Polygons cannot be within any curves","category":"page"},{"location":"source/methods/geom_relations/within/","page":"Within","title":"Within","text":"_within(\n    ::GI.PolygonTrait, g1,\n    ::GI.AbstractCurveTrait, g2,\n) = false","category":"page"},{"location":"source/methods/geom_relations/within/#Geometries-within-multi-geometry/geometry-collections","page":"Within","title":"Geometries within multi-geometry/geometry collections","text":"","category":"section"},{"location":"source/methods/geom_relations/within/","page":"Within","title":"Within","text":"#= Geometry is within a multi-geometry or a collection if the geometry is within\nat least one of the collection elements. =#\nfunction _within(\n    ::Union{GI.PointTrait, GI.AbstractCurveTrait, GI.PolygonTrait}, g1,\n    ::Union{\n        GI.MultiPointTrait, GI.AbstractMultiCurveTrait,\n        GI.MultiPolygonTrait, GI.GeometryCollectionTrait,\n    }, g2,\n)\n    for sub_g2 in GI.getgeom(g2)\n        within(g1, sub_g2) && return true\n    end\n    return false\nend","category":"page"},{"location":"source/methods/geom_relations/within/#Multi-geometry/geometry-collections-within-geometries","page":"Within","title":"Multi-geometry/geometry collections within geometries","text":"","category":"section"},{"location":"source/methods/geom_relations/within/","page":"Within","title":"Within","text":"#= Multi-geometry or a geometry collection is within a geometry if all\nelements of the collection are within the geometry. =#\nfunction _within(\n    ::Union{\n        GI.MultiPointTrait, GI.AbstractMultiCurveTrait,\n        GI.MultiPolygonTrait, GI.GeometryCollectionTrait,\n    }, g1,\n    ::GI.AbstractGeometryTrait, g2,\n)\n    for sub_g1 in GI.getgeom(g1)\n        !within(sub_g1, g2) && return false\n    end\n    return true\nend","category":"page"},{"location":"source/methods/geom_relations/within/","page":"Within","title":"Within","text":"","category":"page"},{"location":"source/methods/geom_relations/within/","page":"Within","title":"Within","text":"This page was generated using Literate.jl.","category":"page"},{"location":"source/methods/distance/#Distance-and-signed-distance","page":"Distance and signed distance","title":"Distance and signed distance","text":"","category":"section"},{"location":"source/methods/distance/","page":"Distance and signed distance","title":"Distance and signed distance","text":"export distance, signed_distance","category":"page"},{"location":"source/methods/distance/#What-is-distance?-What-is-signed-distance?","page":"Distance and signed distance","title":"What is distance? What is signed distance?","text":"","category":"section"},{"location":"source/methods/distance/","page":"Distance and signed distance","title":"Distance and signed distance","text":"Distance is the distance of a point to another geometry. This is always a positive number. If a point is inside of geometry, so on a curve or inside of a polygon, the distance will be zero. Signed distance is mainly used for polygons and multipolygons. If a point is outside of a geometry, signed distance has the same value as distance. However, points within the geometry have a negative distance representing the distance of a point to the closest boundary. Therefore, for all \"non-filled\" geometries, like curves, the distance will either be postitive or 0.","category":"page"},{"location":"source/methods/distance/","page":"Distance and signed distance","title":"Distance and signed distance","text":"To provide an example, consider this rectangle:","category":"page"},{"location":"source/methods/distance/","page":"Distance and signed distance","title":"Distance and signed distance","text":"import GeometryOps as GO\nimport GeoInterface as GI\nusing Makie\nusing CairoMakie\n\nrect = GI.Polygon([[(0,0), (0,1), (1,1), (1,0), (0, 0)]])\npoint_in = (0.5, 0.5)\npoint_out = (0.5, 1.5)\nf, a, p = poly(collect(GI.getpoint(rect)); axis = (; aspect = DataAspect()))\nscatter!(GI.x(point_in), GI.y(point_in); color = :red)\nscatter!(GI.x(point_out), GI.y(point_out); color = :orange)\nf","category":"page"},{"location":"source/methods/distance/","page":"Distance and signed distance","title":"Distance and signed distance","text":"This is clearly a rectangle with one point inside and one point outside. The points are both an equal distance to the polygon. The distance to pointin is negative while the distance to pointout is positive.","category":"page"},{"location":"source/methods/distance/","page":"Distance and signed distance","title":"Distance and signed distance","text":"GO.distance(point_in, rect)  # == 0\nGO.signed_distance(point_in, rect)  # < 0\nGO.signed_distance(point_out, rect)  # > 0","category":"page"},{"location":"source/methods/distance/#Implementation","page":"Distance and signed distance","title":"Implementation","text":"","category":"section"},{"location":"source/methods/distance/","page":"Distance and signed distance","title":"Distance and signed distance","text":"This is the GeoInterface-compatible implementation. First, we implement a wrapper method that dispatches to the correct implementation based on the geometry trait. This is also used in the implementation, since it's a lot less work!","category":"page"},{"location":"source/methods/distance/","page":"Distance and signed distance","title":"Distance and signed distance","text":"Distance and signed distance are only implemented for points to other geometries right now. This could be extended to include distance from other geometries in the future.","category":"page"},{"location":"source/methods/distance/","page":"Distance and signed distance","title":"Distance and signed distance","text":"The distance calculated is the Euclidean distance using the Pythagorean theorem. Also note that singed_distance only makes sense for \"filled-in\" shapes, like polygons, so it isn't implemented for curves.","category":"page"},{"location":"source/methods/distance/","page":"Distance and signed distance","title":"Distance and signed distance","text":"const _DISTANCE_TARGETS = Union{GI.AbstractPolygonTrait,GI.LineStringTrait,GI.LinearRingTrait,GI.LineTrait,GI.PointTrait}\n\n\"\"\"\n    distance(point, geom, ::Type{T} = Float64)::T\n\nCalculates the  ditance from the geometry `g1` to the `point`. The distance\nwill always be positive or zero.\n\nThe method will differ based on the type of the geometry provided:\n    - The distance from a point to a point is just the Euclidean distance\n    between the points.\n    - The distance from a point to a line is the minimum distance from the point\n    to the closest point on the given line.\n    - The distance from a point to a linestring is the minimum distance from the\n    point to the closest segment of the linestring.\n    - The distance from a point to a linear ring is the minimum distance from\n    the point to the closest segment of the linear ring.\n    - The distance from a point to a polygon is zero if the point is within the\n    polygon and otherwise is the minimum distance from the point to an edge of\n    the polygon. This includes edges created by holes.\n    - The distance from a point to a multigeometry or a geometry collection is\n    the minimum distance between the point and any of the sub-geometries.\n\nResult will be of type T, where T is an optional argument with a default value\nof Float64.\n\"\"\"\nfunction distance(\n    geom1, geom2, ::Type{T} = Float64; threaded=false\n) where T<:AbstractFloat\n    distance(GI.trait(geom1), geom1, GI.trait(geom2), geom2, T; threaded)\nend\nfunction distance(\n    trait1, geom, trait2::GI.PointTrait, point, ::Type{T} = Float64;\n    threaded=false\n) where T<:AbstractFloat\n    distance(trait2, point, trait1, geom, T) # Swap order\nend\nfunction distance(\n    trait1::GI.PointTrait, point, trait2, geom, ::Type{T} = Float64;\n    threaded=false\n) where T<:AbstractFloat\n    applyreduce(min, _DISTANCE_TARGETS, geom; threaded, init=typemax(T)) do g\n        _distance(T, trait1, point, GI.trait(g), g)\n    end\nend","category":"page"},{"location":"source/methods/distance/","page":"Distance and signed distance","title":"Distance and signed distance","text":"Needed for method ambiguity","category":"page"},{"location":"source/methods/distance/","page":"Distance and signed distance","title":"Distance and signed distance","text":"function distance(\n    trait1::GI.PointTrait, point1, trait2::GI.PointTrait, point2, ::Type{T} = Float64;\n    threaded=false\n) where T<:AbstractFloat\n    _distance(T, trait1, point1, trait2, point2)\nend","category":"page"},{"location":"source/methods/distance/","page":"Distance and signed distance","title":"Distance and signed distance","text":"Point-Point, Point-Line, Point-LineString, Point-LinearRing","category":"page"},{"location":"source/methods/distance/","page":"Distance and signed distance","title":"Distance and signed distance","text":"_distance(::Type{T}, ::GI.PointTrait, point, ::GI.PointTrait, geom) where T =\n    _euclid_distance(T, point, geom)\n_distance(::Type{T}, ::GI.PointTrait, point, ::GI.LineTrait, geom) where T =\n    _distance_line(T, point, GI.getpoint(geom, 1), GI.getpoint(geom, 2))\n_distance(::Type{T}, ::GI.PointTrait, point, ::GI.LineStringTrait, geom) where T =\n    _distance_curve(T, point, geom; close_curve = false)\n_distance(::Type{T}, ::GI.PointTrait, point, ::GI.LinearRingTrait, geom) where T =\n    _distance_curve(T, point, geom; close_curve = true)","category":"page"},{"location":"source/methods/distance/","page":"Distance and signed distance","title":"Distance and signed distance","text":"Point-Polygon","category":"page"},{"location":"source/methods/distance/","page":"Distance and signed distance","title":"Distance and signed distance","text":"function _distance(::Type{T}, ::GI.PointTrait, point, ::GI.PolygonTrait, geom) where T\n    within(point, geom) && return zero(T)\n    return _distance_polygon(T, point, geom)\nend\n\n\"\"\"\n    signed_distance(point, geom, ::Type{T} = Float64)::T\n\nCalculates the signed distance from the geometry `geom` to the given point.\nPoints within `geom` have a negative signed distance, and points outside of\n`geom` have a positive signed distance.\n    - The signed distance from a point to a point, line, linestring, or linear\n    ring is equal to the distance between the two.\n    - The signed distance from a point to a polygon is negative if the point is\n    within the polygon and is positive otherwise. The value of the distance is\n    the minimum distance from the point to an edge of the polygon. This includes\n    edges created by holes.\n    - The signed distance from a point to a multigeometry or a geometry\n    collection is the minimum signed distance between the point and any of the\n    sub-geometries.\n\nResult will be of type T, where T is an optional argument with a default value\nof Float64.\n\"\"\"\nfunction signed_distance(\n    geom1, geom2, ::Type{T} = Float64; threaded=false\n) where T<:AbstractFloat\n    signed_distance(GI.trait(geom1), geom1, GI.trait(geom2), geom2, T; threaded)\nend\nfunction signed_distance(\n    trait1, geom, trait2::GI.PointTrait, point, ::Type{T} = Float64;\n    threaded=false\n) where T<:AbstractFloat\n    signed_distance(trait2, point, trait1, geom, T; threaded) # Swap order\nend\nfunction signed_distance(\n    trait1::GI.PointTrait, point, trait2, geom, ::Type{T} = Float64;\n    threaded=false\n) where T<:AbstractFloat\n    applyreduce(min, _DISTANCE_TARGETS, geom; threaded, init=typemax(T)) do g\n        _signed_distance(T, trait1, point, GI.trait(g), g)\n    end\nend","category":"page"},{"location":"source/methods/distance/","page":"Distance and signed distance","title":"Distance and signed distance","text":"Needed for method ambiguity","category":"page"},{"location":"source/methods/distance/","page":"Distance and signed distance","title":"Distance and signed distance","text":"function signed_distance(\n    trait1::GI.PointTrait, point1, trait2::GI.PointTrait, point2, ::Type{T} = Float64;\n    threaded=false\n) where T<:AbstractFloat\n    _signed_distance(T, trait1, point1, trait2, point2)\nend","category":"page"},{"location":"source/methods/distance/","page":"Distance and signed distance","title":"Distance and signed distance","text":"Point-Geom (just calls _distance)","category":"page"},{"location":"source/methods/distance/","page":"Distance and signed distance","title":"Distance and signed distance","text":"function _signed_distance(\n    ::Type{T}, ptrait::GI.PointTrait, point, gtrait::GI.AbstractGeometryTrait, geom\n) where T\n    _distance(T, ptrait, point, gtrait, geom)\nend","category":"page"},{"location":"source/methods/distance/","page":"Distance and signed distance","title":"Distance and signed distance","text":"Point-Polygon","category":"page"},{"location":"source/methods/distance/","page":"Distance and signed distance","title":"Distance and signed distance","text":"function _signed_distance(::Type{T}, ::GI.PointTrait, point, ::GI.PolygonTrait, geom) where T\n    min_dist = _distance_polygon(T, point, geom)\n    return within(point, geom) ? -min_dist : min_dist","category":"page"},{"location":"source/methods/distance/","page":"Distance and signed distance","title":"Distance and signed distance","text":"negative if point is inside polygon","category":"page"},{"location":"source/methods/distance/","page":"Distance and signed distance","title":"Distance and signed distance","text":"end","category":"page"},{"location":"source/methods/distance/","page":"Distance and signed distance","title":"Distance and signed distance","text":"Returns the Euclidean distance between two points.","category":"page"},{"location":"source/methods/distance/","page":"Distance and signed distance","title":"Distance and signed distance","text":"Base.@propagate_inbounds _euclid_distance(::Type{T}, p1, p2) where T =\n    sqrt(_squared_euclid_distance(T, p1, p2))","category":"page"},{"location":"source/methods/distance/","page":"Distance and signed distance","title":"Distance and signed distance","text":"Returns the square of the euclidean distance between two points","category":"page"},{"location":"source/methods/distance/","page":"Distance and signed distance","title":"Distance and signed distance","text":"Base.@propagate_inbounds _squared_euclid_distance(::Type{T}, p1, p2) where T =\n    _squared_euclid_distance(\n        T,\n        GeoInterface.x(p1), GeoInterface.y(p1),\n        GeoInterface.x(p2), GeoInterface.y(p2),\n    )","category":"page"},{"location":"source/methods/distance/","page":"Distance and signed distance","title":"Distance and signed distance","text":"Returns the Euclidean distance between two points given their x and y values.","category":"page"},{"location":"source/methods/distance/","page":"Distance and signed distance","title":"Distance and signed distance","text":"Base.@propagate_inbounds _euclid_distance(::Type{T}, x1, y1, x2, y2) where T =\n    sqrt(_squared_euclid_distance(T, x1, y1, x2, y2))","category":"page"},{"location":"source/methods/distance/","page":"Distance and signed distance","title":"Distance and signed distance","text":"Returns the squared Euclidean distance between two points given their x and y values.","category":"page"},{"location":"source/methods/distance/","page":"Distance and signed distance","title":"Distance and signed distance","text":"Base.@propagate_inbounds _squared_euclid_distance(::Type{T}, x1, y1, x2, y2) where T =\n    T((x2 - x1)^2 + (y2 - y1)^2)","category":"page"},{"location":"source/methods/distance/","page":"Distance and signed distance","title":"Distance and signed distance","text":"Returns the minimum distance from point p0 to the line defined by endpoints p1 and p2.","category":"page"},{"location":"source/methods/distance/","page":"Distance and signed distance","title":"Distance and signed distance","text":"_distance_line(::Type{T}, p0, p1, p2) where T =\n    sqrt(_squared_distance_line(T, p0, p1, p2))","category":"page"},{"location":"source/methods/distance/","page":"Distance and signed distance","title":"Distance and signed distance","text":"Returns the squared minimum distance from point p0 to the line defined by endpoints p1 and p2.","category":"page"},{"location":"source/methods/distance/","page":"Distance and signed distance","title":"Distance and signed distance","text":"function _squared_distance_line(::Type{T}, p0, p1, p2) where T\n    x0, y0 = GeoInterface.x(p0), GeoInterface.y(p0)\n    x1, y1 = GeoInterface.x(p1), GeoInterface.y(p1)\n    x2, y2 = GeoInterface.x(p2), GeoInterface.y(p2)\n\n    xfirst, yfirst, xlast, ylast = x1 < x2 ? (x1, y1, x2, y2) : (x2, y2, x1, y1)\n\n    #=\n    Vectors from first point to last point (v) and from first point to point of\n    interest (w) to find the projection of w onto v to find closest point\n    =#\n    v = (xlast - xfirst, ylast - yfirst)\n    w = (x0 - xfirst, y0 - yfirst)\n\n    c1 = sum(w .* v)\n    if c1 <= 0  # p0 is closest to first endpoint\n        return _squared_euclid_distance(T, x0, y0, xfirst, yfirst)\n    end\n\n    c2 = sum(v .* v)\n    if c2 <= c1 # p0 is closest to last endpoint\n        return _squared_euclid_distance(T, x0, y0, xlast, ylast)\n    end\n\n    b2 = c1 / c2  # projection fraction\n    return _squared_euclid_distance(T, x0, y0, xfirst + (b2 * v[1]), yfirst + (b2 * v[2]))\nend","category":"page"},{"location":"source/methods/distance/","page":"Distance and signed distance","title":"Distance and signed distance","text":"Returns the minimum distance from the given point to the given curve. If close_curve is true, make sure to include the edge from the first to last point of the curve, even if it isn't explicitly repeated.","category":"page"},{"location":"source/methods/distance/","page":"Distance and signed distance","title":"Distance and signed distance","text":"function _distance_curve(::Type{T}, point, curve; close_curve = false) where T","category":"page"},{"location":"source/methods/distance/","page":"Distance and signed distance","title":"Distance and signed distance","text":"see if linear ring has explicitly repeated last point in coordinates","category":"page"},{"location":"source/methods/distance/","page":"Distance and signed distance","title":"Distance and signed distance","text":"    np = GI.npoint(curve)\n    first_last_equal = equals(GI.getpoint(curve, 1), GI.getpoint(curve, np))\n    close_curve &= first_last_equal\n    np -= first_last_equal ? 1 : 0","category":"page"},{"location":"source/methods/distance/","page":"Distance and signed distance","title":"Distance and signed distance","text":"find minimum distance","category":"page"},{"location":"source/methods/distance/","page":"Distance and signed distance","title":"Distance and signed distance","text":"    min_dist = typemax(T)\n    p1 = GI.getpoint(curve, close_curve ? np : 1)\n    for i in (close_curve ? 1 : 2):np\n        p2 = GI.getpoint(curve, i)\n        dist = _distance_line(T, point, p1, p2)\n        min_dist = dist < min_dist ? dist : min_dist\n        p1 = p2\n    end\n    return min_dist\nend","category":"page"},{"location":"source/methods/distance/","page":"Distance and signed distance","title":"Distance and signed distance","text":"Returns the minimum distance from the given point to an edge of the given polygon, including from edges created by holes. Assumes polygon isn't filled and treats the exterior and each hole as a linear ring.","category":"page"},{"location":"source/methods/distance/","page":"Distance and signed distance","title":"Distance and signed distance","text":"function _distance_polygon(::Type{T}, point, poly) where T\n    min_dist = _distance_curve(T, point, GI.getexterior(poly); close_curve = true)\n    @inbounds for hole in GI.gethole(poly)\n        dist = _distance_curve(T, point, hole; close_curve = true)\n        min_dist = dist < min_dist ? dist : min_dist\n    end\n    return min_dist\nend","category":"page"},{"location":"source/methods/distance/","page":"Distance and signed distance","title":"Distance and signed distance","text":"","category":"page"},{"location":"source/methods/distance/","page":"Distance and signed distance","title":"Distance and signed distance","text":"This page was generated using Literate.jl.","category":"page"},{"location":"source/utils/#Utility-functions","page":"Utility functions","title":"Utility functions","text":"","category":"section"},{"location":"source/utils/","page":"Utility functions","title":"Utility functions","text":"_is3d(geom) = _is3d(GI.trait(geom), geom)\n_is3d(::GI.AbstractGeometryTrait, geom) = GI.is3d(geom)\n_is3d(::GI.FeatureTrait, feature) = _is3d(GI.geometry(feature))\n_is3d(::GI.FeatureCollectionTrait, fc) = _is3d(GI.getfeature(fc, 1))\n_is3d(::Nothing, geom) = _is3d(first(geom)) # Otherwise step into an itererable\n\n_npoint(x) = _npoint(trait(x), x)\n_npoint(::Nothing, xs::AbstractArray) = sum(_npoint, xs)\n_npoint(::GI.FeatureCollectionTrait, fc) = sum(_npoint, GI.getfeature(fc))\n_npoint(::GI.FeatureTrait, f) = _npoint(GI.geometry(f))\n_npoint(::GI.AbstractGeometryTrait, x) = GI.npoint(trait(x), x)\n\n_nedge(x) = _nedge(trait(x), x)\n_nedge(::Nothing, xs::AbstractArray) = sum(_nedge, xs)\n_nedge(::GI.FeatureCollectionTrait, fc) = sum(_nedge, GI.getfeature(fc))\n_nedge(::GI.FeatureTrait, f) = _nedge(GI.geometry(f))\nfunction _nedge(::GI.AbstractGeometryTrait, x)\n    n = 0\n    for g in GI.getgeom(x)\n        n += _nedge(g)\n    end\n    return n\nend\n_nedge(::GI.AbstractCurveTrait, x) = GI.npoint(x) - 1\n_nedge(::GI.PointTrait, x) = error(\"Cant get edges from points\")\n\n\n\"\"\"\n    polygon_to_line(poly::Polygon)\n\nConverts a Polygon to LineString or MultiLineString","category":"page"},{"location":"source/utils/","page":"Utility functions","title":"Utility functions","text":"Examples","category":"page"},{"location":"source/utils/","page":"Utility functions","title":"Utility functions","text":"```jldoctest\nimport GeometryOps as GO, GeoInterface as GI\n\npoly = GI.Polygon([[(-2.275543, 53.464547), (-2.275543, 53.489271), (-2.215118, 53.489271), (-2.215118, 53.464547), (-2.275543, 53.464547)]])\nGO.polygon_to_line(poly)","category":"page"},{"location":"source/utils/","page":"Utility functions","title":"Utility functions","text":"output","category":"page"},{"location":"source/utils/","page":"Utility functions","title":"Utility functions","text":"GeoInterface.Wrappers.LineString{false, false, Vector{Tuple{Float64, Float64}}, Nothing, Nothing}([(-2.275543, 53.464547), (-2.275543, 53.489271), (-2.215118, 53.489271), (-2.215118, 53.464547), (-2.275543, 53.464547)], nothing, nothing)\n```\n\"\"\"\nfunction polygon_to_line(poly)\n    @assert GI.trait(poly) isa PolygonTrait\n    GI.ngeom(poly) > 1 && return GI.MultiLineString(collect(GI.getgeom(poly)))\n    return GI.LineString(collect(GI.getgeom(GI.getgeom(poly, 1))))\nend\n\n\n\"\"\"\n    to_edges()\n\nConvert any geometry or collection of geometries into a flat\nvector of `Tuple{Tuple{Float64,Float64},Tuple{Float64,Float64}}` edges.\n\"\"\"\nfunction to_edges(x)\n    edges = Vector{Edge}(undef, _nedge(x))\n    _to_edges!(edges, x, 1)\n    return edges\nend\n\n_to_edges!(edges::Vector, x, n) = _to_edges!(edges, trait(x), x, n)\nfunction _to_edges!(edges::Vector, ::GI.FeatureCollectionTrait, fc, n)\n    for f in GI.getfeature(fc)\n        n = _to_edges!(edges, f, n)\n    end\nend\n_to_edges!(edges::Vector, ::GI.FeatureTrait, f, n) = _to_edges!(edges, GI.geometry(f), n)\nfunction _to_edges!(edges::Vector, ::GI.AbstractGeometryTrait, fc, n)\n    for f in GI.getgeom(fc)\n        n = _to_edges!(edges, f, n)\n    end\nend\nfunction _to_edges!(edges::Vector, ::GI.AbstractCurveTrait, geom, n)\n    p1 = GI.getpoint(geom, 1)\n    p1x, p1y = GI.x(p1), GI.y(p1)\n    for i in 2:GI.npoint(geom)\n        p2 = GI.getpoint(geom, i)\n        p2x, p2y = GI.x(p2), GI.y(p2)\n        edges[n] = (p1x, p1y), (p2x, p2y)\n        p1x, p1y = p2x, p2y\n        n += 1\n    end\n    return n\nend\n\n_tuple_point(p) = GI.x(p), GI.y(p)\n\nfunction to_extent(edges::Vector{Edge})\n    x, y = extrema(first, edges)\n    Extents.Extent(X=x, Y=y)\nend\n\nfunction to_points(x)\n    points = Vector{TuplePoint}(undef, _npoint(x))\n    _to_points!(points, x, 1)\n    return points\nend\n\n_to_points!(points::Vector, x, n) = _to_points!(points, trait(x), x, n)\nfunction _to_points!(points::Vector, ::FeatureCollectionTrait, fc, n)\n    for f in GI.getfeature(fc)\n        n = _to_points!(points, f, n)\n    end\nend\n_to_points!(points::Vector, ::FeatureTrait, f, n) = _to_points!(points, GI.geometry(f), n)\nfunction _to_points!(points::Vector, ::AbstractGeometryTrait, fc, n)\n    for f in GI.getgeom(fc)\n        n = _to_points!(points, f, n)\n    end\nend\nfunction _to_points!(points::Vector, ::Union{AbstractCurveTrait,MultiPointTrait}, geom, n)\n    p1 = GI.getpoint(geom, 1)\n    p1x, p1y = GI.x(p1), GI.y(p1)\n    for i in 2:GI.npoint(geom)\n        p2 = GI.getpoint(geom, i)\n        p2x, p2y = GI.x(p2), GI.y(p2)\n        points[n] = (p1x, p1y), (p2x, p2y)\n        p1 = p2\n        n += 1\n    end\n    return n\nend","category":"page"},{"location":"source/utils/","page":"Utility functions","title":"Utility functions","text":"","category":"page"},{"location":"source/utils/","page":"Utility functions","title":"Utility functions","text":"This page was generated using Literate.jl.","category":"page"},{"location":"source/methods/geom_relations/coveredby/#CoveredBy","page":"CoveredBy","title":"CoveredBy","text":"","category":"section"},{"location":"source/methods/geom_relations/coveredby/","page":"CoveredBy","title":"CoveredBy","text":"export coveredby","category":"page"},{"location":"source/methods/geom_relations/coveredby/#What-is-coveredby?","page":"CoveredBy","title":"What is coveredby?","text":"","category":"section"},{"location":"source/methods/geom_relations/coveredby/","page":"CoveredBy","title":"CoveredBy","text":"The coveredby function checks if one geometry is covered by another geometry. This is an extension of within that does not require the interiors of the two geometries to intersect, but still does require that the interior and boundary of the first geometry isn't outside of the second geometry.","category":"page"},{"location":"source/methods/geom_relations/coveredby/","page":"CoveredBy","title":"CoveredBy","text":"To provide an example, consider this point and line:","category":"page"},{"location":"source/methods/geom_relations/coveredby/","page":"CoveredBy","title":"CoveredBy","text":"import GeometryOps as GO\nimport GeoInterface as GI\nusing Makie\nusing CairoMakie\n\np1 = (0.0, 0.0)\nl1 = GI.Line([p1, (1.0, 1.0)])\nf, a, p = lines(GI.getpoint(l1))\nscatter!(p1, color = :red)\nf","category":"page"},{"location":"source/methods/geom_relations/coveredby/","page":"CoveredBy","title":"CoveredBy","text":"As we can see, p1 is on the endpoint of l1. This means it is not within, but it does meet the definition of coveredby.","category":"page"},{"location":"source/methods/geom_relations/coveredby/","page":"CoveredBy","title":"CoveredBy","text":"GO.coveredby(p1, l1)  # true","category":"page"},{"location":"source/methods/geom_relations/coveredby/#Implementation","page":"CoveredBy","title":"Implementation","text":"","category":"section"},{"location":"source/methods/geom_relations/coveredby/","page":"CoveredBy","title":"CoveredBy","text":"This is the GeoInterface-compatible implementation.","category":"page"},{"location":"source/methods/geom_relations/coveredby/","page":"CoveredBy","title":"CoveredBy","text":"First, we implement a wrapper method that dispatches to the correct implementation based on the geometry trait.","category":"page"},{"location":"source/methods/geom_relations/coveredby/","page":"CoveredBy","title":"CoveredBy","text":"Each of these calls a method in the geomgeomprocessors file. The methods in this file determine if the given geometries meet a set of criteria. For the coveredby function and arguments g1 and g2, this criteria is as follows:     - points of g1 are allowed to be in the interior of g2 (either through     overlap or crossing for lines)     - points of g1 are allowed to be on the boundary of g2     - points of g1 are not allowed to be in the exterior of g2     - no points of g1 are required to be in the interior of g2     - no points of g1 are required to be on the boundary of g2     - no points of g1 are required to be in the exterior of g2","category":"page"},{"location":"source/methods/geom_relations/coveredby/","page":"CoveredBy","title":"CoveredBy","text":"The code for the specific implementations is in the geomgeomprocessors file.","category":"page"},{"location":"source/methods/geom_relations/coveredby/","page":"CoveredBy","title":"CoveredBy","text":"const COVEREDBY_ALLOWS = (in_allow = true, on_allow = true, out_allow = false)\nconst COVEREDBY_CURVE_ALLOWS = (over_allow = true, cross_allow = true, on_allow = true, out_allow = false)\nconst COVEREDBY_CURVE_REQUIRES = (in_require = false, on_require = false, out_require = false)\nconst COVEREDBY_POLYGON_REQUIRES = (in_require = true, on_require = false, out_require = false,)\n\n\"\"\"\n    coveredby(g1, g2)::Bool\n\nReturn `true` if the first geometry is completely covered by the second\ngeometry. The interior and boundary of the primary geometry (g1) must not\nintersect the exterior of the secondary geometry (g2).\n\nFurthermore, `coveredby` returns the exact opposite result of `covers`. They are\nequivalent with the order of the arguments swapped.\n\n# Examples\n```jldoctest setup=:(using GeometryOps, GeometryBasics)\nimport GeometryOps as GO, GeoInterface as GI\np1 = GI.Point(0.0, 0.0)\np2 = GI.Point(1.0, 1.0)\nl1 = GI.Line([p1, p2])\n\nGO.coveredby(p1, l1)","category":"page"},{"location":"source/methods/geom_relations/coveredby/","page":"CoveredBy","title":"CoveredBy","text":"output","category":"page"},{"location":"source/methods/geom_relations/coveredby/","page":"CoveredBy","title":"CoveredBy","text":"true\n```\n\"\"\"\ncoveredby(g1, g2) = _coveredby(trait(g1), g1, trait(g2), g2)","category":"page"},{"location":"source/methods/geom_relations/coveredby/#Convert-features-to-geometries","page":"CoveredBy","title":"Convert features to geometries","text":"","category":"section"},{"location":"source/methods/geom_relations/coveredby/","page":"CoveredBy","title":"CoveredBy","text":"_coveredby(::GI.FeatureTrait, g1, ::Any, g2) = coveredby(GI.geometry(g1), g2)\n_coveredby(::Any, g1, t2::GI.FeatureTrait, g2) = coveredby(g1, GI.geometry(g2))\n_coveredby(::FeatureTrait, g1, ::FeatureTrait, g2) = coveredby(GI.geometry(g1), GI.geometry(g2))","category":"page"},{"location":"source/methods/geom_relations/coveredby/#Points-coveredby-geometries","page":"CoveredBy","title":"Points coveredby geometries","text":"","category":"section"},{"location":"source/methods/geom_relations/coveredby/","page":"CoveredBy","title":"CoveredBy","text":"Point is coveredby another point if those points are equal","category":"page"},{"location":"source/methods/geom_relations/coveredby/","page":"CoveredBy","title":"CoveredBy","text":"_coveredby(\n    ::GI.PointTrait, g1,\n    ::GI.PointTrait, g2,\n) = equals(g1, g2)","category":"page"},{"location":"source/methods/geom_relations/coveredby/","page":"CoveredBy","title":"CoveredBy","text":"Point is coveredby a line/linestring if it is on a line vertex or an edge","category":"page"},{"location":"source/methods/geom_relations/coveredby/","page":"CoveredBy","title":"CoveredBy","text":"_coveredby(\n    ::GI.PointTrait, g1,\n    ::Union{GI.LineTrait, GI.LineStringTrait}, g2,\n) = _point_curve_process(\n    g1, g2;\n    COVEREDBY_ALLOWS...,\n    closed_curve = false,\n)","category":"page"},{"location":"source/methods/geom_relations/coveredby/","page":"CoveredBy","title":"CoveredBy","text":"Point is coveredby a linearring if it is on a vertex or an edge of ring","category":"page"},{"location":"source/methods/geom_relations/coveredby/","page":"CoveredBy","title":"CoveredBy","text":"_coveredby(\n    ::GI.PointTrait, g1,\n    ::GI.LinearRingTrait, g2,\n) = _point_curve_process(\n    g1, g2;\n    COVEREDBY_ALLOWS...,\n    closed_curve = true,\n)","category":"page"},{"location":"source/methods/geom_relations/coveredby/","page":"CoveredBy","title":"CoveredBy","text":"Point is coveredby a polygon if it is inside polygon, including edges/vertices","category":"page"},{"location":"source/methods/geom_relations/coveredby/","page":"CoveredBy","title":"CoveredBy","text":"_coveredby(\n    ::GI.PointTrait, g1,\n    ::GI.PolygonTrait, g2,\n) = _point_polygon_process(\n    g1, g2;\n    COVEREDBY_ALLOWS...,\n)","category":"page"},{"location":"source/methods/geom_relations/coveredby/","page":"CoveredBy","title":"CoveredBy","text":"Points cannot cover any geometry other than points","category":"page"},{"location":"source/methods/geom_relations/coveredby/","page":"CoveredBy","title":"CoveredBy","text":"_coveredby(\n    ::Union{GI.AbstractCurveTrait, GI.PolygonTrait}, g1,\n    ::GI.PointTrait, g2,\n) = false","category":"page"},{"location":"source/methods/geom_relations/coveredby/#Lines-coveredby-geometries","page":"CoveredBy","title":"Lines coveredby geometries","text":"","category":"section"},{"location":"source/methods/geom_relations/coveredby/","page":"CoveredBy","title":"CoveredBy","text":"#= Linestring is coveredby a line if all interior and boundary points of the\nfirst line are on the interior/boundary points of the second line. =#\n_coveredby(\n    ::Union{GI.LineTrait, GI.LineStringTrait}, g1,\n    ::Union{GI.LineTrait, GI.LineStringTrait}, g2,\n) = _line_curve_process(\n    g1, g2;\n    COVEREDBY_CURVE_ALLOWS...,\n    COVEREDBY_CURVE_REQUIRES...,\n    closed_line = false,\n    closed_curve = false,\n)\n\n#= Linestring is coveredby a ring if all interior and boundary points of the\nline are on the edges of the ring. =#\n_coveredby(\n    ::Union{GI.LineTrait, GI.LineStringTrait}, g1,\n    ::GI.LinearRingTrait, g2,\n) = _line_curve_process(\n    g1, g2;\n    COVEREDBY_CURVE_ALLOWS...,\n    COVEREDBY_CURVE_REQUIRES...,\n    closed_line = false,\n    closed_curve = true,\n)\n\n#= Linestring is coveredby a polygon if all interior and boundary points of the\nline are in the polygon interior or on its edges, inlcuding hole edges. =#\n_coveredby(\n    ::Union{GI.LineTrait, GI.LineStringTrait}, g1,\n    ::GI.PolygonTrait, g2,\n) = _line_polygon_process(\n    g1, g2;\n    COVEREDBY_ALLOWS...,\n    COVEREDBY_CURVE_REQUIRES...,\n    closed_line = false,\n)","category":"page"},{"location":"source/methods/geom_relations/coveredby/#Rings-covered-by-geometries","page":"CoveredBy","title":"Rings covered by geometries","text":"","category":"section"},{"location":"source/methods/geom_relations/coveredby/","page":"CoveredBy","title":"CoveredBy","text":"#= Linearring is covered by a line if all vertices and edges of the ring are on\nthe edges and vertices of the line. =#\n_coveredby(\n    ::GI.LinearRingTrait, g1,\n    ::Union{GI.LineTrait, GI.LineStringTrait}, g2,\n) = _line_curve_process(\n    g1, g2;\n    COVEREDBY_CURVE_ALLOWS...,\n    COVEREDBY_CURVE_REQUIRES...,\n    closed_line = true,\n    closed_curve = false,\n)\n\n#= Linearring is covered by another linear ring if all vertices and edges of the\nfirst ring are on the edges/vertices of the second ring. =#\n_coveredby(\n    ::GI.LinearRingTrait, g1,\n    ::GI.LinearRingTrait, g2,\n) = _line_curve_process(\n    g1, g2;\n    COVEREDBY_CURVE_ALLOWS...,\n    COVEREDBY_CURVE_REQUIRES...,\n    closed_line = true,\n    closed_curve = true,\n)\n\n#= Linearring is coveredby a polygon if all vertices and edges of the ring are\nin the polygon interior or on the polygon edges, inlcuding hole edges. =#\n_coveredby(\n    ::GI.LinearRingTrait, g1,\n    ::GI.PolygonTrait, g2,\n) = _line_polygon_process(\n    g1, g2;\n    COVEREDBY_ALLOWS...,\n    COVEREDBY_CURVE_REQUIRES...,\n    closed_line = true,\n)","category":"page"},{"location":"source/methods/geom_relations/coveredby/#Polygons-covered-by-geometries","page":"CoveredBy","title":"Polygons covered by geometries","text":"","category":"section"},{"location":"source/methods/geom_relations/coveredby/","page":"CoveredBy","title":"CoveredBy","text":"#= Polygon is covered by another polygon if if the interior and edges of the\nfirst polygon are in the second polygon interior or on polygon edges, including\nhole edges.=#\n_coveredby(\n    ::GI.PolygonTrait, g1,\n    ::GI.PolygonTrait, g2,\n) = _polygon_polygon_process(\n    g1, g2;\n    COVEREDBY_ALLOWS...,\n    COVEREDBY_POLYGON_REQUIRES...,\n)","category":"page"},{"location":"source/methods/geom_relations/coveredby/","page":"CoveredBy","title":"CoveredBy","text":"Polygons cannot covered by any curves","category":"page"},{"location":"source/methods/geom_relations/coveredby/","page":"CoveredBy","title":"CoveredBy","text":"_coveredby(\n    ::GI.PolygonTrait, g1,\n    ::GI.AbstractCurveTrait, g2,\n) = false","category":"page"},{"location":"source/methods/geom_relations/coveredby/#Geometries-coveredby-multi-geometry/geometry-collections","page":"CoveredBy","title":"Geometries coveredby multi-geometry/geometry collections","text":"","category":"section"},{"location":"source/methods/geom_relations/coveredby/","page":"CoveredBy","title":"CoveredBy","text":"#= Geometry is covered by a multi-geometry or a collection if one of the elements\nof the collection cover the geometry. =#\nfunction _coveredby(\n    ::Union{GI.PointTrait, GI.AbstractCurveTrait, GI.PolygonTrait}, g1,\n    ::Union{\n        GI.MultiPointTrait, GI.AbstractMultiCurveTrait,\n        GI.MultiPolygonTrait, GI.GeometryCollectionTrait,\n    }, g2,\n)\n    for sub_g2 in GI.getgeom(g2)\n        coveredby(g1, sub_g2) && return true\n    end\n    return false\nend","category":"page"},{"location":"source/methods/geom_relations/coveredby/#Multi-geometry/geometry-collections-coveredby-geometries","page":"CoveredBy","title":"Multi-geometry/geometry collections coveredby geometries","text":"","category":"section"},{"location":"source/methods/geom_relations/coveredby/","page":"CoveredBy","title":"CoveredBy","text":"#= Multi-geometry or a geometry collection is covered by a geometry if all\nelements of the collection are covered by the geometry. =#\nfunction _coveredby(\n    ::Union{\n        GI.MultiPointTrait, GI.AbstractMultiCurveTrait,\n        GI.MultiPolygonTrait, GI.GeometryCollectionTrait,\n    }, g1,\n    ::GI.AbstractGeometryTrait, g2,\n)\n    for sub_g1 in GI.getgeom(g1)\n        !coveredby(sub_g1, g2) && return false\n    end\n    return true\nend","category":"page"},{"location":"source/methods/geom_relations/coveredby/","page":"CoveredBy","title":"CoveredBy","text":"","category":"page"},{"location":"source/methods/geom_relations/coveredby/","page":"CoveredBy","title":"CoveredBy","text":"This page was generated using Literate.jl.","category":"page"},{"location":"source/methods/bools/#Boolean-conditions","page":"Boolean conditions","title":"Boolean conditions","text":"","category":"section"},{"location":"source/methods/bools/","page":"Boolean conditions","title":"Boolean conditions","text":"export isclockwise, isconcave","category":"page"},{"location":"source/methods/bools/","page":"Boolean conditions","title":"Boolean conditions","text":"These are all adapted from Turf.jl.","category":"page"},{"location":"source/methods/bools/","page":"Boolean conditions","title":"Boolean conditions","text":"The may not necessarily be what want in the end but work for now!","category":"page"},{"location":"source/methods/bools/","page":"Boolean conditions","title":"Boolean conditions","text":"\"\"\"\n    isclockwise(line::Union{LineString, Vector{Position}})::Bool\n\nTake a ring and return true or false whether or not the ring is clockwise or\ncounter-clockwise.\n\n# Example\n\n```jldoctest\nimport GeoInterface as GI, GeometryOps as GO\n\nring = GI.LinearRing([(0, 0), (1, 1), (1, 0), (0, 0)])\nGO.isclockwise(ring)","category":"page"},{"location":"source/methods/bools/","page":"Boolean conditions","title":"Boolean conditions","text":"output","category":"page"},{"location":"source/methods/bools/","page":"Boolean conditions","title":"Boolean conditions","text":"true\n```\n\"\"\"\nisclockwise(geom)::Bool = isclockwise(GI.trait(geom), geom)\n\nfunction isclockwise(::AbstractCurveTrait, line)::Bool\n    sum = 0.0\n    prev = GI.getpoint(line, 1)\n    for p in GI.getpoint(line)","category":"page"},{"location":"source/methods/bools/","page":"Boolean conditions","title":"Boolean conditions","text":"sum will be zero for the first point as x is subtracted from itself","category":"page"},{"location":"source/methods/bools/","page":"Boolean conditions","title":"Boolean conditions","text":"        sum += (GI.x(p) - GI.x(prev)) * (GI.y(p) + GI.y(prev))\n        prev = p\n    end\n\n    return sum > 0.0\nend\n\n\"\"\"\n    isconcave(poly::Polygon)::Bool\n\nTake a polygon and return true or false as to whether it is concave or not.\n\n# Examples\n```jldoctest\nimport GeoInterface as GI, GeometryOps as GO\n\npoly = GI.Polygon([[(0, 0), (0, 1), (1, 1), (1, 0), (0, 0)]])\nGO.isconcave(poly)","category":"page"},{"location":"source/methods/bools/","page":"Boolean conditions","title":"Boolean conditions","text":"output","category":"page"},{"location":"source/methods/bools/","page":"Boolean conditions","title":"Boolean conditions","text":"false\n```\n\"\"\"\nfunction isconcave(poly)::Bool\n    sign = false\n\n    exterior = GI.getexterior(poly)","category":"page"},{"location":"source/methods/bools/","page":"Boolean conditions","title":"Boolean conditions","text":"FIXME handle not closed polygons","category":"page"},{"location":"source/methods/bools/","page":"Boolean conditions","title":"Boolean conditions","text":"    GI.npoint(exterior) <= 4 && return false\n    n = GI.npoint(exterior) - 1\n\n    for i in 1:n\n        j = ((i + 1) % n) === 0 ? 1 : (i + 1) % n\n        m = ((i + 2) % n) === 0 ? 1 : (i + 2) % n\n\n        pti = GI.getpoint(exterior, i)\n        ptj = GI.getpoint(exterior, j)\n        ptm = GI.getpoint(exterior, m)\n\n        dx1 = GI.x(ptm) - GI.x(ptj)\n        dy1 = GI.y(ptm) - GI.y(ptj)\n        dx2 = GI.x(pti) - GI.x(ptj)\n        dy2 = GI.y(pti) - GI.y(ptj)\n\n        cross = (dx1 * dy2) - (dy1 * dx2)\n\n        if i === 0\n            sign = cross > 0\n        elseif sign !== (cross > 0)\n            return true\n        end\n    end\n\n    return false\nend","category":"page"},{"location":"source/methods/bools/","page":"Boolean conditions","title":"Boolean conditions","text":"\"\"\"     isparallel(line1::LineString, line2::LineString)::Bool","category":"page"},{"location":"source/methods/bools/","page":"Boolean conditions","title":"Boolean conditions","text":"Return true if each segment of line1 is parallel to the correspondent segment of line2","category":"page"},{"location":"source/methods/bools/#Examples","page":"Boolean conditions","title":"Examples","text":"","category":"section"},{"location":"source/methods/bools/","page":"Boolean conditions","title":"Boolean conditions","text":"import GeoInterface as GI, GeometryOps as GO\njulia> line1 = GI.LineString([(9.170356, 45.477985), (9.164434, 45.482551), (9.166644, 45.484003)])\nGeoInterface.Wrappers.LineString{false, false, Vector{Tuple{Float64, Float64}}, Nothing, Nothing}([(9.170356, 45.477985), (9.164434, 45.482551), (9.166644, 45.484003)], nothing, nothing)\n\njulia> line2 = GI.LineString([(9.169356, 45.477985), (9.163434, 45.482551), (9.165644, 45.484003)])\nGeoInterface.Wrappers.LineString{false, false, Vector{Tuple{Float64, Float64}}, Nothing, Nothing}([(9.169356, 45.477985), (9.163434, 45.482551), (9.165644, 45.484003)], nothing, nothing)\n\njulia>\nGO.isparallel(line1, line2)\ntrue","category":"page"},{"location":"source/methods/bools/","page":"Boolean conditions","title":"Boolean conditions","text":"\"\"\" function isparallel(line1, line2)::Bool     seg1 = linesegment(line1)     seg2 = linesegment(line2)","category":"page"},{"location":"source/methods/bools/","page":"Boolean conditions","title":"Boolean conditions","text":"for i in eachindex(seg1)\n    coors2 = nothing\n    coors1 = seg1[i]\n    coors2 = seg2[i]\n    _isparallel(coors1, coors2) == false && return false\nend\nreturn true","category":"page"},{"location":"source/methods/bools/","page":"Boolean conditions","title":"Boolean conditions","text":"end","category":"page"},{"location":"source/methods/bools/","page":"Boolean conditions","title":"Boolean conditions","text":"@inline function isparallel(p1, p2)     slope1 = bearingtoazimuth(rhumbbearing(GI.x(p1), GI.x(p2)))     slope2 = bearingtoazimuth(rhumb_bearing(GI.y(p1), GI.y(p2)))","category":"page"},{"location":"source/methods/bools/","page":"Boolean conditions","title":"Boolean conditions","text":"return slope1 === slope2","category":"page"},{"location":"source/methods/bools/","page":"Boolean conditions","title":"Boolean conditions","text":"end","category":"page"},{"location":"source/methods/bools/","page":"Boolean conditions","title":"Boolean conditions","text":"_isparallel(((ax, ay), (bx, by)), ((cx, cy), (dx, dy))) =\n    _isparallel(bx - ax, by - ay, dx - cx, dy - cy)\n\n_isparallel(Δx1, Δy1, Δx2, Δy2) = (Δx1 * Δy2 == Δy1 * Δx2)\n\n\nfunction point_in_extent(p, extent::Extents.Extent)\n    (x1, x2), (y1, y1) = extent.X, extent.Y\n    return x1 <= GI.x(p) && y1 <= GI.y(p) && x2 >= GI.x(p) && y2 >= GI.y(p)\nend","category":"page"},{"location":"source/methods/bools/","page":"Boolean conditions","title":"Boolean conditions","text":"","category":"page"},{"location":"source/methods/bools/","page":"Boolean conditions","title":"Boolean conditions","text":"This page was generated using Literate.jl.","category":"page"},{"location":"source/methods/equals/#Equals","page":"Equals","title":"Equals","text":"","category":"section"},{"location":"source/methods/equals/","page":"Equals","title":"Equals","text":"export equals","category":"page"},{"location":"source/methods/equals/#What-is-equals?","page":"Equals","title":"What is equals?","text":"","category":"section"},{"location":"source/methods/equals/","page":"Equals","title":"Equals","text":"The equals function checks if two geometries are equal. They are equal if they share the same set of points and edges to define the same shape.","category":"page"},{"location":"source/methods/equals/","page":"Equals","title":"Equals","text":"To provide an example, consider these two lines:","category":"page"},{"location":"source/methods/equals/","page":"Equals","title":"Equals","text":"import GeometryOps as GO\nimport GeoInterface as GI\nusing Makie\nusing CairoMakie\n\nl1 = GI.LineString([(0.0, 0.0), (0.0, 10.0)])\nl2 = GI.LineString([(0.0, -10.0), (0.0, 3.0)])\nf, a, p = lines(GI.getpoint(l1), color = :blue)\nscatter!(GI.getpoint(l1), color = :blue)\nlines!(GI.getpoint(l2), color = :orange)\nscatter!(GI.getpoint(l2), color = :orange)\nf","category":"page"},{"location":"source/methods/equals/","page":"Equals","title":"Equals","text":"We can see that the two lines do not share a commen set of points and edges in the plot, so they are not equal:","category":"page"},{"location":"source/methods/equals/","page":"Equals","title":"Equals","text":"GO.equals(l1, l2)  # returns false","category":"page"},{"location":"source/methods/equals/#Implementation","page":"Equals","title":"Implementation","text":"","category":"section"},{"location":"source/methods/equals/","page":"Equals","title":"Equals","text":"This is the GeoInterface-compatible implementation.","category":"page"},{"location":"source/methods/equals/","page":"Equals","title":"Equals","text":"First, we implement a wrapper method that dispatches to the correct implementation based on the geometry trait. This is also used in the implementation, since it's a lot less work!","category":"page"},{"location":"source/methods/equals/","page":"Equals","title":"Equals","text":"Note that while we need the same set of points and edges, they don't need to be provided in the same order for polygons. For for example, we need the same set points for two multipoints to be equal, but they don't have to be saved in the same order. The winding order also doesn't have to be the same to represent the same geometry. This requires checking every point against every other point in the two geometries we are comparing. Also, some geometries must be \"closed\" like polygons and linear rings. These will be assumed to be closed, even if they don't have a repeated last point explicity written in the coordinates. Additionally, geometries and multi-geometries can be equal if the multi-geometry only includes that single geometry.","category":"page"},{"location":"source/methods/equals/","page":"Equals","title":"Equals","text":"\"\"\"\n    equals(geom1, geom2)::Bool\n\nCompare two Geometries return true if they are the same geometry.\n\n# Examples\n```jldoctest\nimport GeometryOps as GO, GeoInterface as GI\npoly1 = GI.Polygon([[(0,0), (0,5), (5,5), (5,0), (0,0)]])\npoly2 = GI.Polygon([[(0,0), (0,5), (5,5), (5,0), (0,0)]])\n\nGO.equals(poly1, poly2)","category":"page"},{"location":"source/methods/equals/","page":"Equals","title":"Equals","text":"output","category":"page"},{"location":"source/methods/equals/","page":"Equals","title":"Equals","text":"true\n```\n\"\"\"\nequals(geom_a, geom_b) = equals(\n    GI.trait(geom_a), geom_a,\n    GI.trait(geom_b), geom_b,\n)\n\n\"\"\"\n    equals(::T, geom_a, ::T, geom_b)::Bool\n\nTwo geometries of the same type, which don't have a equals function to dispatch\noff of should throw an error.\n\"\"\"\nequals(::T, geom_a, ::T, geom_b) where T = error(\"Cant compare $T yet\")\n\n\"\"\"\n    equals(trait_a, geom_a, trait_b, geom_b)\n\nTwo geometries which are not of the same type cannot be equal so they always\nreturn false.\n\"\"\"\nequals(trait_a, geom_a, trait_b, geom_b) = false\n\n\"\"\"\n    equals(::GI.PointTrait, p1, ::GI.PointTrait, p2)::Bool\n\nTwo points are the same if they have the same x and y (and z if 3D) coordinates.\n\"\"\"\nfunction equals(::GI.PointTrait, p1, ::GI.PointTrait, p2)\n    GI.ncoord(p1) == GI.ncoord(p2) || return false\n    GI.x(p1) == GI.x(p2) || return false\n    GI.y(p1) == GI.y(p2) || return false\n    if GI.is3d(p1)\n        GI.z(p1) == GI.z(p2) || return false\n    end\n    return true\nend\n\n\"\"\"\n    equals(::GI.PointTrait, p1, ::GI.MultiPointTrait, mp2)::Bool\n\nA point and a multipoint are equal if the multipoint is composed of a single\npoint that is equivalent to the given point.\n\"\"\"\nfunction equals(::GI.PointTrait, p1, ::GI.MultiPointTrait, mp2)\n    GI.npoint(mp2) == 1 || return false\n    return equals(p1, GI.getpoint(mp2, 1))\nend\n\n\"\"\"\n    equals(::GI.MultiPointTrait, mp1, ::GI.PointTrait, p2)::Bool\n\nA point and a multipoint are equal if the multipoint is composed of a single\npoint that is equivalent to the given point.\n\"\"\"\nequals(trait1::GI.MultiPointTrait, mp1, trait2::GI.PointTrait, p2) =\n    equals(trait2, p2, trait1, mp1)\n\n\"\"\"\n    equals(::GI.MultiPointTrait, mp1, ::GI.MultiPointTrait, mp2)::Bool\n\nTwo multipoints are equal if they share the same set of points.\n\"\"\"\nfunction equals(::GI.MultiPointTrait, mp1, ::GI.MultiPointTrait, mp2)\n    GI.npoint(mp1) == GI.npoint(mp2) || return false\n    for p1 in GI.getpoint(mp1)\n        has_match = false  # if point has a matching point in other multipoint\n        for p2 in GI.getpoint(mp2)\n            if equals(p1, p2)\n                has_match = true\n                break\n            end\n        end\n        has_match || return false  # if no matching point, can't be equal\n    end\n    return true  # all points had a match\nend\n\n\"\"\"\n    _equals_curves(c1, c2, closed_type1, closed_type2)::Bool\n\nTwo curves are equal if they share the same set of point, representing the same\ngeometry. Both curves must must be composed of the same set of points, however,\nthey do not have to wind in the same direction, or start on the same point to be\nequivalent.\nInputs:\n    c1 first geometry\n    c2 second geometry\n    closed_type1::Bool true if c1 is closed by definition (polygon, linear ring)\n    closed_type2::Bool true if c2 is closed by definition (polygon, linear ring)\n\"\"\"\nfunction _equals_curves(c1, c2, closed_type1, closed_type2)","category":"page"},{"location":"source/methods/equals/","page":"Equals","title":"Equals","text":"Check if both curves are closed or not","category":"page"},{"location":"source/methods/equals/","page":"Equals","title":"Equals","text":"    n1 = GI.npoint(c1)\n    n2 = GI.npoint(c2)\n    c1_repeat_point = GI.getpoint(c1, 1) == GI.getpoint(c1, n1)\n    n2 = GI.npoint(c2)\n    c2_repeat_point = GI.getpoint(c2, 1) == GI.getpoint(c2, n2)\n    closed1 = closed_type1 || c1_repeat_point\n    closed2 = closed_type2 || c2_repeat_point\n    closed1 == closed2 || return false","category":"page"},{"location":"source/methods/equals/","page":"Equals","title":"Equals","text":"How many points in each curve","category":"page"},{"location":"source/methods/equals/","page":"Equals","title":"Equals","text":"    n1 -= c1_repeat_point ? 1 : 0\n    n2 -= c2_repeat_point ? 1 : 0\n    n1 == n2 || return false\n    n1 == 0 && return true","category":"page"},{"location":"source/methods/equals/","page":"Equals","title":"Equals","text":"Find offset between curves","category":"page"},{"location":"source/methods/equals/","page":"Equals","title":"Equals","text":"    jstart = nothing\n    p1 = GI.getpoint(c1, 1)\n    for i in 1:n2\n        if equals(p1, GI.getpoint(c2, i))\n            jstart = i\n            break\n        end\n    end","category":"page"},{"location":"source/methods/equals/","page":"Equals","title":"Equals","text":"no point matches the first point","category":"page"},{"location":"source/methods/equals/","page":"Equals","title":"Equals","text":"    isnothing(jstart) && return false","category":"page"},{"location":"source/methods/equals/","page":"Equals","title":"Equals","text":"found match for only point","category":"page"},{"location":"source/methods/equals/","page":"Equals","title":"Equals","text":"    n1 == 1 && return true","category":"page"},{"location":"source/methods/equals/","page":"Equals","title":"Equals","text":"if isn't closed and first or last point don't match, not same curve","category":"page"},{"location":"source/methods/equals/","page":"Equals","title":"Equals","text":"    !closed_type1 && (jstart != 1 && jstart != n1) && return false","category":"page"},{"location":"source/methods/equals/","page":"Equals","title":"Equals","text":"Check if curves are going in same direction","category":"page"},{"location":"source/methods/equals/","page":"Equals","title":"Equals","text":"    i = 2\n    j = jstart + 1\n    j -= j > n2 ? n2 : 0\n    same_direction = equals(GI.getpoint(c1, i), GI.getpoint(c2, j))","category":"page"},{"location":"source/methods/equals/","page":"Equals","title":"Equals","text":"if only 2 points, we have already compared both","category":"page"},{"location":"source/methods/equals/","page":"Equals","title":"Equals","text":"    n1 == 2 && return same_direction","category":"page"},{"location":"source/methods/equals/","page":"Equals","title":"Equals","text":"Check all remaining points are the same wrapping around line","category":"page"},{"location":"source/methods/equals/","page":"Equals","title":"Equals","text":"    jstep = same_direction ? 1 : -1\n    for i in 2:n1\n        ip = GI.getpoint(c1, i)\n        j = jstart + (i - 1) * jstep\n        j += (0 < j <= n2) ? 0 : (n2 * -jstep)\n        jp = GI.getpoint(c2, j)\n        equals(ip, jp) || return false\n    end\n    return true\nend\n\n\"\"\"\n    equals(\n        ::Union{GI.LineTrait, GI.LineStringTrait}, l1,\n        ::Union{GI.LineTrait, GI.LineStringTrait}, l2,\n    )::Bool\n\nTwo lines/linestrings are equal if they share the same set of points going\nalong the curve. Note that lines/linestrings aren't closed by defintion.\n\"\"\"\nequals(\n    ::Union{GI.LineTrait, GI.LineStringTrait}, l1,\n    ::Union{GI.LineTrait, GI.LineStringTrait}, l2,\n) = _equals_curves(l1, l2, false, false)\n\n\"\"\"\n    equals(\n        ::Union{GI.LineTrait, GI.LineStringTrait}, l1,\n        ::GI.LinearRingTrait, l2,\n    )::Bool\n\nA line/linestring and a linear ring are equal if they share the same set of\npoints going along the curve. Note that lines aren't closed by defintion, but\nrings are, so the line must have a repeated last point to be equal\n\"\"\"\nequals(\n    ::Union{GI.LineTrait, GI.LineStringTrait}, l1,\n    ::GI.LinearRingTrait, l2,\n) = _equals_curves(l1, l2, false, true)\n\n\"\"\"\n    equals(\n        ::GI.LinearRingTrait, l1,\n        ::Union{GI.LineTrait, GI.LineStringTrait}, l2,\n    )::Bool\n\nA linear ring and a line/linestring are equal if they share the same set of\npoints going along the curve. Note that lines aren't closed by defintion, but\nrings are, so the line must have a repeated last point to be equal\n\"\"\"\nequals(\n    ::GI.LinearRingTrait, l1,\n    ::Union{GI.LineTrait, GI.LineStringTrait}, l2,\n) = _equals_curves(l1, l2, true, false)\n\n\"\"\"\n    equals(\n        ::GI.LinearRingTrait, l1,\n        ::GI.LinearRingTrait, l2,\n    )::Bool\n\nTwo linear rings are equal if they share the same set of points going along the\ncurve. Note that rings are closed by definition, so they can have, but don't\nneed, a repeated last point to be equal.\n\"\"\"\nequals(\n    ::GI.LinearRingTrait, l1,\n    ::GI.LinearRingTrait, l2,\n) = _equals_curves(l1, l2, true, true)\n\n\"\"\"\n    equals(::GI.PolygonTrait, geom_a, ::GI.PolygonTrait, geom_b)::Bool\n\nTwo polygons are equal if they share the same exterior edge and holes.\n\"\"\"\nfunction equals(::GI.PolygonTrait, geom_a, ::GI.PolygonTrait, geom_b)","category":"page"},{"location":"source/methods/equals/","page":"Equals","title":"Equals","text":"Check if exterior is equal","category":"page"},{"location":"source/methods/equals/","page":"Equals","title":"Equals","text":"    _equals_curves(\n        GI.getexterior(geom_a), GI.getexterior(geom_b),\n        true, true,  # linear rings are closed by definition\n    ) || return false","category":"page"},{"location":"source/methods/equals/","page":"Equals","title":"Equals","text":"Check if number of holes are equal","category":"page"},{"location":"source/methods/equals/","page":"Equals","title":"Equals","text":"    GI.nhole(geom_a) == GI.nhole(geom_b) || return false","category":"page"},{"location":"source/methods/equals/","page":"Equals","title":"Equals","text":"Check if holes are equal","category":"page"},{"location":"source/methods/equals/","page":"Equals","title":"Equals","text":"    for ihole in GI.gethole(geom_a)\n        has_match = false\n        for jhole in GI.gethole(geom_b)\n            if _equals_curves(\n                ihole, jhole,\n                true, true,  # linear rings are closed by definition\n            )\n                has_match = true\n                break\n            end\n        end\n        has_match || return false\n    end\n    return true\nend\n\n\"\"\"\n    equals(::GI.PolygonTrait, geom_a, ::GI.MultiPolygonTrait, geom_b)::Bool\n\nA polygon and a multipolygon are equal if the multipolygon is composed of a\nsingle polygon that is equivalent to the given polygon.\n\"\"\"\nfunction equals(::GI.PolygonTrait, geom_a, ::MultiPolygonTrait, geom_b)\n    GI.npolygon(geom_b) == 1 || return false\n    return equals(geom_a, GI.getpolygon(geom_b, 1))\nend\n\n\"\"\"\n    equals(::GI.MultiPolygonTrait, geom_a, ::GI.PolygonTrait, geom_b)::Bool\n\nA polygon and a multipolygon are equal if the multipolygon is composed of a\nsingle polygon that is equivalent to the given polygon.\n\"\"\"\nequals(trait_a::GI.MultiPolygonTrait, geom_a, trait_b::PolygonTrait, geom_b) =\n    equals(trait_b, geom_b, trait_a, geom_a)\n\n\"\"\"\n    equals(::GI.PolygonTrait, geom_a, ::GI.PolygonTrait, geom_b)::Bool\n\nTwo multipolygons are equal if they share the same set of polygons.\n\"\"\"\nfunction equals(::GI.MultiPolygonTrait, geom_a, ::GI.MultiPolygonTrait, geom_b)","category":"page"},{"location":"source/methods/equals/","page":"Equals","title":"Equals","text":"Check if same number of polygons","category":"page"},{"location":"source/methods/equals/","page":"Equals","title":"Equals","text":"    GI.npolygon(geom_a) == GI.npolygon(geom_b) || return false","category":"page"},{"location":"source/methods/equals/","page":"Equals","title":"Equals","text":"Check if each polygon has a matching polygon","category":"page"},{"location":"source/methods/equals/","page":"Equals","title":"Equals","text":"    for poly_a in GI.getpolygon(geom_a)\n        has_match = false\n        for poly_b in GI.getpolygon(geom_b)\n            if equals(poly_a, poly_b)\n                has_match = true\n                break\n            end\n        end\n        has_match || return false\n    end\n    return true\nend","category":"page"},{"location":"source/methods/equals/","page":"Equals","title":"Equals","text":"","category":"page"},{"location":"source/methods/equals/","page":"Equals","title":"Equals","text":"This page was generated using Literate.jl.","category":"page"},{"location":"source/transformations/tuples/#Tuple-conversion","page":"Tuple conversion","title":"Tuple conversion","text":"","category":"section"},{"location":"source/transformations/tuples/","page":"Tuple conversion","title":"Tuple conversion","text":"\"\"\"\n    tuples(obj)\n\nConvert all points in `obj` to `Tuple`s, wherever the are nested.\n\nReturns a similar object or collection of objects using GeoInterface.jl\ngeometries wrapping `Tuple` points.","category":"page"},{"location":"source/transformations/tuples/","page":"Tuple conversion","title":"Tuple conversion","text":"Keywords","category":"page"},{"location":"source/transformations/tuples/","page":"Tuple conversion","title":"Tuple conversion","text":"$APPLY_KEYWORDS\n\"\"\"\nfunction tuples(geom; kw...)\n    if _is3d(geom)\n        return apply(PointTrait, geom; kw...) do p\n            (Float64(GI.x(p)), Float64(GI.y(p)), Float64(GI.z(p)))\n        end\n    else\n        return apply(PointTrait, geom; kw...) do p\n            (Float64(GI.x(p)), Float64(GI.y(p)))\n        end\n    end\nend","category":"page"},{"location":"source/transformations/tuples/","page":"Tuple conversion","title":"Tuple conversion","text":"","category":"page"},{"location":"source/transformations/tuples/","page":"Tuple conversion","title":"Tuple conversion","text":"This page was generated using Literate.jl.","category":"page"},{"location":"source/methods/geom_relations/contains/#Contains","page":"Contains","title":"Contains","text":"","category":"section"},{"location":"source/methods/geom_relations/contains/","page":"Contains","title":"Contains","text":"export contains","category":"page"},{"location":"source/methods/geom_relations/contains/#What-is-contains?","page":"Contains","title":"What is contains?","text":"","category":"section"},{"location":"source/methods/geom_relations/contains/","page":"Contains","title":"Contains","text":"The contains function checks if a given geometry completly contains another geometry, or in other words, that the second geometry is completly within the first. This requires that the two interiors intersect and that the interior and boundary of the second geometry is not in the exterior of the first geometry.","category":"page"},{"location":"source/methods/geom_relations/contains/","page":"Contains","title":"Contains","text":"To provide an example, consider these two lines:","category":"page"},{"location":"source/methods/geom_relations/contains/","page":"Contains","title":"Contains","text":"import GeometryOps as GO\nimport GeoInterface as GI\nusing Makie\nusing CairoMakie\n\nl1 = GI.LineString([(0.0, 0.0), (1.0, 0.0), (0.0, 0.1)])\nl2 = GI.LineString([(0.25, 0.0), (0.75, 0.0)])\nf, a, p = lines(GI.getpoint(l1), color = :blue)\nscatter!(GI.getpoint(l1), color = :blue)\nlines!(GI.getpoint(l2), color = :orange)\nscatter!(GI.getpoint(l2), color = :orange)\nf","category":"page"},{"location":"source/methods/geom_relations/contains/","page":"Contains","title":"Contains","text":"We can see that all of the points and edges of l2 are within l1, so l1 contains l2. However, l2 does not contain l1.","category":"page"},{"location":"source/methods/geom_relations/contains/","page":"Contains","title":"Contains","text":"GO.contains(l1, l2)  # returns true\nGO.contains(l2, l1)  # returns false","category":"page"},{"location":"source/methods/geom_relations/contains/#Implementation","page":"Contains","title":"Implementation","text":"","category":"section"},{"location":"source/methods/geom_relations/contains/","page":"Contains","title":"Contains","text":"This is the GeoInterface-compatible implementation.","category":"page"},{"location":"source/methods/geom_relations/contains/","page":"Contains","title":"Contains","text":"Given that contains is the exact opposite of within, we simply pass the two inputs variables, swapped in order, to within.","category":"page"},{"location":"source/methods/geom_relations/contains/","page":"Contains","title":"Contains","text":"\"\"\"\n    contains(g1::AbstractGeometry, g2::AbstractGeometry)::Bool\n\nReturn true if the second geometry is completely contained by the first\ngeometry. The interiors of both geometries must intersect and the interior and\nboundary of the secondary (g2) must not intersect the exterior of the first\n(g1).\n\n`contains` returns the exact opposite result of `within`.\n\n# Examples\n\n```jldoctest\nimport GeometryOps as GO, GeoInterface as GI\nline = GI.LineString([(1, 1), (1, 2), (1, 3), (1, 4)])\npoint = GI.Point((1, 2))\n\nGO.contains(line, point)","category":"page"},{"location":"source/methods/geom_relations/contains/","page":"Contains","title":"Contains","text":"output","category":"page"},{"location":"source/methods/geom_relations/contains/","page":"Contains","title":"Contains","text":"true\n```\n\"\"\"\ncontains(g1, g2) = GeometryOps.within(g2, g1)","category":"page"},{"location":"source/methods/geom_relations/contains/","page":"Contains","title":"Contains","text":"","category":"page"},{"location":"source/methods/geom_relations/contains/","page":"Contains","title":"Contains","text":"This page was generated using Literate.jl.","category":"page"},{"location":"source/methods/area/#Area-and-signed-area","page":"Area and signed area","title":"Area and signed area","text":"","category":"section"},{"location":"source/methods/area/","page":"Area and signed area","title":"Area and signed area","text":"export area, signed_area","category":"page"},{"location":"source/methods/area/#What-is-area?-What-is-signed-area?","page":"Area and signed area","title":"What is area? What is signed area?","text":"","category":"section"},{"location":"source/methods/area/","page":"Area and signed area","title":"Area and signed area","text":"Area is the amount of space occupied by a two-dimensional figure. It is always a positive value. Signed area is simply the integral over the exterior path of a polygon, minus the sum of integrals over its interior holes. It is signed such that a clockwise path has a positive area, and a counterclockwise path has a negative area. The area is the absolute value of the signed area.","category":"page"},{"location":"source/methods/area/","page":"Area and signed area","title":"Area and signed area","text":"To provide an example, consider this rectangle:","category":"page"},{"location":"source/methods/area/","page":"Area and signed area","title":"Area and signed area","text":"import GeometryOps as GO\nimport GeoInterface as GI\nusing Makie\nusing CairoMakie\n\nrect = GI.Polygon([[(0,0), (0,1), (1,1), (1,0), (0, 0)]])\nf, a, p = poly(collect(GI.getpoint(rect)); axis = (; aspect = DataAspect()))","category":"page"},{"location":"source/methods/area/","page":"Area and signed area","title":"Area and signed area","text":"This is clearly a rectangle, etc.  But now let's look at how the points look:","category":"page"},{"location":"source/methods/area/","page":"Area and signed area","title":"Area and signed area","text":"lines!(\n    collect(GI.getpoint(rect));\n    color = 1:GI.npoint(rect), linewidth = 10.0)\nf","category":"page"},{"location":"source/methods/area/","page":"Area and signed area","title":"Area and signed area","text":"The points are ordered in a counterclockwise fashion, which means that the signed area is negative.  If we reverse the order of the points, we get a postive area.","category":"page"},{"location":"source/methods/area/","page":"Area and signed area","title":"Area and signed area","text":"GO.signed_area(rect)  # -1.0","category":"page"},{"location":"source/methods/area/#Implementation","page":"Area and signed area","title":"Implementation","text":"","category":"section"},{"location":"source/methods/area/","page":"Area and signed area","title":"Area and signed area","text":"This is the GeoInterface-compatible implementation. First, we implement a wrapper method that dispatches to the correct implementation based on the geometry trait. This is also used in the implementation, since it's a lot less work!","category":"page"},{"location":"source/methods/area/","page":"Area and signed area","title":"Area and signed area","text":"Note that area (and signed area) are zero for all points and curves, even if the curves are closed like with a linear ring. Also note that signed area really only makes sense for polygons, given with a multipolygon can have several polygons each with a different orientation and thus the absolute value of the signed area might not be the area. This is why signed area is only implemented for polygons.","category":"page"},{"location":"source/methods/area/","page":"Area and signed area","title":"Area and signed area","text":"const _AREA_TARGETS = Union{GI.PolygonTrait,GI.AbstractCurveTrait,GI.MultiPointTrait,GI.PointTrait}\n\n\"\"\"\n    area(geom, ::Type{T} = Float64)::T\n\nReturns the area of a geometry or collection of geometries.\nThis is computed slightly differently for different geometries:\n\n    - The area of a point/multipoint is always zero.\n    - The area of a curve/multicurve is always zero.\n    - The area of a polygon is the absolute value of the signed area.\n    - The area multi-polygon is the sum of the areas of all of the sub-polygons.\n    - The area of a geometry collection, feature collection of array/iterable\n        is the sum of the areas of all of the sub-geometries.\n\nResult will be of type T, where T is an optional argument with a default value\nof Float64.\n\"\"\"\nfunction area(geom, ::Type{T} = Float64; threaded=false) where T <: AbstractFloat\n    applyreduce(+, _AREA_TARGETS, geom; threaded, init=zero(T)) do g\n        _area(T, GI.trait(g), g)\n    end\nend\n\n\n\"\"\"\n    signed_area(geom, ::Type{T} = Float64)::T\n\nReturns the signed area of a single geometry, based on winding order.\nThis is computed slighly differently for different geometries:\n\n    - The signed area of a point is always zero.\n    - The signed area of a curve is always zero.\n    - The signed area of a polygon is computed with the shoelace formula and is\n    positive if the polygon coordinates wind clockwise and negative if\n    counterclockwise.\n    - You cannot compute the signed area of a multipolygon as it doesn't have a\n    meaning as each sub-polygon could have a different winding order.\n\nResult will be of type T, where T is an optional argument with a default value\nof Float64.\n\"\"\"\nsigned_area(geom, ::Type{T} = Float64) where T <: AbstractFloat =\n    _signed_area(T, GI.trait(geom), geom)","category":"page"},{"location":"source/methods/area/","page":"Area and signed area","title":"Area and signed area","text":"Points, MultiPoints, Curves, MultiCurves","category":"page"},{"location":"source/methods/area/","page":"Area and signed area","title":"Area and signed area","text":"_area(::Type{T}, ::GI.AbstractGeometryTrait, geom) where T = zero(T)\n\n_signed_area(::Type{T}, ::GI.AbstractGeometryTrait, geom) where T = zero(T)","category":"page"},{"location":"source/methods/area/","page":"Area and signed area","title":"Area and signed area","text":"Polygons","category":"page"},{"location":"source/methods/area/","page":"Area and signed area","title":"Area and signed area","text":"_area(::Type{T}, trait::GI.PolygonTrait, poly) where T =\n    abs(_signed_area(T, trait, poly))\n\nfunction _signed_area(::Type{T}, ::GI.PolygonTrait, poly) where T\n    GI.isempty(poly) && return zero(T)\n    s_area = _signed_area(T, GI.getexterior(poly))\n    area = abs(s_area)\n    area == 0 && return area","category":"page"},{"location":"source/methods/area/","page":"Area and signed area","title":"Area and signed area","text":"Remove hole areas from total","category":"page"},{"location":"source/methods/area/","page":"Area and signed area","title":"Area and signed area","text":"    for hole in GI.gethole(poly)\n        area -= abs(_signed_area(T, hole))\n    end","category":"page"},{"location":"source/methods/area/","page":"Area and signed area","title":"Area and signed area","text":"Winding of exterior ring determines sign","category":"page"},{"location":"source/methods/area/","page":"Area and signed area","title":"Area and signed area","text":"    return area * sign(s_area)\nend","category":"page"},{"location":"source/methods/area/","page":"Area and signed area","title":"Area and signed area","text":"Helper function:","category":"page"},{"location":"source/methods/area/","page":"Area and signed area","title":"Area and signed area","text":"Calculates the signed area of a given curve. This is equivalent to integrating to find the area under the curve. Even if curve isn't explicitly closed by repeating the first point at the end of the coordinates, curve is still assumed to be closed.","category":"page"},{"location":"source/methods/area/","page":"Area and signed area","title":"Area and signed area","text":"function _signed_area(::Type{T}, geom) where T\n    area = zero(T)\n    np = GI.npoint(geom)\n    np == 0 && return area\n\n    first = true\n    local pfirst, p1","category":"page"},{"location":"source/methods/area/","page":"Area and signed area","title":"Area and signed area","text":"Integrate the area under the curve","category":"page"},{"location":"source/methods/area/","page":"Area and signed area","title":"Area and signed area","text":"    for p2 in GI.getpoint(geom)","category":"page"},{"location":"source/methods/area/","page":"Area and signed area","title":"Area and signed area","text":"Skip the first and do it later This lets us work within one iteration over geom, which means on C call when using points from external libraries.","category":"page"},{"location":"source/methods/area/","page":"Area and signed area","title":"Area and signed area","text":"        if first\n            p1 = pfirst = p2\n            first = false\n            continue\n        end","category":"page"},{"location":"source/methods/area/","page":"Area and signed area","title":"Area and signed area","text":"Accumulate the area into area","category":"page"},{"location":"source/methods/area/","page":"Area and signed area","title":"Area and signed area","text":"        area += GI.x(p1) * GI.y(p2) - GI.y(p1) * GI.x(p2)\n        p1 = p2\n    end","category":"page"},{"location":"source/methods/area/","page":"Area and signed area","title":"Area and signed area","text":"Complete the last edge. If the first and last where the same this will be zero","category":"page"},{"location":"source/methods/area/","page":"Area and signed area","title":"Area and signed area","text":"    p2 = pfirst\n    area += GI.x(p1) * GI.y(p2) - GI.y(p1) * GI.x(p2)\n    return T(area / 2)\nend","category":"page"},{"location":"source/methods/area/","page":"Area and signed area","title":"Area and signed area","text":"","category":"page"},{"location":"source/methods/area/","page":"Area and signed area","title":"Area and signed area","text":"This page was generated using Literate.jl.","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/#Line-curve-interaction","page":"Line-curve interaction","title":"Line-curve interaction","text":"","category":"section"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"#= Code is based off of DE-9IM Standards (https://en.wikipedia.org/wiki/DE-9IM)\nand attempts a standardized solution for most of the functions.\n=#\n\n\"\"\"\n    Enum PointOrientation\n\nEnum for the orientation of a point with respect to a curve. A point can be\n`point_in` the curve, `point_on` the curve, or `point_out` of the curve.\n\"\"\"\n@enum PointOrientation point_in=1 point_on=2 point_out=3\n\n\"\"\"\n    Enum LineOrientation\nEnum for the orientation of a line with respect to a curve. A line can be\n`line_cross` (crossing over the curve), `line_hinge` (crossing the endpoint of the curve),\n`line_over` (colinear with the curve), or `line_out` (not interacting with the curve).\n\"\"\"\n@enum LineOrientation line_cross=1 line_hinge=2 line_over=3 line_out=4","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"Determines if a point meets the given checks with respect to a curve.","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"If inallow is true, the point can be on the curve interior. If onallow is true, the point can be on the curve boundary. If out_allow is true, the point can be disjoint from the curve.","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"If the point is in an \"allowed\" location, return true. Else, return false.","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"If closed_curve is true, curve is treated as a closed curve where the first and last point are connected by a segment.","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"function _point_curve_process(\n    point, curve;\n    in_allow, on_allow, out_allow,\n    closed_curve = false,\n)","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"Determine if curve is closed","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"    n = GI.npoint(curve)\n    first_last_equal = equals(GI.getpoint(curve, 1), GI.getpoint(curve, n))\n    closed_curve |= first_last_equal\n    n -= first_last_equal ? 1 : 0","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"Loop through all curve segments","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"    p_start = GI.getpoint(curve, closed_curve ? n : 1)\n    @inbounds for i in (closed_curve ? 1 : 2):n\n        p_end = GI.getpoint(curve, i)\n        seg_val = _point_segment_orientation(point, p_start, p_end)\n        seg_val == point_in && return in_allow\n        if seg_val == point_on\n            if !closed_curve  # if point is on curve endpoints, it is \"on\"\n                i == 2 && equals(point, p_start) && return on_allow\n                i == n && equals(point, p_end) && return on_allow\n            end\n            return in_allow\n        end\n        p_start = p_end\n    end\n    return out_allow\nend","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"Determines if a point meets the given checks with respect to a polygon.","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"If inallow is true, the point can be within the polygon interior If onallow is true, the point can be on the polygon boundary. If out_allow is true, the point can be disjoint from the polygon.","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"If the point is in an \"allowed\" location, return true. Else, return false.","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"function _point_polygon_process(\n    point, polygon;\n    in_allow, on_allow, out_allow,\n)","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"Check interaction of geom with polygon's exterior boundary","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"    ext_val = _point_filled_curve_orientation(point, GI.getexterior(polygon))","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"If a point is outside, it isn't interacting with any holes","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"    ext_val == point_out && return out_allow","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"if a point is on an external boundary, it isn't interacting with any holes","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"    ext_val == point_on && return on_allow","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"If geom is within the polygon, need to check interactions with holes","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"    for hole in GI.gethole(polygon)\n        hole_val = _point_filled_curve_orientation(point, hole)","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"If a point in in a hole, it is outside of the polygon","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"        hole_val == point_in && return out_allow","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"If a point in on a hole edge, it is on the edge of the polygon","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"        hole_val == point_on && return on_allow\n    end","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"Point is within external boundary and on in/on any holes","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"    return in_allow\nend","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"Determines if a line meets the given checks with respect to a curve.","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"If overallow is true, segments of the line and curve can be co-linear. If crossallow is true, segments of the line and curve can cross. If onallow is true, endpoints of either the line or curve can intersect a     segment of the other geometry. If crossallow is true, segments of the line and curve can be disjoint.","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"If inrequire is true, the interiors of the line and curve must meet in at least     one point. If onrequire is true, the bounday of one of the two geometries can meet the     interior or boundary of the other geometry in at least one point. If out_require is true, there must be at least one point of the given line that     is exterior of the curve.","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"If the point is in an \"allowed\" location and meets all requirments, return true. Else, return false.","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"If closedline is true, line is treated as a closed line where the first and last point are connected by a segment. Same with closedcurve.","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"function _line_curve_process(\n    line, curve;\n    over_allow, cross_allow, on_allow, out_allow,\n    in_require, on_require, out_require,\n    closed_line = false,\n    closed_curve = false,\n)","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"Set up requirments","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"    in_req_met = !in_require\n    on_req_met = !on_require\n    out_req_met = !out_require","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"Determine curve endpoints","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"    nl = GI.npoint(line)\n    nc = GI.npoint(curve)\n    first_last_equal_line = equals(GI.getpoint(line, 1), GI.getpoint(line, nl))\n    first_last_equal_curve = equals(GI.getpoint(curve, 1), GI.getpoint(curve, nc))\n    nl -= first_last_equal_line ? 1 : 0\n    nc -= first_last_equal_curve ? 1 : 0\n    closed_line |= first_last_equal_line\n    closed_curve |= first_last_equal_curve","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"Loop over each line segment","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"    l_start = _tuple_point(GI.getpoint(line, closed_line ? nl : 1))\n    i = closed_line ? 1 : 2\n    while i ≤ nl\n        l_end = _tuple_point(GI.getpoint(line, i))\n        c_start = _tuple_point(GI.getpoint(curve, closed_curve ? nc : 1))","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"Loop over each curve segment","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"        for j in (closed_curve ? 1 : 2):nc\n            c_end = _tuple_point(GI.getpoint(curve, j))","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"Check if line and curve segments meet","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"            seg_val = _segment_segment_orientation((l_start, l_end), (c_start, c_end))","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"If segments are co-linear","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"            if seg_val == line_over\n                !over_allow && return false","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"at least one point in, meets requirments","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"                in_req_met = true\n                point_val = _point_segment_orientation(l_start, c_start, c_end)","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"If entire segment isn't covered, consider remaining section","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"                if point_val != point_out\n                    i, l_start, break_off = _find_new_seg(i, l_start, l_end, c_start, c_end)\n                    break_off && break\n                end\n            else\n                if seg_val == line_cross\n                    !cross_allow && return false\n                    in_req_met = true\n                elseif seg_val == line_hinge  # could cross or overlap","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"Determine location of intersection point on each segment","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"                    (α, β) = _find_intersect_fracs(l_start, l_end, c_start, c_end)\n                    if ( # Don't consider edges of curves as they can't cross\n                        (!closed_line && ((α == 0 && i == 2) || (α == 1 && i == nl))) ||\n                        (!closed_curve && ((β == 0 && j == 2) || (β == 1 && j == nc)))\n                    )\n                        !on_allow && return false\n                        on_req_met = true\n                    else\n                        in_req_met = true","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"If needed, determine if hinge actually crosses","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"                        if (!cross_allow || !over_allow) && α != 0 && β != 0","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"Find next pieces of hinge to see if line and curve cross","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"                            l, c = _find_hinge_next_segments(\n                                α, β, l_start, l_end, c_start, c_end,\n                                i, line, j, curve,\n                            )\n                            if _segment_segment_orientation(l, c) == line_hinge\n                                !cross_allow && return false\n                            else\n                                !over_allow && return false\n                            end\n                        end\n                    end\n                end","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"no overlap for a give segment, some of segment must be out of curve","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"                if j == nc\n                    !out_allow && return false\n                    out_req_met = true\n                end\n            end\n            c_start = c_end  # consider next segment of curve\n            if j == nc  # move on to next line segment\n                i += 1\n                l_start = l_end\n            end\n        end\n    end\n    return in_req_met && on_req_met && out_req_met\nend\n\n#= If entire segment (le to ls) isn't covered by segment (cs to ce), find remaining section\npart of section outside of cs to ce. If completly covered, increase segment index i. =#\nfunction _find_new_seg(i, ls, le, cs, ce)\n    break_off = true\n    if _point_segment_orientation(le, cs, ce) != point_out\n        ls = le\n        i += 1\n    elseif !equals(ls, cs) && _point_segment_orientation(cs, ls, le) != point_out\n        ls = cs\n    elseif !equals(ls, ce) && _point_segment_orientation(ce, ls, le) != point_out\n        ls = ce\n    else\n        break_off = false\n    end\n    return i, ls, break_off\nend\n\n#= Find where line and curve segments intersect by fraction of length. α is the fraction of\nthe line (ls to le) and β is the traction of the curve (cs to ce). All inputs are tuples. =#\nfunction _find_intersect_fracs(ls, le, cs, ce)\n    _, fracs = _intersection_point(\n        Float64,\n        (ls, le),\n        (cs, ce)\n    )\n    (α, β) = if !isnothing(fracs)\n        fracs\n    else  # line and curve segments are parallel\n        if equals(ls, cs)\n            (0, 0)\n        elseif equals(ls, ce)\n            (0, 1)\n        elseif equals(le, cs)\n            (1, 0)\n        else  # equals(l_end, c_end)\n            (1, 1)\n        end\n    end\n    return α, β\nend\n\n#= Find next set of segments needed to determine if given hinge segments cross or not.=#\nfunction _find_hinge_next_segments(α, β, ls, le, cs, ce, i, line, j, curve)\n    next_seg = if β == 1\n        if α == 1  # hinge at endpoints, so next segment of both is needed\n            ((le, _tuple_point(GI.getpoint(line, i + 1))), (ce, _tuple_point(GI.getpoint(curve, j + 1))))\n        else  # hinge at curve endpoint and line interior point, curve next segment needed\n            ((ls, le), (ce, _tuple_point(GI.getpoint(curve, j + 1))))\n        end\n    else  # hinge at curve interior point and line endpoint, line next segment needed\n        ((le, _tuple_point(GI.getpoint(line, i + 1))), (cs, ce))\n    end\n    return next_seg\nend","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"Determines if a line meets the given checks with respect to a polygon.","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"If inallow is true, segments of the line can be in the polygon interior. If onallow is true, segments of the line can be on the polygon's boundary. If out_allow is true, segments of the line can be outside of the polygon.","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"If inrequire is true, the interiors of the line and polygon must meet in at     least one point. If onrequire is true, the line must have at least one point on the polygon'same     boundary. If out_require is true, the line must have at least one point outside of the     polygon.","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"If the point is in an \"allowed\" location and meets all requirments, return true. Else, return false.","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"If closed_line is true, line is treated as a closed line where the first and last point are connected by a segment.","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"function _line_polygon_process(\n    line, polygon;\n    in_allow, on_allow, out_allow,\n    in_require, on_require, out_require,\n    closed_line = false,\n)\n    in_req_met = !in_require\n    on_req_met = !on_require\n    out_req_met = !out_require","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"Check interaction of line with polygon's exterior boundary","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"    in_curve, on_curve, out_curve = _line_filled_curve_interactions(\n        line, GI.getexterior(polygon);\n        closed_line = closed_line,\n    )\n    if on_curve\n        !on_allow && return false\n        on_req_met = true\n    end\n    if out_curve\n        !out_allow && return false\n        out_req_met = true\n    end","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"If no points within the polygon, the line is disjoint and we are done","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"    !in_curve && return in_req_met && on_req_met && out_req_met","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"Loop over polygon holes","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"    for hole in GI.gethole(polygon)\n        in_hole, on_hole, out_hole =_line_filled_curve_interactions(\n            line, hole;\n            closed_line = closed_line,\n        )\n        if in_hole  # line in hole is equivalent to being out of polygon\n            !out_allow && return false\n            out_req_met = true\n        end\n        if on_hole  # hole bounday is polygon boundary\n            !on_allow && return false\n            on_req_met = true\n        end\n        if !out_hole  # entire line is in/on hole, can't be in/on other holes\n            in_curve = false\n            break\n        end\n    end\n    if in_curve  # entirely of curve isn't within a hole\n        !in_allow && return false\n        in_req_met = true\n    end\n    return in_req_met && on_req_met && out_req_met\nend","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"Determines if a polygon meets the given checks with respect to a polygon.","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"If inallow is true, the polygon's interiors must intersect. If onallow is true, the one of the polygon's boundaries must either interact     with the other polygon's boundary or interior. If out_allow is true, the first polygon must have interior regions outside of     the second polygon.","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"If inrequire is true, the polygon interiors must meet in at least one point. If onrequire is true, one of the polygon's must have at least one boundary     point in or on the other polygon. If out_require is true, the first polygon must have at least one interior point     outside of the second polygon.","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"If the point is in an \"allowed\" location and meets all requirments, return true. Else, return false.","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"function _polygon_polygon_process(\n    poly1, poly2;\n    in_allow, on_allow, out_allow,\n    in_require, on_require, out_require,\n)\n    in_req_met = !in_require\n    on_req_met = !on_require\n    out_req_met = !out_require","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"Check if exterior of poly1 is within poly2","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"    ext1 = GI.getexterior(poly1)\n    ext2 = GI.getexterior(poly2)","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"Check if exterior of poly1 is in polygon 2","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"    e1_in_p2, e1_on_p2, e1_out_p2 = _line_polygon_interactions(\n        ext1, poly2;\n        closed_line = true,\n    )\n    if e1_on_p2\n        !on_allow && return false\n        on_req_met = true\n    end\n    if e1_out_p2\n        !out_allow && return false\n        out_req_met = true\n    end\n\n    if !e1_in_p2","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"if exterior ring isn't in poly2, check if it surrounds poly2","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"        _, _, e2_out_e1 = _line_filled_curve_interactions(\n            ext2, ext1;\n            closed_line = true,\n        )  # if they really are disjoint, we are done\n        e2_out_e1 && return in_req_met && on_req_met && out_req_met\n    end","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"If interiors interact, check if poly2 interacts with any of poly1's holes","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"    for h1 in GI.gethole(poly1)\n        h1_in_p2, h1_on_p2, h1_out_p2 = _line_polygon_interactions(\n            h1, poly2;\n            closed_line = true,\n        )\n        if h1_on_p2\n            !on_allow && return false\n            on_req_met = true\n        end\n        if h1_out_p2\n            !out_allow && return false\n            out_req_met = true\n        end\n        if !h1_in_p2","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"If hole isn't in poly2, see if poly2 is in hole","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"            _, _, e2_out_h1 = _line_filled_curve_interactions(\n                ext2, h1;\n                closed_line = true,\n            )","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"hole encompasses all of poly2","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"            !e2_out_h1 && return in_req_met && on_req_met && out_req_met\n            break\n        end\n    end\n    #=\n    poly2 isn't outside of poly1 and isn't in a hole, poly1 interior must\n    interact with poly2 interior\n    =#\n    !in_allow && return false\n    in_req_met = true","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"If any of poly2 holes are within poly1, part of poly1 is exterior to poly2","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"    for h2 in GI.gethole(poly2)\n        h2_in_p1, h2_on_p1, _ = _line_polygon_interactions(\n            h2, poly1;\n            closed_line = true,\n        )\n        if h2_on_p1\n            !on_allow && return false\n            on_req_met = true\n        end\n        if h2_in_p1\n            !out_allow && return false\n            out_req_met = true\n        end\n    end\n    return in_req_met && on_req_met && out_req_met\nend","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"Determines if a point is in, on, or out of a segment. If the point is on the segment it is on one of the segments endpoints. If it is in, it is on any other point of the segment. If the point is not on any part of the segment, it is out of the segment.","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"Point should be an object of point trait and curve should be an object with a linestring or linearring trait.","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"Can provide values of in, on, and out keywords, which determines return values for each scenario.","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"function _point_segment_orientation(\n    point, start, stop;\n    in::T = point_in, on::T = point_on, out::T = point_out,\n) where {T}","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"Parse out points","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"    x, y = GI.x(point), GI.y(point)\n    x1, y1 = GI.x(start), GI.y(start)\n    x2, y2 = GI.x(stop), GI.y(stop)\n    Δx_seg = x2 - x1\n    Δy_seg = y2 - y1\n    Δx_pt = x - x1\n    Δy_pt = y - y1\n    if (Δx_pt == 0 && Δy_pt == 0) || (Δx_pt == Δx_seg && Δy_pt == Δy_seg)","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"If point is equal to the segment start or end points","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"        return on\n    else\n        #=\n        Determine if the point is on the segment -> see if vector from segment\n        start to point is parallel to segment and if point is between the\n        segment endpoints\n        =#\n        on_line = _isparallel(Δx_seg, Δy_seg, Δx_pt, Δy_pt)\n        !on_line && return out\n        between_endpoints =\n            (x2 > x1 ? x1 <= x <= x2 : x2 <= x <= x1) &&\n            (y2 > y1 ? y1 <= y <= y2 : y2 <= y <= y1)\n        !between_endpoints && return out\n    end\n    return in\nend","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"Determine if point is in, on, or out of a closed curve, which includes the space enclosed by the closed curve.","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"In means the point is within the closed curve (excluding edges and vertices). On means the point is on an edge or a vertex of the closed curve. Out means the point is outside of the closed curve.","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"Point should be an object of point trait and curve should be an object with a linestring or linearring trait, that is assumed to be closed, regardless of repeated last point.","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"Can provide values of in, on, and out keywords, which determines return values for each scenario.","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"Note that this uses the Algorithm by Hao and Sun (2018): https://doi.org/10.3390/sym10100477 Paper seperates orientation of point and edge into 26 cases. For each case, it is either a case where the point is on the edge (returns on), where a ray from the point (x, y) to infinity along the line y = y cut through the edge (k += 1), or the ray does not pass through the edge (do nothing and continue). If the ray passes through an odd number of edges, it is within the curve, else outside of of the curve if it didn't return 'on'. See paper for more information on cases denoted in comments.","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"function _point_filled_curve_orientation(\n    point, curve;\n    in::T = point_in, on::T = point_on, out::T = point_out,\n) where {T}\n    x, y = GI.x(point), GI.y(point)\n    n = GI.npoint(curve)\n    n -= equals(GI.getpoint(curve, 1), GI.getpoint(curve, n)) ? 1 : 0\n    k = 0  # counter for ray crossings\n    p_start = GI.getpoint(curve, n)\n    @inbounds for i in 1:n\n        p_end = GI.getpoint(curve, i)\n        v1 = GI.y(p_start) - y\n        v2 = GI.y(p_end) - y\n        if !((v1 < 0 && v2 < 0) || (v1 > 0 && v2 > 0)) # if not cases 11 or 26\n            u1 = GI.x(p_start) - x\n            u2 = GI.x(p_end) - x\n            c1 = u1 * v2  # first element of cross product summation\n            c2 = u2 * v1  # second element of cross product summation\n            f = c1 - c2\n            if v2 > 0 && v1 ≤ 0                # Case 3, 9, 16, 21, 13, or 24\n                (c1 ≈ c2) && return on         # Case 16 or 21\n                f > 0 && (k += 1)              # Case 3 or 9\n            elseif v1 > 0 && v2 ≤ 0            # Case 4, 10, 19, 20, 12, or 25\n                (c1 ≈ c2) && return on         # Case 19 or 20\n                f < 0 && (k += 1)              # Case 4 or 10\n            elseif v2 == 0 && v1 < 0           # Case 7, 14, or 17\n                (c1 ≈ c2) && return on         # Case 17\n            elseif v1 == 0 && v2 < 0           # Case 8, 15, or 18\n                (c1 ≈ c2) && return on         # Case 18\n            elseif v1 == 0 && v2 == 0          # Case 1, 2, 5, 6, 22, or 23\n                u2 ≤ 0 && u1 ≥ 0 && return on  # Case 1\n                u1 ≤ 0 && u2 ≥ 0 && return on  # Case 2\n            end\n        end\n        p_start = p_end\n    end\n    return iseven(k) ? out : in\nend","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"Determines the type of interaction between two line segments. If the segments cross, this means that they have a single intersection point that isn't on either of their enpoints. If they form a hinge, they meet at one of the segments endpoints. If they are over, then they are co-linear for at least some of the length of the segments. Finally, if they are out, then the segments are disjoint.","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"Point should be an object of point trait and curve should be an object with a linestring or linearring trait.","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"Can provide values of in, on, and out keywords, which determines return values for each scenario.","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"function _segment_segment_orientation(\n    (a_point, b_point), (c_point, d_point);\n    cross::T = line_cross, hinge::T = line_hinge,\n    over::T = line_over, out::T = line_out,\n) where T\n    (ax, ay) = Float64.(a_point)\n    (bx, by) = Float64.(b_point)\n    (cx, cy) = Float64.(c_point)\n    (dx, dy) = Float64.(d_point)\n    meet_type = ExactPredicates.meet((ax, ay), (bx, by), (cx, cy), (dx, dy))","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"Lines meet at one point within open segments","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"    meet_type == 1 && return cross","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"Lines don't meet at any points","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"    meet_type == -1 && return out","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"Lines meet at one or more points within closed segments","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"    if _isparallel(((ax, ay), (bx, by)), ((cx, cy), (dx, dy)))\n        min_x, max_x = cx < dx ? (cx, dx) : (dx, cx)\n        min_y, max_y = cy < dy ? (cy, dy) : (dy, cy)\n        if (\n            ((ax ≤ min_x && bx ≤ min_x) || (ax ≥ max_x && bx ≥ max_x)) &&\n            ((ay ≤ min_y && by ≤ min_y) || (ay ≥ max_y && by ≥ max_y))\n        )","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"apoint and bpoint are on the same side of segment, don't overlap","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"            return hinge\n        else\n            return over\n        end\n    end","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"if lines aren't parallel then they must hinge","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"    return hinge\nend","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"Determines the types of interactions of a line with a filled-in curve. By filled-in curve, I am referring to the exterior ring of a poylgon, for example.","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"Returns a tuple of booleans: (incurve, oncurve, out_curve).","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"If incurve is true, some of the lines interior points interact with the curve's     interior points. If oncurve is true, endpoints of either the line intersect with the curve or     the line interacts with the polygon boundary. If out_curve is true, at least one segments of the line is outside the curve.","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"If closed_line is true, line is treated as a closed line where the first and last point are connected by a segment.","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"function _line_filled_curve_interactions(\n    line, curve;\n    closed_line = false,\n)\n    in_curve = false\n    on_curve = false\n    out_curve = false","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"Determine number of points in curve and line","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"    nl = GI.npoint(line)\n    nc = GI.npoint(curve)\n    first_last_equal_line = equals(GI.getpoint(line, 1), GI.getpoint(line, nl))\n    first_last_equal_curve = equals(GI.getpoint(curve, 1), GI.getpoint(curve, nc))\n    nl -= first_last_equal_line ? 1 : 0\n    nc -= first_last_equal_curve ? 1 : 0\n    closed_line |= first_last_equal_line","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"See if first point is in an acceptable orientation","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"    l_start = _tuple_point(GI.getpoint(line, closed_line ? nl : 1))\n    point_val = _point_filled_curve_orientation(l_start, curve)\n    if point_val == point_in\n        in_curve = true\n    elseif point_val == point_on\n        on_curve = true\n    else  # point_val == point_out\n        out_curve = true\n    end","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"Check for any intersections between line and curve","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"    for i in (closed_line ? 1 : 2):nl\n        l_end = _tuple_point(GI.getpoint(line, i))\n        c_start = _tuple_point(GI.getpoint(curve, nc))","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"If already interacted with all regions of curve, can stop","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"        in_curve && on_curve && out_curve && break","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"Check next segment of line against curve","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"        for j in 1:nc\n            c_end = _tuple_point(GI.getpoint(curve, j))","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"Check if two line and curve segments meet","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"            seg_val = _segment_segment_orientation(\n                (l_start, l_end),\n                (c_start, c_end),\n            )\n            if seg_val != line_out","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"If line and curve meet, then at least one point is on boundary","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"                on_curve = true\n                if seg_val == line_cross","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"When crossing boundary, line is both in and out of curve","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"                    in_curve = true\n                    out_curve = true\n                else\n                    if seg_val == line_over\n                        sp = _point_segment_orientation(l_start, c_start, c_end)\n                        lp = _point_segment_orientation(l_end, c_start, c_end)\n                        if sp != point_in || lp != point_in\n                            #=\n                            Line crosses over segment endpoint, creating a hinge\n                            with another segment.\n                            =#\n                            seg_val = line_hinge\n                        end\n                    end\n                    if seg_val == line_hinge\n                        #=\n                        Can't determine all types of interactions (in, out) with\n                        hinge as it could pass through multiple other segments\n                        so calculate if segment endpoints and intersections are\n                        in/out of filled curve\n                        =#\n                        ipoints = intersection_points(\n                            GI.Line([l_start, l_end]),\n                            curve\n                        )\n                        npoints = length(ipoints)  # since hinge, at least one\n                        sort!(ipoints, by = p -> _euclid_distance(Float64, p, l_start))\n                        p_start = _tuple_point(l_start)\n                        for i in 1:(npoints + 1)\n                            p_end = i ≤ npoints ?\n                                _tuple_point(ipoints[i]) :\n                                l_end\n                            mid_val = _point_filled_curve_orientation(\n                                (p_start .+ p_end) ./ 2,\n                                curve,\n                            )\n                            if mid_val == point_in\n                                in_curve = true\n                            elseif mid_val == point_out\n                                out_curve = true\n                            end\n                        end","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"already checked segment against whole filled curve","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"                        l_start = l_end\n                        break\n                    end\n                end\n            end\n            c_start = c_end\n        end\n        l_start = l_end\n    end\n    return in_curve, on_curve, out_curve\nend","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"Determines the types of interactions of a line with a polygon.","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"Returns a tuple of booleans: (inpoly, onpoly, out_poly).","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"If inpoly is true, some of the lines interior points interact with the polygon     interior points. If inpoly is true, endpoints of either the line intersect with the polygon or     the line interacts with the polygon boundary, including hole bounaries. If out_curve is true, at least one segments of the line is outside the polygon,     including inside of holes.","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"If closed_line is true, line is treated as a closed line where the first and last point are connected by a segment.","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"function _line_polygon_interactions(\n    line, polygon;\n    closed_line = false,\n)\n    in_poly, on_poly, out_poly = _line_filled_curve_interactions(\n        line, GI.getexterior(polygon);\n        closed_line = closed_line,\n    )\n    !in_poly && return (in_poly, on_poly, out_poly)","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"Loop over polygon holes","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"    for hole in GI.gethole(polygon)\n        in_hole, on_hole, out_hole =_line_filled_curve_interactions(\n            line, hole;\n            closed_line = closed_line,\n        )\n        if in_hole\n            out_poly = true\n        end\n        if on_hole\n            on_poly = true\n        end\n        if !out_hole  # entire line is in/on hole, can't be in/on other holes\n            in_poly = false\n            return (in_poly, on_poly, out_poly)\n        end\n    end\n    return in_poly, on_poly, out_poly\nend\n\nfunction _point_in_extent(p, extent::Extents.Extent)\n    (x1, x2), (y1, y2) = extent.X, extent.Y\n    return x1 ≤ GI.x(p) ≤ x2 && y1 ≤ GI.y(p) ≤ y2\nend","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"","category":"page"},{"location":"source/methods/geom_relations/geom_geom_processors/","page":"Line-curve interaction","title":"Line-curve interaction","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#GeometryOps.jl","page":"Home","title":"GeometryOps.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: Dev) (Image: Build Status)","category":"page"},{"location":"","page":"Home","title":"Home","text":"<img src=\"docs/src/assets/logo.png\" alt=\"GeometryOps logo\" width=\"250\">","category":"page"},{"location":"","page":"Home","title":"Home","text":"GeometryOps.jl is a package for geometric calculations on (primarily 2D) geometries.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The driving idea behind this package is to unify all the disparate packages for geometric calculations in Julia, and make them GeoInterface.jl-compatible. We seem to be focusing primarily on 2/2.5D geometries for now.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Most of the usecases are driven by GIS and similar Earth data workflows, so this might be a bit specialized towards that, but methods should always be general to any coordinate space.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We welcome contributions, either as pull requests or discussion on issues!","category":"page"},{"location":"#Methods","page":"Home","title":"Methods","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GeometryOps tries to offer most of the basic geometry operations you'd need, implemented in pure Julia and accepting any GeoInterface.jl compatible type.","category":"page"},{"location":"","page":"Home","title":"Home","text":"General geometry methods (OGC methods): equals, extent, distance, crosses, contains, intersects, etc\nTargeted function application over large nested geometries (apply)\nsigned_area, centroid, distance, etc for valid geometries\nLine and polygon simplification (simplify)\nPolygon clipping, intersection, difference and union\nGeneralized barycentric coordinates in polygons (barycentric_coordinates)\nProjection of geometries between coordinate reference systems using Proj.jl\nPolygonization of raster images by contour detection (polygonize)","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the \"API\" page in the docs for a more complete list!","category":"page"},{"location":"#Planned-additions","page":"Home","title":"Planned additions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Arclength interpolation (absolute and relative)\nBuffering, hulls \nSome kind of applyreduce primitive (#38)\nChecks for valid geometries (empty linestrings, null points, etc) (#14)\nOperations on spherical (non-Euclidean) geometry (#17)","category":"page"}]
}
