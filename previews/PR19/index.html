<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · GeometryOps.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://asinghvi17.github.io/GeometryOps.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href><img src="assets/logo.png" alt="GeometryOps.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href>GeometryOps.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li><li><span class="tocitem">Source code</span><ul><li><a class="tocitem" href="source/GeometryOps/">GeometryOps.jl</a></li><li><a class="tocitem" href="source/primitives/">Primitive functions</a></li><li><a class="tocitem" href="source/utils/">Utility functions</a></li><li><a class="tocitem" href="source/methods/barycentric/">Barycentric coordinates</a></li><li><a class="tocitem" href="source/methods/bools/">Boolean conditions</a></li><li><a class="tocitem" href="source/methods/centroid/">Centroid</a></li><li><a class="tocitem" href="source/methods/contains/">Containment</a></li><li><a class="tocitem" href="source/methods/crosses/">Crossing checks</a></li><li><a class="tocitem" href="source/methods/disjoint/">Disjointness checks</a></li><li><a class="tocitem" href="source/methods/intersects/">Intersection checks</a></li><li><a class="tocitem" href="source/methods/overlaps/">Overlap checks</a></li><li><a class="tocitem" href="source/methods/polygonize/">Polygonizing raster data</a></li><li><a class="tocitem" href="source/methods/signed_area/">Signed area</a></li><li><a class="tocitem" href="source/methods/signed_distance/">Signed distance</a></li><li><a class="tocitem" href="source/methods/within/">Containment/withinness</a></li><li><a class="tocitem" href="source/transformations/extent/">-</a></li><li><a class="tocitem" href="source/transformations/flip/">Coordinate flipping</a></li><li><a class="tocitem" href="source/transformations/reproject/">Geometry reprojection</a></li><li><a class="tocitem" href="source/transformations/simplify/">Geometry simplification</a></li><li><a class="tocitem" href="source/transformations/tuples/">Tuple conversion</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/asinghvi17/GeometryOps.jl/blob/main/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="GeometryOps"><a class="docs-heading-anchor" href="#GeometryOps">GeometryOps</a><a id="GeometryOps-1"></a><a class="docs-heading-anchor-permalink" href="#GeometryOps" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/asinghvi17/GeometryOps.jl">GeometryOps</a>.</p><ul><li><a href="#GeometryOps.AbstractBarycentricCoordinateMethod"><code>GeometryOps.AbstractBarycentricCoordinateMethod</code></a></li><li><a href="#GeometryOps.DouglasPeucker"><code>GeometryOps.DouglasPeucker</code></a></li><li><a href="#GeometryOps.MeanValue"><code>GeometryOps.MeanValue</code></a></li><li><a href="#GeometryOps.RadialDistance"><code>GeometryOps.RadialDistance</code></a></li><li><a href="#GeometryOps.SimplifyAlg"><code>GeometryOps.SimplifyAlg</code></a></li><li><a href="#GeometryOps.VisvalingamWhyatt"><code>GeometryOps.VisvalingamWhyatt</code></a></li><li><a href="#GeometryOps._det-Union{Tuple{T2}, Tuple{T1}, Tuple{Union{Tuple{T1, T1}, StaticArraysCore.StaticArray{Tuple{2}, T1, 1}}, Union{Tuple{T2, T2}, StaticArraysCore.StaticArray{Tuple{2}, T2, 1}}}} where {T1&lt;:Real, T2&lt;:Real}"><code>GeometryOps._det</code></a></li><li><a href="#GeometryOps._distance-Tuple{Any, Any, Any}"><code>GeometryOps._distance</code></a></li><li><a href="#GeometryOps.apply-Union{Tuple{Target}, Tuple{Any, Type{Target}, Any}} where Target"><code>GeometryOps.apply</code></a></li><li><a href="#GeometryOps.centroid-Tuple{Any}"><code>GeometryOps.centroid</code></a></li><li><a href="#GeometryOps.centroid-Tuple{Any, Any}"><code>GeometryOps.centroid</code></a></li><li><a href="#GeometryOps.centroid-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.LinearRingTrait}, Any}"><code>GeometryOps.centroid</code></a></li><li><a href="#GeometryOps.centroid_and_area-Tuple{Any}"><code>GeometryOps.centroid_and_area</code></a></li><li><a href="#GeometryOps.centroid_and_area-Tuple{GeoInterface.PolygonTrait, Any}"><code>GeometryOps.centroid_and_area</code></a></li><li><a href="#GeometryOps.centroid_and_area-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.LinearRingTrait}, Any}"><code>GeometryOps.centroid_and_area</code></a></li><li><a href="#GeometryOps.centroid_and_area-Tuple{GeoInterface.MultiPolygonTrait, Any}"><code>GeometryOps.centroid_and_area</code></a></li><li><a href="#GeometryOps.centroid_and_length-Tuple{Any}"><code>GeometryOps.centroid_and_length</code></a></li><li><a href="#GeometryOps.centroid_and_length-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.LinearRingTrait}, Any}"><code>GeometryOps.centroid_and_length</code></a></li><li><a href="#GeometryOps.contains-Tuple{Any, Any}"><code>GeometryOps.contains</code></a></li><li><a href="#GeometryOps.crosses-Tuple{Any, Any}"><code>GeometryOps.crosses</code></a></li><li><a href="#GeometryOps.disjoint-Tuple{Any, Any}"><code>GeometryOps.disjoint</code></a></li><li><a href="#GeometryOps.flatten-Union{Tuple{Target}, Tuple{Type{Target}, Any}} where Target&lt;:GeoInterface.AbstractTrait"><code>GeometryOps.flatten</code></a></li><li><a href="#GeometryOps.flip-Tuple{Any}"><code>GeometryOps.flip</code></a></li><li><a href="#GeometryOps.get_contours-Tuple{AbstractMatrix}"><code>GeometryOps.get_contours</code></a></li><li><a href="#GeometryOps.isclockwise-Tuple{Any}"><code>GeometryOps.isclockwise</code></a></li><li><a href="#GeometryOps.isconcave-Tuple{Any}"><code>GeometryOps.isconcave</code></a></li><li><a href="#GeometryOps.line_intersection-Tuple{Any, Any}"><code>GeometryOps.line_intersection</code></a></li><li><a href="#GeometryOps.line_intersects-Tuple{Any, Any}"><code>GeometryOps.line_intersects</code></a></li><li><a href="#GeometryOps.overlaps-Tuple{Any, Any}"><code>GeometryOps.overlaps</code></a></li><li><a href="#GeometryOps.point_in_polygon-Tuple{Any, Any}"><code>GeometryOps.point_in_polygon</code></a></li><li><a href="#GeometryOps.point_on_line-Tuple{Any, Any}"><code>GeometryOps.point_on_line</code></a></li><li><a href="#GeometryOps.polygon_to_line-Tuple{Any}"><code>GeometryOps.polygon_to_line</code></a></li><li><a href="#GeometryOps.polygonize-Tuple{AbstractMatrix}"><code>GeometryOps.polygonize</code></a></li><li><a href="#GeometryOps.rebuild-Tuple{Any, Any}"><code>GeometryOps.rebuild</code></a></li><li><a href="#GeometryOps.reconstruct-Tuple{Any, Any}"><code>GeometryOps.reconstruct</code></a></li><li><a href="#GeometryOps.reproject-Tuple{Any}"><code>GeometryOps.reproject</code></a></li><li><a href="#GeometryOps.signed_area-Tuple{Any}"><code>GeometryOps.signed_area</code></a></li><li><a href="#GeometryOps.signed_distance-Tuple{Any, Any, Any}"><code>GeometryOps.signed_distance</code></a></li><li><a href="#GeometryOps.simplify-Tuple{Any}"><code>GeometryOps.simplify</code></a></li><li><a href="#GeometryOps.t_value-Union{Tuple{T2}, Tuple{T1}, Tuple{N}, Tuple{Union{Tuple{Vararg{T1, N}}, StaticArraysCore.StaticArray{Tuple{N}, T1, 1}}, Union{Tuple{Vararg{T1, N}}, StaticArraysCore.StaticArray{Tuple{N}, T1, 1}}, T2, T2}} where {N, T1&lt;:Real, T2&lt;:Real}"><code>GeometryOps.t_value</code></a></li><li><a href="#GeometryOps.to_edges-Tuple{Any}"><code>GeometryOps.to_edges</code></a></li><li><a href="#GeometryOps.tuples-Tuple{Any}"><code>GeometryOps.tuples</code></a></li><li><a href="#GeometryOps.unwrap"><code>GeometryOps.unwrap</code></a></li><li><a href="#GeometryOps.weighted_mean-Union{Tuple{WT}, Tuple{WT, Any, Any}} where WT&lt;:Real"><code>GeometryOps.weighted_mean</code></a></li><li><a href="#GeometryOps.within-Tuple{Any, Any}"><code>GeometryOps.within</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.AbstractBarycentricCoordinateMethod" href="#GeometryOps.AbstractBarycentricCoordinateMethod"><code>GeometryOps.AbstractBarycentricCoordinateMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractBarycentricCoordinateMethod</code></pre><p>Abstract supertype for barycentric coordinate methods.   The subtypes may serve as dispatch types, or may cache  some information about the target polygon.  </p><p><strong>API</strong></p><p>The following methods must be implemented for all subtypes:</p><ul><li><code>barycentric_coordinates!(λs::Vector{&lt;: Real}, method::AbstractBarycentricCoordinateMethod, exterior::Vector{&lt;: Point{2, T1}}, point::Point{2, T2})</code></li><li><code>barycentric_interpolate(method::AbstractBarycentricCoordinateMethod, exterior::Vector{&lt;: Point{2, T1}}, values::Vector{V}, point::Point{2, T2})::V</code></li><li><code>barycentric_interpolate(method::AbstractBarycentricCoordinateMethod, exterior::Vector{&lt;: Point{2, T1}}, interiors::Vector{&lt;: Vector{&lt;: Point{2, T1}}} values::Vector{V}, point::Point{2, T2})::V</code></li></ul><p>The rest of the methods will be implemented in terms of these, and have efficient dispatches for broadcasting.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/6757cf1d58de64ece71fcab146468d17532be719/src/methods/barycentric.jl#L112-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.DouglasPeucker" href="#GeometryOps.DouglasPeucker"><code>GeometryOps.DouglasPeucker</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DouglasPeucker &lt;: SimplifyAlg

DouglasPeucker(; number, ratio, tol)</code></pre><p>Simplifies geometries by removing points below <code>tol</code> distance from the line between its neighboring points.</p><p><strong>Keywords</strong></p><ul><li><p><code>ratio</code>: the fraction of points that should remain after <code>simplify</code>.    Useful as it will generalise for large collections of objects.</p></li><li><p><code>number</code>: the number of points that should remain after <code>simplify</code>.   Less useful for large collections of mixed size objects.</p></li><li><p><code>tol</code>: the minimum distance a point will be from the line   joining its neighboring points.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/6757cf1d58de64ece71fcab146468d17532be719/src/transformations/simplify.jl#L176-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.MeanValue" href="#GeometryOps.MeanValue"><code>GeometryOps.MeanValue</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MeanValue() &lt;: AbstractBarycentricCoordinateMethod</code></pre><p>This method calculates barycentric coordinates using the mean value method.</p><p><strong>References</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/6757cf1d58de64ece71fcab146468d17532be719/src/methods/barycentric.jl#L218-L225">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.RadialDistance" href="#GeometryOps.RadialDistance"><code>GeometryOps.RadialDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RadialDistance &lt;: SimplifyAlg</code></pre><p>Simplifies geometries by removing points less than <code>tol</code> distance from the line between its neighboring points.</p><p><strong>Keywords</strong></p><ul><li><p><code>ratio</code>: the fraction of points that should remain after <code>simplify</code>.    Useful as it will generalise for large collections of objects.</p></li><li><p><code>number</code>: the number of points that should remain after <code>simplify</code>.   Less useful for large collections of mixed size objects.</p></li><li><p><code>tol</code>: the minimum distance between points.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/6757cf1d58de64ece71fcab146468d17532be719/src/transformations/simplify.jl#L132-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.SimplifyAlg" href="#GeometryOps.SimplifyAlg"><code>GeometryOps.SimplifyAlg</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type SimplifyAlg</code></pre><p>Abstract type for simplification algorithms.</p><p><strong>API</strong></p><p>For now, the algorithm must hold the <code>number</code>, <code>ratio</code> and <code>tol</code> properties.  </p><p>Simplification algorithm types can hook into the interface by implementing  the <code>_simplify(trait, alg, geom)</code> methods for whichever traits are necessary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/6757cf1d58de64ece71fcab146468d17532be719/src/transformations/simplify.jl#L9-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.VisvalingamWhyatt" href="#GeometryOps.VisvalingamWhyatt"><code>GeometryOps.VisvalingamWhyatt</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VisvalingamWhyatt &lt;: SimplifyAlg

VisvalingamWhyatt(; kw...)</code></pre><p>Simplifies geometries by removing points below <code>tol</code> distance from the line between its neighboring points.</p><p><strong>Keywords</strong></p><ul><li><p><code>ratio</code>: the fraction of points that should remain after <code>simplify</code>.    Useful as it will generalise for large collections of objects.</p></li><li><p><code>number</code>: the number of points that should remain after <code>simplify</code>.   Less useful for large collections of mixed size objects.</p></li><li><p><code>tol</code>: the minimum area of a triangle made with a point and   its neighboring points.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/6757cf1d58de64ece71fcab146468d17532be719/src/transformations/simplify.jl#L233-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps._det-Union{Tuple{T2}, Tuple{T1}, Tuple{Union{Tuple{T1, T1}, StaticArraysCore.StaticArray{Tuple{2}, T1, 1}}, Union{Tuple{T2, T2}, StaticArraysCore.StaticArray{Tuple{2}, T2, 1}}}} where {T1&lt;:Real, T2&lt;:Real}" href="#GeometryOps._det-Union{Tuple{T2}, Tuple{T1}, Tuple{Union{Tuple{T1, T1}, StaticArraysCore.StaticArray{Tuple{2}, T1, 1}}, Union{Tuple{T2, T2}, StaticArraysCore.StaticArray{Tuple{2}, T2, 1}}}} where {T1&lt;:Real, T2&lt;:Real}"><code>GeometryOps._det</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_det(s1::Point2{T1}, s2::Point2{T2}) where {T1 &lt;: Real, T2 &lt;: Real}</code></pre><p>Returns the determinant of the matrix formed by <code>hcat</code>&#39;ing two points <code>s1</code> and <code>s2</code>.</p><p>Specifically, this is: </p><pre><code class="language-julia hljs">s1[1] * s2[2] - s1[2] * s2[1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/6757cf1d58de64ece71fcab146468d17532be719/src/methods/barycentric.jl#L232-L241">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps._distance-Tuple{Any, Any, Any}" href="#GeometryOps._distance-Tuple{Any, Any, Any}"><code>GeometryOps._distance</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Distance from p0 to the line segment formed by p1 and p2.  Implementation from Turf.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/6757cf1d58de64ece71fcab146468d17532be719/src/methods/signed_distance.jl#L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.apply-Union{Tuple{Target}, Tuple{Any, Type{Target}, Any}} where Target" href="#GeometryOps.apply-Union{Tuple{Target}, Tuple{Any, Type{Target}, Any}} where Target"><code>GeometryOps.apply</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">apply(f, target::Type{&lt;:AbstractTrait}, obj; crs)</code></pre><p>Reconstruct a geometry or feature using the function <code>f</code> on the <code>target</code> trait.</p><p><code>f(target_geom) =&gt; x</code> where <code>x</code> also has the <code>target</code> trait, or an equivalent.</p><p>The result is an functionally similar geometry with values depending on <code>f</code></p><p><strong>Flipped point the order in any feature or geometry, or iterables of either:</strong></p><p>```juia import GeoInterface as GI import GeometryOps as GO geom = GI.Polygon([GI.LinearRing([(1, 2), (3, 4), (5, 6), (1, 2)]),                     GI.LinearRing([(3, 4), (5, 6), (6, 7), (3, 4)])])</p><p>flipped_geom = GO.apply(GI.PointTrait, geom) do p     (GI.y(p), GI.x(p)) end</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/6757cf1d58de64ece71fcab146468d17532be719/src/primitives.jl#L5-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.centroid-Tuple{Any, Any}" href="#GeometryOps.centroid-Tuple{Any, Any}"><code>GeometryOps.centroid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">centroid(trait, geom)::Tuple{T, T}</code></pre><p>Returns the centroid of a polygon or multipolygon, which is calculated by weighting edges by their <code>area component</code> by convention.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/6757cf1d58de64ece71fcab146468d17532be719/src/methods/centroid.jl#L76-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.centroid-Tuple{Any}" href="#GeometryOps.centroid-Tuple{Any}"><code>GeometryOps.centroid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">centroid(geom)::Tuple{T, T}</code></pre><p>Returns the centroid of a given line segment, linear ring, polygon, or mutlipolygon.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/6757cf1d58de64ece71fcab146468d17532be719/src/methods/centroid.jl#L54-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.centroid-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.LinearRingTrait}, Any}" href="#GeometryOps.centroid-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.LinearRingTrait}, Any}"><code>GeometryOps.centroid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">centroid(
    trait::Union{GI.LineStringTrait, GI.LinearRingTrait},
    geom,
)::Tuple{T, T}</code></pre><p>Returns the centroid of a line string or linear ring, which is calculated by weighting line segments by their length by convention.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/6757cf1d58de64ece71fcab146468d17532be719/src/methods/centroid.jl#L62-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.centroid_and_area-Tuple{Any}" href="#GeometryOps.centroid_and_area-Tuple{Any}"><code>GeometryOps.centroid_and_area</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">centroid_and_area(
    ::Union{GI.LineStringTrait, GI.LinearRingTrait}, 
    geom,
)::(::Tuple{T, T}, ::Real)</code></pre><p>Returns the centroid and area of a given geom.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/6757cf1d58de64ece71fcab146468d17532be719/src/methods/centroid.jl#L92-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.centroid_and_area-Tuple{GeoInterface.MultiPolygonTrait, Any}" href="#GeometryOps.centroid_and_area-Tuple{GeoInterface.MultiPolygonTrait, Any}"><code>GeometryOps.centroid_and_area</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">centroid_and_area(::GI.MultiPolygonTrait, geom)::(::Tuple{T, T}, ::Real)</code></pre><p>Returns the centroid and area of a given multipolygon.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/6757cf1d58de64ece71fcab146468d17532be719/src/methods/centroid.jl#L207-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.centroid_and_area-Tuple{GeoInterface.PolygonTrait, Any}" href="#GeometryOps.centroid_and_area-Tuple{GeoInterface.PolygonTrait, Any}"><code>GeometryOps.centroid_and_area</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">centroid_and_area(::GI.PolygonTrait, geom)::(::Tuple{T, T}, ::Real)</code></pre><p>Returns the centroid and area of a given polygon.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/6757cf1d58de64ece71fcab146468d17532be719/src/methods/centroid.jl#L181-L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.centroid_and_area-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.LinearRingTrait}, Any}" href="#GeometryOps.centroid_and_area-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.LinearRingTrait}, Any}"><code>GeometryOps.centroid_and_area</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">centroid_and_area(
    ::Union{GI.LineStringTrait, GI.LinearRingTrait},
    geom,
)::(::Tuple{T, T}, ::Real)</code></pre><p>Returns the centroid and area of a given a line string or a linear ring. Note that this is only valid if the line segment or linear ring is closed. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/6757cf1d58de64ece71fcab146468d17532be719/src/methods/centroid.jl#L139-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.centroid_and_length-Tuple{Any}" href="#GeometryOps.centroid_and_length-Tuple{Any}"><code>GeometryOps.centroid_and_length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">centroid_and_length(geom)::(::Tuple{T, T}, ::Real)</code></pre><p>Returns the centroid and length of a given line/ring. Note this is only valid for line strings and linear rings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/6757cf1d58de64ece71fcab146468d17532be719/src/methods/centroid.jl#L84-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.centroid_and_length-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.LinearRingTrait}, Any}" href="#GeometryOps.centroid_and_length-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.LinearRingTrait}, Any}"><code>GeometryOps.centroid_and_length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">centroid_and_length(geom)::(::Tuple{T, T}, ::Real)</code></pre><p>Returns the centroid and length of a given line/ring. Note this is only valid for line strings and linear rings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/6757cf1d58de64ece71fcab146468d17532be719/src/methods/centroid.jl#L102-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.contains-Tuple{Any, Any}" href="#GeometryOps.contains-Tuple{Any, Any}"><code>GeometryOps.contains</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">contains(ft1::AbstractGeometry, ft2::AbstractGeometry)::Bool</code></pre><p>Return true if the second geometry is completely contained by the first geometry. The interiors of both geometries must intersect and, the interior and boundary of the secondary (geometry b) must not intersect the exterior of the primary (geometry a). <code>contains</code> returns the exact opposite result of <code>within</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">import GeometryOps as GO, GeoInterface as GI
line = GI.LineString([(1, 1), (1, 2), (1, 3), (1, 4)])
point = (1, 2)

GO.contains(line, point)
# output
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/6757cf1d58de64ece71fcab146468d17532be719/src/methods/contains.jl#L5-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.crosses-Tuple{Any, Any}" href="#GeometryOps.crosses-Tuple{Any, Any}"><code>GeometryOps.crosses</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs"> crosses(geom1, geom2)::Bool</code></pre><p>Return <code>true</code> if the intersection results in a geometry whose dimension is one less than the maximum dimension of the two source geometries and the intersection set is interior to both source geometries.</p><p>TODO: broken</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">import GeoInterface as GI, GeometryOps as GO

line1 = GI.LineString([(1, 1), (1, 2), (1, 3), (1, 4)])
line2 = GI.LineString([(-2, 2), (4, 2)])

GO.crosses(line1, line2)
# output
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/6757cf1d58de64ece71fcab146468d17532be719/src/methods/crosses.jl#L3-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.disjoint-Tuple{Any, Any}" href="#GeometryOps.disjoint-Tuple{Any, Any}"><code>GeometryOps.disjoint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">disjoint(geom1, geom2)::Bool</code></pre><p>Return <code>true</code> if the intersection of the two geometries is an empty set.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">import GeometryOps as GO, GeoInterface as GI

poly = GI.Polygon([[(-1, 2), (3, 2), (3, 3), (-1, 3), (-1, 2)]])
point = (1, 1)
GO.disjoint(poly, point)

# output
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/6757cf1d58de64ece71fcab146468d17532be719/src/methods/disjoint.jl#L3-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.flatten-Union{Tuple{Target}, Tuple{Type{Target}, Any}} where Target&lt;:GeoInterface.AbstractTrait" href="#GeometryOps.flatten-Union{Tuple{Target}, Tuple{Type{Target}, Any}} where Target&lt;:GeoInterface.AbstractTrait"><code>GeometryOps.flatten</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flatten(target::Type{&lt;:GI.AbstractTrait}, geom)</code></pre><p>Lazily flatten any geometry, feature or iterator of geometries or features so that objects with the specified trait are returned by the iterator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/6757cf1d58de64ece71fcab146468d17532be719/src/primitives.jl#L115-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.flip-Tuple{Any}" href="#GeometryOps.flip-Tuple{Any}"><code>GeometryOps.flip</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flip(obj)</code></pre><p>Swap all of the x and y coordinates in obj, otherwise keeping the original structure (but not necessarily the original type).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/6757cf1d58de64ece71fcab146468d17532be719/src/transformations/flip.jl#L6-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.get_contours-Tuple{AbstractMatrix}" href="#GeometryOps.get_contours-Tuple{AbstractMatrix}"><code>GeometryOps.get_contours</code></a> — <span class="docstring-category">Method</span></header><section><div><p>get_contours(A::AbstractMatrix)</p><p>Returns contours as vectors of <code>CartesianIndex</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/6757cf1d58de64ece71fcab146468d17532be719/src/methods/polygonize.jl#L158-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.isclockwise-Tuple{Any}" href="#GeometryOps.isclockwise-Tuple{Any}"><code>GeometryOps.isclockwise</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isclockwise(line::Union{LineString, Vector{Position}})::Bool</code></pre><p>Take a ring and return true or false whether or not the ring is clockwise or counter-clockwise.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">import GeoInterface as GI, GeometryOps as GO

ring = GI.LinearRing([(0, 0), (1, 1), (1, 0), (0, 0)])
GO.isclockwise(ring)

# output
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/6757cf1d58de64ece71fcab146468d17532be719/src/methods/bools.jl#L11-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.isconcave-Tuple{Any}" href="#GeometryOps.isconcave-Tuple{Any}"><code>GeometryOps.isconcave</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isconcave(poly::Polygon)::Bool</code></pre><p>Take a polygon and return true or false as to whether it is concave or not.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">import GeoInterface as GI, GeometryOps as GO

poly = GI.Polygon([[(0, 0), (0, 1), (1, 1), (1, 0), (0, 0)]])
GO.isconcave(poly)

# output
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/6757cf1d58de64ece71fcab146468d17532be719/src/methods/bools.jl#L41-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.line_intersection-Tuple{Any, Any}" href="#GeometryOps.line_intersection-Tuple{Any, Any}"><code>GeometryOps.line_intersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">line_intersection(line_a, line_b)</code></pre><p>Find a point that intersects LineStrings with two coordinates each.</p><p>Returns <code>nothing</code> if no point is found.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">import GeoInterface as GI, GeometryOps as GO

line1 = GI.Line([(124.584961,-12.768946), (126.738281,-17.224758)])
line2 = GI.Line([(123.354492,-15.961329), (127.22168,-14.008696)])
GO.line_intersection(line1, line2)

# output
(125.58375366067547, -14.83572303404496)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/6757cf1d58de64ece71fcab146468d17532be719/src/methods/intersects.jl#L56-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.line_intersects-Tuple{Any, Any}" href="#GeometryOps.line_intersects-Tuple{Any, Any}"><code>GeometryOps.line_intersects</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">line_intersects(line_a, line_b)</code></pre><p>Check if <code>line_a</code> intersects with <code>line_b</code>.</p><p>These can be <code>LineTrait</code>, <code>LineStringTrait</code> or <code>LinearRingTrait</code></p><p><strong>Example</strong></p><pre><code class="language-julia hljs">import GeoInterface as GI, GeometryOps as GO

line1 = GI.Line([(124.584961,-12.768946), (126.738281,-17.224758)])
line2 = GI.Line([(123.354492,-15.961329), (127.22168,-14.008696)])
GO.line_intersects(line1, line2)

# output
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/6757cf1d58de64ece71fcab146468d17532be719/src/methods/intersects.jl#L13-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.overlaps-Tuple{Any, Any}" href="#GeometryOps.overlaps-Tuple{Any, Any}"><code>GeometryOps.overlaps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">overlaps(geom1, geom2)::Bool</code></pre><p>Compare two Geometries of the same dimension and return true if their intersection set results in a geometry different from both but of the same dimension. It applies to Polygon/Polygon, LineString/LineString, Multipoint/Multipoint, MultiLineString/MultiLineString and MultiPolygon/MultiPolygon.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">import GeometryOps as GO, GeoInterface as GI
poly1 = GI.Polygon([[(0,0), (0,5), (5,5), (5,0), (0,0)]])
poly2 = GI.Polygon([[(1,1), (1,6), (6,6), (6,1), (1,1)]])

GO.overlaps(poly1, poly2)
# output
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/6757cf1d58de64ece71fcab146468d17532be719/src/methods/overlaps.jl#L9-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.point_in_polygon-Tuple{Any, Any}" href="#GeometryOps.point_in_polygon-Tuple{Any, Any}"><code>GeometryOps.point_in_polygon</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">point_in_polygon(point::Point, polygon::Union{Polygon, MultiPolygon}, ignore_boundary::Bool=false)::Bool</code></pre><p>Take a Point and a Polygon and determine if the point resides inside the polygon. The polygon can be convex or concave. The function accounts for holes.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">import GeoInterface as GI, GeometryOps as GO

point = (-77.0, 44.0)
poly = GI.Polygon([[(-81, 41), (-81, 47), (-72, 47), (-72, 41), (-81, 41)]])
GO.point_in_polygon(point, poly)

# output
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/6757cf1d58de64ece71fcab146468d17532be719/src/methods/bools.jl#L235-L253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.point_on_line-Tuple{Any, Any}" href="#GeometryOps.point_on_line-Tuple{Any, Any}"><code>GeometryOps.point_on_line</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">point_on_line(point::Point, line::LineString; ignore_end_vertices::Bool=false)::Bool</code></pre><p>Return true if a point is on a line. Accept a optional parameter to ignore the start and end vertices of the linestring.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">import GeoInterface as GI, GeometryOps as GO

point = (1, 1)
line = GI.LineString([(0, 0), (3, 3), (4, 4)])
GO.point_on_line(point, line)

# output
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/6757cf1d58de64ece71fcab146468d17532be719/src/methods/bools.jl#L155-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.polygon_to_line-Tuple{Any}" href="#GeometryOps.polygon_to_line-Tuple{Any}"><code>GeometryOps.polygon_to_line</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">polygon_to_line(poly::Polygon)</code></pre><p>Converts a Polygon to LineString or MultiLineString</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">import GeometryOps as GO, GeoInterface as GI

poly = GI.Polygon([[(-2.275543, 53.464547), (-2.275543, 53.489271), (-2.215118, 53.489271), (-2.215118, 53.464547), (-2.275543, 53.464547)]])
GO.polygon_to_line(poly)
# output
GeoInterface.Wrappers.LineString{false, false, Vector{Tuple{Float64, Float64}}, Nothing, Nothing}([(-2.275543, 53.464547), (-2.275543, 53.489271), (-2.215118, 53.489271), (-2.215118, 53.464547), (-2.275543, 53.464547)], nothing, nothing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/6757cf1d58de64ece71fcab146468d17532be719/src/utils.jl#L30-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.polygonize-Tuple{AbstractMatrix}" href="#GeometryOps.polygonize-Tuple{AbstractMatrix}"><code>GeometryOps.polygonize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">polygonize(A; minpoints=10)
polygonize(xs, ys, A; minpoints=10)</code></pre><p>Convert matrix <code>A</code> to polygons.</p><p>If <code>xs</code> and <code>ys</code> are passed in they are used as the pixel center points.</p><p><strong>Keywords</strong></p><ul><li><code>minpoints</code>: ignore polygons with less than <code>minpoints</code> points. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/6757cf1d58de64ece71fcab146468d17532be719/src/methods/polygonize.jl#L54-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.rebuild-Tuple{Any, Any}" href="#GeometryOps.rebuild-Tuple{Any, Any}"><code>GeometryOps.rebuild</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rebuild(geom, child_geoms)</code></pre><p>Rebuild a geometry from child geometries.</p><p>By default geometries will be rebuilt as a GeoInterface.Wrappers  geometry, but <code>rebuild</code> can have methods added to it to dispatch on geometries from other packages and specify how to rebuild them.</p><p>(Maybe it should go into GeoInterface.jl)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/6757cf1d58de64ece71fcab146468d17532be719/src/primitives.jl#L206-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.reconstruct-Tuple{Any, Any}" href="#GeometryOps.reconstruct-Tuple{Any, Any}"><code>GeometryOps.reconstruct</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reconstruct(geom, components)</code></pre><p>Reconstruct <code>geom</code> from an iterable of component objects that match its structure.</p><p>All objects in <code>components</code> must have the same <code>GeoInterface.trait</code>.</p><p>Ususally used in combination with <code>flatten</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/6757cf1d58de64ece71fcab146468d17532be719/src/primitives.jl#L149-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.reproject-Tuple{Any}" href="#GeometryOps.reproject-Tuple{Any}"><code>GeometryOps.reproject</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reproject(geometry; source_crs, target_crs, transform, always_xy, time)
reproject(geometry, source_crs, target_crs; always_xy, time)
reproject(geometry, transform; always_xy, time)</code></pre><p>Reproject any GeoInterface.jl compatible <code>geometry</code> from <code>source_crs</code> to <code>target_crs</code>.</p><p>The returned object will be constructed from <code>GeoInterface.WrapperGeometry</code> geometries, wrapping views of a <code>Vector{Proj.Point{D}}</code>, where <code>D</code> is the dimension.</p><p><strong>Arguments</strong></p><ul><li><code>geometry</code>: Any GeoInterface.jl compatible geometries.</li><li><code>source_crs</code>: the source coordinate referece system, as a GeoFormatTypes.jl object or a string.</li><li><code>target_crs</code>: the target coordinate referece system, as a GeoFormatTypes.jl object or a string.</li></ul><p>If these a passed as keywords, <code>transform</code> will take priority. Without it <code>target_crs</code> is always needed, and <code>source_crs</code> is needed if it is not retreivable from the geometry with <code>GeoInterface.crs(geometry)</code>.</p><p><strong>Keywords</strong></p><p>-<code>always_xy</code>: force x, y coordinate order, <code>true</code> by default.     <code>false</code> will expect and return points in the crs coordinate order. -<code>time</code>: the time for the coordinates. <code>Inf</code> by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/6757cf1d58de64ece71fcab146468d17532be719/src/transformations/reproject.jl#L11-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.signed_area-Tuple{Any}" href="#GeometryOps.signed_area-Tuple{Any}"><code>GeometryOps.signed_area</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">signed_area(geom)::Real</code></pre><p>Returns the signed area of the geometry, based on winding order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/6757cf1d58de64ece71fcab146468d17532be719/src/methods/signed_area.jl#L38-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.signed_distance-Tuple{Any, Any, Any}" href="#GeometryOps.signed_distance-Tuple{Any, Any, Any}"><code>GeometryOps.signed_distance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">signed_distance(geom, x::Real, y::Real)::Float64</code></pre><p>Calculates the signed distance from the geometry <code>geom</code> to the point defined by <code>(x, y)</code>.  Points within <code>geom</code> have a negative distance, and points outside of <code>geom</code> have a positive distance.</p><p>If <code>geom</code> is a MultiPolygon, then this function returns the maximum distance  to any of the polygons in <code>geom</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/6757cf1d58de64ece71fcab146468d17532be719/src/methods/signed_distance.jl#L91-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.simplify-Tuple{Any}" href="#GeometryOps.simplify-Tuple{Any}"><code>GeometryOps.simplify</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">simplify(obj; kw...)
simplify(::SimplifyAlg, obj)</code></pre><p>Simplify a geometry, feature, feature collection,  or nested vectors or a table of these.</p><p><a href="#GeometryOps.RadialDistance"><code>RadialDistance</code></a>, <a href="#GeometryOps.DouglasPeucker"><code>DouglasPeucker</code></a>, or  <a href="#GeometryOps.VisvalingamWhyatt"><code>VisvalingamWhyatt</code></a> algorithms are available,  listed in order of increasing quality but decreaseing performance.</p><p><code>PoinTrait</code> and <code>MultiPointTrait</code> are returned unchanged.</p><p>The default behaviour is <code>simplify(DouglasPeucker(; kw...), obj)</code>. Pass in other <a href="#GeometryOps.SimplifyAlg"><code>SimplifyAlg</code></a> to use other algorithms.</p><p><strong>Example</strong></p><p>Simplify a polygon to have six points:</p><pre><code class="language-julia hljs">import GeoInterface as GI
import GeometryOps as GO

poly = GI.Polygon([[
    [-70.603637, -33.399918],
    [-70.614624, -33.395332],
    [-70.639343, -33.392466],
    [-70.659942, -33.394759],
    [-70.683975, -33.404504],
    [-70.697021, -33.419406],
    [-70.701141, -33.434306],
    [-70.700454, -33.446339],
    [-70.694274, -33.458369],
    [-70.682601, -33.465816],
    [-70.668869, -33.472117],
    [-70.646209, -33.473835],
    [-70.624923, -33.472117],
    [-70.609817, -33.468107],
    [-70.595397, -33.458369],
    [-70.587158, -33.442901],
    [-70.587158, -33.426283],
    [-70.590591, -33.414248],
    [-70.594711, -33.406224],
    [-70.603637, -33.399918]]])

simple = GO.simplify(poly; number=6)
GI.npoint(simple)

# output
6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/6757cf1d58de64ece71fcab146468d17532be719/src/transformations/simplify.jl#L49-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.t_value-Union{Tuple{T2}, Tuple{T1}, Tuple{N}, Tuple{Union{Tuple{Vararg{T1, N}}, StaticArraysCore.StaticArray{Tuple{N}, T1, 1}}, Union{Tuple{Vararg{T1, N}}, StaticArraysCore.StaticArray{Tuple{N}, T1, 1}}, T2, T2}} where {N, T1&lt;:Real, T2&lt;:Real}" href="#GeometryOps.t_value-Union{Tuple{T2}, Tuple{T1}, Tuple{N}, Tuple{Union{Tuple{Vararg{T1, N}}, StaticArraysCore.StaticArray{Tuple{N}, T1, 1}}, Union{Tuple{Vararg{T1, N}}, StaticArraysCore.StaticArray{Tuple{N}, T1, 1}}, T2, T2}} where {N, T1&lt;:Real, T2&lt;:Real}"><code>GeometryOps.t_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">t_value(sᵢ, sᵢ₊₁, rᵢ, rᵢ₊₁)</code></pre><p>Returns the &quot;T-value&quot; as described in Hormann&#39;s presentation <sup class="footnote-reference"><a id="citeref-HormannPresentation" href="#footnote-HormannPresentation">[HormannPresentation]</a></sup> on how to calculate the mean-value coordinate.  </p><p>Here, <code>sᵢ</code> is the vector from vertex <code>vᵢ</code> to the point, and <code>rᵢ</code> is the norm (length) of <code>sᵢ</code>. <code>s</code> must be <code>Point</code> and <code>r</code> must be real numbers.</p><p class="math-container">\[tᵢ = \frac{\mathrm{det}\left(sᵢ, sᵢ₊₁\right)}{rᵢ * rᵢ₊₁ + sᵢ ⋅ sᵢ₊₁}\]</p><p>```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/6757cf1d58de64ece71fcab146468d17532be719/src/methods/barycentric.jl#L246-L262">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.to_edges-Tuple{Any}" href="#GeometryOps.to_edges-Tuple{Any}"><code>GeometryOps.to_edges</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to_edges()</code></pre><p>Convert any geometry or collection of geometries into a flat  vector of <code>Tuple{Tuple{Float64,Float64},{Float64,Float64}}</code> edges.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/6757cf1d58de64ece71fcab146468d17532be719/src/utils.jl#L53-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.tuples-Tuple{Any}" href="#GeometryOps.tuples-Tuple{Any}"><code>GeometryOps.tuples</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tuples(obj)</code></pre><p>Convert all points on obj to <code>Tuple</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/6757cf1d58de64ece71fcab146468d17532be719/src/transformations/tuples.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.unwrap" href="#GeometryOps.unwrap"><code>GeometryOps.unwrap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unwrap(target::Type{&lt;:AbstractTrait}, obj)
unwrap(f, target::Type{&lt;:AbstractTrait}, obj)</code></pre><p>Unwrap the geometry to vectors, down to the target trait.</p><p>If <code>f</code> is passed in it will be applied to the target geometries as they are found.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/6757cf1d58de64ece71fcab146468d17532be719/src/primitives.jl#L84-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.weighted_mean-Union{Tuple{WT}, Tuple{WT, Any, Any}} where WT&lt;:Real" href="#GeometryOps.weighted_mean-Union{Tuple{WT}, Tuple{WT, Any, Any}} where WT&lt;:Real"><code>GeometryOps.weighted_mean</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">weighted_mean(weight::Real, x1, x2)</code></pre><p>Returns the weighted mean of <code>x1</code> and <code>x2</code>, where <code>weight</code> is the weight of <code>x1</code>.</p><p>Specifically, calculates <code>x1 * weight + x2 * (1 - weight)</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The idea for this method is that you can override this for custom types, like Color types, in extension modules.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/6757cf1d58de64ece71fcab146468d17532be719/src/methods/barycentric.jl#L203-L212">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.within-Tuple{Any, Any}" href="#GeometryOps.within-Tuple{Any, Any}"><code>GeometryOps.within</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">within(geom1, geom)::Bool</code></pre><p>Return <code>true</code> if the first geometry is completely within the second geometry. The interiors of both geometries must intersect and, the interior and boundary of the primary (geometry a) must not intersect the exterior of the secondary (geometry b). <code>within</code> returns the exact opposite result of <code>contains</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">import GeometryOps as GO, GeoInterface as GI

line = GI.LineString([(1, 1), (1, 2), (1, 3), (1, 4)])
point = (1, 2)
GO.within(point, line)

# output
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/6757cf1d58de64ece71fcab146468d17532be719/src/methods/within.jl#L6-L25">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-HormannPresentation"><a class="tag is-link" href="#citeref-HormannPresentation">HormannPresentation</a>K. Hormann and N. Sukumar. Generalized Barycentric Coordinates in Computer Graphics and Computational Mechanics. Taylor &amp; Fancis, CRC Press, 2017.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="source/GeometryOps/">GeometryOps.jl »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Monday 2 October 2023 19:21">Monday 2 October 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
