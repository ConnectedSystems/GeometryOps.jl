<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>- · GeometryOps.jl</title><script data-outdated-warner src="../../../assets/warner.js"></script><link rel="canonical" href="https://asinghvi17.github.io/GeometryOps.jl/source/transformations/simplify/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">GeometryOps.jl</a></span></div><form class="docs-search" action="../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">Source code</span><ul><li><a class="tocitem" href="../../GeometryOps/">-</a></li><li><a class="tocitem" href="../../GeometryOps.jl.2645/">-</a></li><li><a class="tocitem" href="../../primitives/">-</a></li><li><a class="tocitem" href="../../methods/centroid/">-</a></li><li><a class="tocitem" href="../../methods/contains/">-</a></li><li><a class="tocitem" href="../../methods/signed_area/">Signed area</a></li><li><a class="tocitem" href="../../methods/signed_distance/">Signed distance</a></li><li><a class="tocitem" href="../flip/">-</a></li><li><a class="tocitem" href="../reproject/">-</a></li><li class="is-active"><a class="tocitem" href>-</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Source code</a></li><li class="is-active"><a href>-</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>-</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/asinghvi17/GeometryOps.jl/blob/main/docs/src/source/transformations/simplify.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><pre><code class="language-julia hljs">abstract type SimplifyAlg end

&quot;&quot;&quot;
    simplify(obj; tol=0.1, prefilter=true)
    simplify(::SimplifyAlg, obj)

Simplify a geometry, feature, feature collection,
or nested vectors or a table of these.

`RadialDistance`, `DouglasPeucker`, or
`VisvalingamWhyatt` algorithms are available,
listed in order of increasing quality but decreaseing performance.

`PoinTrait` and `MultiPointTrait` are returned unchanged.

The default behaviour is `DouglasPeucker(; tol=0.1, prefilter=true)`.

Pass in constructed `SimplifyAlg`s to use other algorithms.</code></pre><p>Examples</p><pre><code class="language-julia hljs">```jldoctest
julia&gt;
import GeoInterface as GI
import GeometryOps as GO

poly = GI.Polygon([[
    [-70.603637, -33.399918],
    [-70.614624, -33.395332],
    [-70.639343, -33.392466],
    [-70.659942, -33.394759],
    [-70.683975, -33.404504],
    [-70.697021, -33.419406],
    [-70.701141, -33.434306],
    [-70.700454, -33.446339],
    [-70.694274, -33.458369],
    [-70.682601, -33.465816],
    [-70.668869, -33.472117],
    [-70.646209, -33.473835],
    [-70.624923, -33.472117],
    [-70.609817, -33.468107],
    [-70.595397, -33.458369],
    [-70.587158, -33.442901],
    [-70.587158, -33.426283],
    [-70.590591, -33.414248],
    [-70.594711, -33.406224],
    [-70.603637, -33.399918]]])

julia&gt; GO.simplify(DouglasPeucker(; tol=0.01), poly)
Polygon(Array{Array{Float64,1},1}[[[-70.6036, -33.3999], [-70.684, -33.4045], [-70.7011, -33.4343], [-70.6943, -33.4584], [-70.6689, -33.4721], [-70.6098, -33.4681], [-70.5872, -33.4429], [-70.6036, -33.3999]]])
```
&quot;&quot;&quot;
simplify(data; tol=0.1, prefilter=true) = _simplify(DouglasPeucker(; tol, prefilter), data)
simplify(alg::SimplifyAlg, data) = _simplify(alg, data)

function _simplify(alg::SimplifyAlg, data)</code></pre><p>Apply simplication to all curves, multipoints, and points, reconstructing everything else around them.</p><pre><code class="language-julia hljs">    apply(Union{PolygonTrait,AbstractCurveTrait,MultiPoint,PointTrait}, data) do geom
        _simplify(trait(geom), alg, geom)
    end
end</code></pre><p>For Point and MultiPoint traits we do nothing</p><pre><code class="language-julia hljs">_simplify(::PointTrait, alg, geom) = geom
_simplify(::MultiPointTrait, alg, geom) = geom
function _simplify(::PolygonTrait, alg, geom)</code></pre><p>Force treating children as LinearRing</p><pre><code class="language-julia hljs">    lrs = map(GI.getgeom(geom)) do g
        rebuild(g, _simplify(LinearRingTrait(), alg, g))
    end
    return rebuild(geom, lrs)
end</code></pre><p>For curves and rings we simplify</p><pre><code class="language-julia hljs">_simplify(::AbstractCurveTrait, alg, geom) = rebuild(geom, simplify(alg, tuple_points(geom)))
function _simplify(::LinearRingTrait, alg, geom)
    GI.npoint(geom) &lt; 4 &amp;&amp; throw(ArgumentError(&quot;Invalid ring, has less than 4 points.&quot;))</code></pre><p>Make a vector of points</p><pre><code class="language-julia hljs">    points = tuple_points(geom)</code></pre><p>Simplify it once</p><pre><code class="language-julia hljs">    simple = _simplify(alg, points)</code></pre><p>Reduce the tolerance and simplify until its valid</p><pre><code class="language-julia hljs">    while !_isvalid(simple)
        alg = settol(alg, alg.tol * 0.9)
        simple = _simplify(alg, points)
    end</code></pre><p>Close the ring if its not closed</p><pre><code class="language-julia hljs">    point_equals_point(simple[begin], simple[end]) || push!(simple, simple[1])

    return rebuild(geom, simple)
end

&quot;&quot;&quot;
    RadialDistance &lt;: SimplifyAlg

Simplifies geometries by removing points less than
`tol` distance from the line between its neighboring points.
&quot;&quot;&quot;
@kwdef struct RadialDistance &lt;: SimplifyAlg
    tol::Float64=0.1
end

settol(::RadialDistance, tol) = RadialDistance(tol)

function _simplify(alg::RadialDistance, points::Vector)
    point = previous = points[1]
    new_points = [previous]

    for i in eachindex(points)
        point = points[i]
        if squared_dist(point, previous) &gt; alg.tol^2
            push!(new_points, point)
            previous = point
        end
    end

    !isequal(previous, point) &amp;&amp; push!(new_points, point)

    return new_points
end

function squared_dist(p1, p2)
    dx = GI.x(p1) - GI.x(p2)
    dy = GI.y(p1) - GI.y(p2)

    return dx^2 + dy^2
end

&quot;&quot;&quot;
    DouglasPeucker &lt;: SimplifyAlg

Simplifies geometries by removing points below `tol`
distance from the line between its neighboring points.
&quot;&quot;&quot;
@kwdef struct DouglasPeucker &lt;: SimplifyAlg
    tol::Float64=0.1
    prefilter::Bool=true
end

settol(alg::DouglasPeucker, tol) = DouglasPeucker(tol, alg.prefilter)

function _simplify(alg::DouglasPeucker, points::Vector)
    length(points) &lt;= 3 &amp;&amp; return points
    points = alg.prefilter ? simplify(RadialDistance(alg.tol), points) : points</code></pre><p>Defined the simplified point vector, starting with the first point</p><pre><code class="language-julia hljs">    new_points = [points[1]]</code></pre><p>Iteratively add simplified points</p><pre><code class="language-julia hljs">    _dp_step!(new_points, points, 1, length(points), alg.tol)</code></pre><p>Make sure the last point is included</p><pre><code class="language-julia hljs">    push!(new_points, points[end])

    return new_points
end

function _dp_step!(simplified, points::Vector, first::Integer, last::Integer, tol::Real)
    max_dist = tol
    index = 0

    for i = first+1:last
        dist = squared_segdist(points[i], points[first], points[last])
        if dist &gt; max_dist
            index = i
            max_dist = dist
        end
    end

    if max_dist &gt; tol
        if (index - first &gt; 1)
            _dp_step!(simplified, points, first, index, tol)
        end
        push!(simplified, points[index])
        if (last - index &gt; 1)
            _dp_step!(simplified, points, index, last, tol)
        end
    end

    return nothing
end

function _isvalid(ring::Vector)
    length(ring) &lt; 3 &amp;&amp; return false
    length(ring) == 3 &amp;&amp; point_equals_point(ring[3], ring[1]) &amp;&amp; return false
    return true
end

function squared_segdist(p, l1, l2)
    x, y = GI.x(l1), GI.y(l1)
    dx = GI.x(l2) - x
    dy = GI.y(l2) - y

    if !iszero(dx) || !iszero(dy)
        t = ((GI.x(p) - x) * dx + (GI.y(p) - y) * dy) / (dx * dx + dy * dy)

        if t &gt; 1
            x = GI.x(l2)
            y = GI.y(l2)
        elseif t &gt; 0
            x += dx * t
            y += dy * t
        end
    end

    dx = GI.x(p) - x
    dy = GI.y(p) - y

    return dx^2 + dy^2
end

point_equals_point(g1, g2) = !(GI.x(g1) == GI.x(g2) &amp;&amp; GI.y(g1) == GI.y(g2))
tuple_points(geom) = map(p -&gt; (Float64(GI.x(p)), Float64(GI.y(p))), GI.getpoint(geom))

&quot;&quot;&quot;
    VisvalingamWhyatt &lt;: SimplifyAlg

    VisvalingamWhyatt(; kw...)

Simplifies geometries by removing points below `tol`
distance from the line between its neighboring points.</code></pre><p>Keywords</p><pre><code class="language-julia hljs">- `number`:
- `ratio`:
- `tol`:
- `prefilter`: wether to use a `RadialDistance()` prefilter -
    for better performance with a slight loss of quality.
&quot;&quot;&quot;
struct VisvalingamWhyatt &lt;: SimplifyAlg
    number::Union{Int,Nothing}
    ratio::Union{Float64,Nothing}
    tol::Union{Float64,Nothing}
    prefilter::Bool
end
function VisvalingamWhyatt(; number=nothing, ratio=nothing, tol=nothing, prefilter=false)
    if count(isnothing, (number, ratio, tol)) == 2
        return VisvalingamWhyatt(number, ratio, tol, prefilter)
    else
        error(&quot;Must provide one of `number`, `ratio` or `tol` keywords&quot;)
    end
end

settol(alg::VisvalingamWhyatt, tol) = VisvalingamWhyatt(alg.number, alg.ratio, tol, alg.prefilter)

function _simplify(alg::VisvalingamWhyatt, points::Vector)
    length(points) &lt;= 2 &amp;&amp; return points
    areas = _build_areas(points)

    (; tol, number, ratio) = alg
    isnothing(tol) || return _by_tol(alg, alg.tol, points, areas)
    isnothing(number) || return _by_number(alg, alg.number, points, areas)
    return _by_ratio(alg, alg.ratio, points, areas)
end

_by_tol(alg, tol, points, areas) = points[areas .&gt;= tol]

function _by_number(alg, n, points, areas)
    tol = partialsort(areas, n)
    return _by_tol(alg, tol, points, areas)[1:n]
end

function _by_ratio(alg, r, points, areas)
    if r &lt;= 0 || r &gt; 1
        error(&quot;Ratio must be 0 &lt; r &lt;= 1. Got $r&quot;)
    end
    return _by_number(alg, round(Int, r * length(points)), points, areas)
end

function _build_areas(points)
    nmax = length(points)
    real_areas = _triangle_areas(points)

    areas = copy(real_areas)
    i = collect(1:nmax)

    min_vert = argmin(areas)
    this_area = areas[min_vert]
    _remove!(areas, min_vert)
    deleteat!(i, min_vert)

    while this_area &lt; Inf
        skip = false

        if min_vert &lt; length(i)
            right_area = _triangle_area(
                points[i[min_vert - 1]],
                points[i[min_vert]],
                points[i[min_vert + 1]],
            )
            if right_area &lt;= this_area
                right_area = this_area
                skip = min_vert == 1
            end

            real_areas[i[min_vert]] = right_area
            areas[min_vert] = right_area
        end

        if min_vert &gt; 2
            left_area = _triangle_area(
                points[i[min_vert - 2]],
                points[i[min_vert - 1]],
                points[i[min_vert]],
            )
            if left_area &lt;= this_area
                left_area = this_area
                skip = min_vert == 2
            end
            real_areas[i[min_vert - 1]] = left_area
            areas[min_vert - 1] = left_area
        end

        if !skip
            min_vert = argmin(areas)
        end
        deleteat!(i, min_vert)
        this_area = areas[min_vert]
        _remove!(areas, min_vert)
    end

    return real_areas
end</code></pre><p>calculates the area of a triangle given its vertices</p><pre><code class="language-julia hljs">_triangle_area(p1, p2, p3) =
    abs(p1[1] * (p2[2] - p3[2]) + p2[1] * (p3[2] - p1[2]) + p3[1] * (p1[2] - p2[2])) / 2.0

function _triangle_areas(points)
    result = Array{Float64}(undef, length(points))
    result[1] = result[end] = Inf

    for i in 2:length(result) - 1
        result[i] = _triangle_area(points[i-1], points[i], points[i+1])
    end
    return result
end

_remove!(s, i) = s[i:end-1] .= s[i+1:end]</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../reproject/">« -</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 26 May 2023 07:16">Friday 26 May 2023</span>. Using Julia version 1.9.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
