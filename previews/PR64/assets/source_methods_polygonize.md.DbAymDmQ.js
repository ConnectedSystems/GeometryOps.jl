import{_ as s,c as i,o as a,a7 as n}from"./chunks/framework.DQ7xOWOY.js";const t="/GeometryOps.jl/previews/PR64/assets/ntngamj.Cq0iXRxq.png",l="/GeometryOps.jl/previews/PR64/assets/adkmlwl.Cu1SXv7U.png",e="/GeometryOps.jl/previews/PR64/assets/xomlcgp.Fkvvj3yN.png",B=JSON.parse('{"title":"Polygonizing raster data","description":"","frontmatter":{},"headers":[],"relativePath":"source/methods/polygonize.md","filePath":"source/methods/polygonize.md","lastUpdated":null}'),p={name:"source/methods/polygonize.md"},o=n(`<h1 id="Polygonizing-raster-data" tabindex="-1">Polygonizing raster data <a class="header-anchor" href="#Polygonizing-raster-data" aria-label="Permalink to &quot;Polygonizing raster data {#Polygonizing-raster-data}&quot;">​</a></h1><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> polygonize</span></span></code></pre></div><p>The methods in this file are able to convert a raster image into a set of polygons, by contour detection using a clockwise Moore neighborhood method.</p><p>The main entry point is the <code>polygonize</code> function.</p><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="GeometryOps.polygonize" href="#GeometryOps.polygonize">#</a> <b><u>GeometryOps.polygonize</u></b> — <i>Function</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">polygonize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(A; minpoints</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">polygonize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(xs, ys, A; minpoints</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Convert matrix <code>A</code> to polygons.</p><p>If <code>xs</code> and <code>ys</code> are passed in they are used as the pixel center points.</p><p><strong>Keywords</strong></p><ul><li><code>minpoints</code>: ignore polygons with less than <code>minpoints</code> points.</li></ul><p><a href="https://github.com/asinghvi17/GeometryOps.jl/blob/b366095a02042f1d20ed35a5d9b706c93c17dbef/src/methods/polygonize.jl#L54-L64" target="_blank" rel="noreferrer">source</a></p></div><br><h2 id="Example" tabindex="-1">Example <a class="header-anchor" href="#Example" aria-label="Permalink to &quot;Example {#Example}&quot;">​</a></h2><p>Here&#39;s a basic example, using the <code>Makie.peaks()</code> function. First, let&#39;s investigate the nature of the function:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Makie, GeometryOps</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 49</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">xs, ys </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> LinRange</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, n), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">LinRange</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, n)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">zs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Makie</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">peaks</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">z_max_value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> maximum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">abs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">extrema</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(zs)))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f, a, p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> heatmap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    xs, ys, zs;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    axis </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (; aspect </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> DataAspect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), title </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Exact function&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cb </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Colorbar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], p; label </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Z-value&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f</span></span></code></pre></div><p><img src="`+t+`" alt=""></p><p>Now, we can use the <code>polygonize</code> function to convert the raster data into polygons.</p><p>For this particular example, we chose a range of z-values between 0.8 and 3.2, which would provide two distinct polyogns with holes.</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">polygons </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> polygonize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(xs, ys, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.8</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> .&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> zs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3.2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>5-element Vector{GeometryBasics.Polygon{2, Float32, Point{2, Float32}, GeometryBasics.LineString{2, Float32, Point{2, Float32}, Base.ReinterpretArray{GeometryBasics.Line{2, Float32}, 1, Tuple{Point{2, Float32}, Point{2, Float32}}, GeometryBasics.TupleView{Tuple{Point{2, Float32}, Point{2, Float32}}, 2, 1, Vector{Point{2, Float32}}}, false}}, Vector{GeometryBasics.LineString{2, Float32, Point{2, Float32}, Base.ReinterpretArray{GeometryBasics.Line{2, Float32}, 1, Tuple{Point{2, Float32}, Point{2, Float32}}, GeometryBasics.TupleView{Tuple{Point{2, Float32}, Point{2, Float32}}, 2, 1, Vector{Point{2, Float32}}}, false}}}}}:</span></span>
<span class="line"><span> GeometryBasics.Polygon{2, Float32, Point{2, Float32}, GeometryBasics.LineString{2, Float32, Point{2, Float32}, Base.ReinterpretArray{GeometryBasics.Line{2, Float32}, 1, Tuple{Point{2, Float32}, Point{2, Float32}}, GeometryBasics.TupleView{Tuple{Point{2, Float32}, Point{2, Float32}}, 2, 1, Vector{Point{2, Float32}}}, false}}, Vector{GeometryBasics.LineString{2, Float32, Point{2, Float32}, Base.ReinterpretArray{GeometryBasics.Line{2, Float32}, 1, Tuple{Point{2, Float32}, Point{2, Float32}}, GeometryBasics.TupleView{Tuple{Point{2, Float32}, Point{2, Float32}}, 2, 1, Vector{Point{2, Float32}}}, false}}}}(GeometryBasics.Line{2, Float32}[Line(Float32[-1.25, -1.25] =&gt; Float32[-1.125, -1.25]), Line(Float32[-1.125, -1.25] =&gt; Float32[-1.0, -1.25]), Line(Float32[-1.0, -1.25] =&gt; Float32[-0.875, -1.25]), Line(Float32[-0.875, -1.25] =&gt; Float32[-0.75, -1.125]), Line(Float32[-0.75, -1.125] =&gt; Float32[-0.625, -1.0]), Line(Float32[-0.625, -1.0] =&gt; Float32[-0.5, -0.875]), Line(Float32[-0.5, -0.875] =&gt; Float32[-0.375, -0.875]), Line(Float32[-0.375, -0.875] =&gt; Float32[-0.25, -0.75]), Line(Float32[-0.25, -0.75] =&gt; Float32[-0.125, -0.625]), Line(Float32[-0.125, -0.625] =&gt; Float32[0.0, -0.625])  …  Line(Float32[-0.625, 0.125] =&gt; Float32[-0.75, 0.0]), Line(Float32[-0.75, 0.0] =&gt; Float32[-0.875, -0.125]), Line(Float32[-0.875, -0.125] =&gt; Float32[-1.0, -0.25]), Line(Float32[-1.0, -0.25] =&gt; Float32[-1.0, -0.375]), Line(Float32[-1.0, -0.375] =&gt; Float32[-1.125, -0.5]), Line(Float32[-1.125, -0.5] =&gt; Float32[-1.125, -0.625]), Line(Float32[-1.125, -0.625] =&gt; Float32[-1.25, -0.75]), Line(Float32[-1.25, -0.75] =&gt; Float32[-1.25, -0.875]), Line(Float32[-1.25, -0.875] =&gt; Float32[-1.25, -1.0]), Line(Float32[-1.25, -1.0] =&gt; Float32[-1.25, -1.125])], GeometryBasics.LineString{2, Float32, Point{2, Float32}, Base.ReinterpretArray{GeometryBasics.Line{2, Float32}, 1, Tuple{Point{2, Float32}, Point{2, Float32}}, GeometryBasics.TupleView{Tuple{Point{2, Float32}, Point{2, Float32}}, 2, 1, Vector{Point{2, Float32}}}, false}}[])</span></span>
<span class="line"><span> GeometryBasics.Polygon{2, Float32, Point{2, Float32}, GeometryBasics.LineString{2, Float32, Point{2, Float32}, Base.ReinterpretArray{GeometryBasics.Line{2, Float32}, 1, Tuple{Point{2, Float32}, Point{2, Float32}}, GeometryBasics.TupleView{Tuple{Point{2, Float32}, Point{2, Float32}}, 2, 1, Vector{Point{2, Float32}}}, false}}, Vector{GeometryBasics.LineString{2, Float32, Point{2, Float32}, Base.ReinterpretArray{GeometryBasics.Line{2, Float32}, 1, Tuple{Point{2, Float32}, Point{2, Float32}}, GeometryBasics.TupleView{Tuple{Point{2, Float32}, Point{2, Float32}}, 2, 1, Vector{Point{2, Float32}}}, false}}}}(GeometryBasics.Line{2, Float32}[Line(Float32[-1.0, 1.5] =&gt; Float32[-0.875, 1.375]), Line(Float32[-0.875, 1.375] =&gt; Float32[-0.875, 1.25]), Line(Float32[-0.875, 1.25] =&gt; Float32[-0.875, 1.125]), Line(Float32[-0.875, 1.125] =&gt; Float32[-0.75, 1.0]), Line(Float32[-0.75, 1.0] =&gt; Float32[-0.625, 0.875]), Line(Float32[-0.625, 0.875] =&gt; Float32[-0.5, 0.75]), Line(Float32[-0.5, 0.75] =&gt; Float32[-0.375, 0.625]), Line(Float32[-0.375, 0.625] =&gt; Float32[-0.25, 0.625]), Line(Float32[-0.25, 0.625] =&gt; Float32[-0.125, 0.625]), Line(Float32[-0.125, 0.625] =&gt; Float32[0.0, 0.625])  …  Line(Float32[0.125, 2.125] =&gt; Float32[0.0, 2.125]), Line(Float32[0.0, 2.125] =&gt; Float32[-0.125, 2.125]), Line(Float32[-0.125, 2.125] =&gt; Float32[-0.25, 2.125]), Line(Float32[-0.25, 2.125] =&gt; Float32[-0.375, 2.125]), Line(Float32[-0.375, 2.125] =&gt; Float32[-0.5, 2.125]), Line(Float32[-0.5, 2.125] =&gt; Float32[-0.625, 2.0]), Line(Float32[-0.625, 2.0] =&gt; Float32[-0.75, 2.0]), Line(Float32[-0.75, 2.0] =&gt; Float32[-0.875, 1.875]), Line(Float32[-0.875, 1.875] =&gt; Float32[-0.875, 1.75]), Line(Float32[-0.875, 1.75] =&gt; Float32[-1.0, 1.625])], GeometryBasics.LineString{2, Float32, Point{2, Float32}, Base.ReinterpretArray{GeometryBasics.Line{2, Float32}, 1, Tuple{Point{2, Float32}, Point{2, Float32}}, GeometryBasics.TupleView{Tuple{Point{2, Float32}, Point{2, Float32}}, 2, 1, Vector{Point{2, Float32}}}, false}}[])</span></span>
<span class="line"><span> GeometryBasics.Polygon{2, Float32, Point{2, Float32}, GeometryBasics.LineString{2, Float32, Point{2, Float32}, Base.ReinterpretArray{GeometryBasics.Line{2, Float32}, 1, Tuple{Point{2, Float32}, Point{2, Float32}}, GeometryBasics.TupleView{Tuple{Point{2, Float32}, Point{2, Float32}}, 2, 1, Vector{Point{2, Float32}}}, false}}, Vector{GeometryBasics.LineString{2, Float32, Point{2, Float32}, Base.ReinterpretArray{GeometryBasics.Line{2, Float32}, 1, Tuple{Point{2, Float32}, Point{2, Float32}}, GeometryBasics.TupleView{Tuple{Point{2, Float32}, Point{2, Float32}}, 2, 1, Vector{Point{2, Float32}}}, false}}}}(GeometryBasics.Line{2, Float32}[Line(Float32[-0.75, -0.75] =&gt; Float32[-0.875, -0.625]), Line(Float32[-0.875, -0.625] =&gt; Float32[-0.875, -0.5]), Line(Float32[-0.875, -0.5] =&gt; Float32[-0.875, -0.375]), Line(Float32[-0.875, -0.375] =&gt; Float32[-0.75, -0.25]), Line(Float32[-0.75, -0.25] =&gt; Float32[-0.625, -0.125]), Line(Float32[-0.625, -0.125] =&gt; Float32[-0.5, -0.125]), Line(Float32[-0.5, -0.125] =&gt; Float32[-0.375, -0.25]), Line(Float32[-0.375, -0.25] =&gt; Float32[-0.25, -0.375]), Line(Float32[-0.25, -0.375] =&gt; Float32[-0.375, -0.5]), Line(Float32[-0.375, -0.5] =&gt; Float32[-0.5, -0.625]), Line(Float32[-0.5, -0.625] =&gt; Float32[-0.625, -0.75])], GeometryBasics.LineString{2, Float32, Point{2, Float32}, Base.ReinterpretArray{GeometryBasics.Line{2, Float32}, 1, Tuple{Point{2, Float32}, Point{2, Float32}}, GeometryBasics.TupleView{Tuple{Point{2, Float32}, Point{2, Float32}}, 2, 1, Vector{Point{2, Float32}}}, false}}[])</span></span>
<span class="line"><span> GeometryBasics.Polygon{2, Float32, Point{2, Float32}, GeometryBasics.LineString{2, Float32, Point{2, Float32}, Base.ReinterpretArray{GeometryBasics.Line{2, Float32}, 1, Tuple{Point{2, Float32}, Point{2, Float32}}, GeometryBasics.TupleView{Tuple{Point{2, Float32}, Point{2, Float32}}, 2, 1, Vector{Point{2, Float32}}}, false}}, Vector{GeometryBasics.LineString{2, Float32, Point{2, Float32}, Base.ReinterpretArray{GeometryBasics.Line{2, Float32}, 1, Tuple{Point{2, Float32}, Point{2, Float32}}, GeometryBasics.TupleView{Tuple{Point{2, Float32}, Point{2, Float32}}, 2, 1, Vector{Point{2, Float32}}}, false}}}}(GeometryBasics.Line{2, Float32}[Line(Float32[-0.25, 1.125] =&gt; Float32[-0.375, 1.25]), Line(Float32[-0.375, 1.25] =&gt; Float32[-0.375, 1.375]), Line(Float32[-0.375, 1.375] =&gt; Float32[-0.25, 1.5]), Line(Float32[-0.25, 1.5] =&gt; Float32[-0.125, 1.625]), Line(Float32[-0.125, 1.625] =&gt; Float32[0.0, 1.625]), Line(Float32[0.0, 1.625] =&gt; Float32[0.125, 1.625]), Line(Float32[0.125, 1.625] =&gt; Float32[0.25, 1.5]), Line(Float32[0.25, 1.5] =&gt; Float32[0.375, 1.375]), Line(Float32[0.375, 1.375] =&gt; Float32[0.375, 1.25]), Line(Float32[0.375, 1.25] =&gt; Float32[0.25, 1.125]), Line(Float32[0.25, 1.125] =&gt; Float32[0.125, 1.0]), Line(Float32[0.125, 1.0] =&gt; Float32[0.0, 1.0]), Line(Float32[0.0, 1.0] =&gt; Float32[-0.125, 1.0])], GeometryBasics.LineString{2, Float32, Point{2, Float32}, Base.ReinterpretArray{GeometryBasics.Line{2, Float32}, 1, Tuple{Point{2, Float32}, Point{2, Float32}}, GeometryBasics.TupleView{Tuple{Point{2, Float32}, Point{2, Float32}}, 2, 1, Vector{Point{2, Float32}}}, false}}[])</span></span>
<span class="line"><span> GeometryBasics.Polygon{2, Float32, Point{2, Float32}, GeometryBasics.LineString{2, Float32, Point{2, Float32}, Base.ReinterpretArray{GeometryBasics.Line{2, Float32}, 1, Tuple{Point{2, Float32}, Point{2, Float32}}, GeometryBasics.TupleView{Tuple{Point{2, Float32}, Point{2, Float32}}, 2, 1, Vector{Point{2, Float32}}}, false}}, Vector{GeometryBasics.LineString{2, Float32, Point{2, Float32}, Base.ReinterpretArray{GeometryBasics.Line{2, Float32}, 1, Tuple{Point{2, Float32}, Point{2, Float32}}, GeometryBasics.TupleView{Tuple{Point{2, Float32}, Point{2, Float32}}, 2, 1, Vector{Point{2, Float32}}}, false}}}}(GeometryBasics.Line{2, Float32}[Line(Float32[1.0, -0.5] =&gt; Float32[0.875, -0.375]), Line(Float32[0.875, -0.375] =&gt; Float32[0.875, -0.25]), Line(Float32[0.875, -0.25] =&gt; Float32[0.875, -0.125]), Line(Float32[0.875, -0.125] =&gt; Float32[0.875, 0.0]), Line(Float32[0.875, 0.0] =&gt; Float32[0.875, 0.125]), Line(Float32[0.875, 0.125] =&gt; Float32[0.875, 0.25]), Line(Float32[0.875, 0.25] =&gt; Float32[1.0, 0.375]), Line(Float32[1.0, 0.375] =&gt; Float32[1.0, 0.5]), Line(Float32[1.0, 0.5] =&gt; Float32[1.0, 0.625]), Line(Float32[1.0, 0.625] =&gt; Float32[1.0, 0.75])  …  Line(Float32[2.125, -0.625] =&gt; Float32[2.125, -0.75]), Line(Float32[2.125, -0.75] =&gt; Float32[2.0, -0.875]), Line(Float32[2.0, -0.875] =&gt; Float32[1.875, -0.875]), Line(Float32[1.875, -0.875] =&gt; Float32[1.75, -1.0]), Line(Float32[1.75, -1.0] =&gt; Float32[1.625, -1.0]), Line(Float32[1.625, -1.0] =&gt; Float32[1.5, -1.0]), Line(Float32[1.5, -1.0] =&gt; Float32[1.375, -0.875]), Line(Float32[1.375, -0.875] =&gt; Float32[1.25, -0.875]), Line(Float32[1.25, -0.875] =&gt; Float32[1.125, -0.75]), Line(Float32[1.125, -0.75] =&gt; Float32[1.125, -0.625])], GeometryBasics.LineString{2, Float32, Point{2, Float32}, Base.ReinterpretArray{GeometryBasics.Line{2, Float32}, 1, Tuple{Point{2, Float32}, Point{2, Float32}}, GeometryBasics.TupleView{Tuple{Point{2, Float32}, Point{2, Float32}}, 2, 1, Vector{Point{2, Float32}}}, false}}[])</span></span></code></pre></div><p>This returns a list of <code>GeometryBasics.Polygon</code>, which can be plotted immediately, or wrapped directly in a <code>GeometryBasics.MultiPolygon</code>. Let&#39;s see how these look:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f, a, p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> poly</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(polygons; label </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Polygonized polygons&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, axis </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (; aspect </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> DataAspect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()))</span></span></code></pre></div><p><img src="`+l+`" alt=""></p><p>Finally, let&#39;s plot the Makie contour lines on top, to see how well the polygonization worked:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">contour!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a, xs, ys, zs; labels </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, levels </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3.2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], label </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Contour lines&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f</span></span></code></pre></div><p><img src="`+e+`" alt=""></p><h2 id="Implementation" tabindex="-1">Implementation <a class="header-anchor" href="#Implementation" aria-label="Permalink to &quot;Implementation {#Implementation}&quot;">​</a></h2><p>The implementation follows:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&quot;&quot;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    polygonize(A; minpoints=10)</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    polygonize(xs, ys, A; minpoints=10)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">Convert matrix \`A\` to polygons.</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">If \`xs\` and \`ys\` are passed in they are used as the pixel center points.</span></span></code></pre></div><p>Keywords</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`minpoints\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: ignore polygons with less than </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`minpoints\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> points.</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&quot;&quot;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">polygonize(A::AbstractMatrix; kw...) = polygonize(axes(A)..., A; kw...)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">function polygonize(xs, ys, A::AbstractMatrix; minpoints=10)</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    # This function uses a lazy map to get contours.</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    contours = Iterators.map(get_contours(A)) do contour</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        poly = map(contour) do xy</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">            x, y = Tuple(xy)</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">            Point2f(xs[x], ys[y])</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        end</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    end</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    # If we filter off the minimum points, then it&#39;s a hair more efficient</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    # not to convert contours with length &lt; missingpoints to polygons.</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    if minpoints &gt; 1</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        contours = Iterators.filter(contours) do contour</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">            length(contour) &gt; minpoints</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        end</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">       return map(Polygon, contours)</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    else</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        return map(Polygon, contours)</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    end</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"># rotate direction clockwise</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">rot_clockwise(dir) = (dir) % 8 + 1</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"># rotate direction counterclockwise</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">rot_counterclockwise(dir) = (dir + 6) % 8 + 1</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"># move from current pixel to next in given direction</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">function move(pixel, image, dir, dir_delta)</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    newp = pixel + dir_delta[dir]</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    height, width = size(image)</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    if (0 &lt; newp[1] &lt;= height) &amp;&amp; (0 &lt; newp[2] &lt;= width)</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        if image[newp] != 0</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">            return newp</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        end</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    end</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    return CartesianIndex(0, 0)</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"># finds direction between two given pixels</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">function from_to(from, to, dir_delta)</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    delta = to - from</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    return findall(x -&gt; x == delta, dir_delta)[1]</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">function detect_move(image, p0, p2, nbd, border, done, dir_delta)</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    dir = from_to(p0, p2, dir_delta)</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    moved = rot_clockwise(dir)</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    p1 = CartesianIndex(0, 0)</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    while moved != dir ## 3.1</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        newp = move(p0, image, moved, dir_delta)</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        if newp[1] != 0</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">            p1 = newp</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">            break</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        end</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        moved = rot_clockwise(moved)</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    if p1 == CartesianIndex(0, 0)</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        return</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    p2 = p1 ## 3.2</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    p3 = p0 ## 3.2</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    done .= false</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    while true</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        dir = from_to(p3, p2, dir_delta)</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        moved = rot_counterclockwise(dir)</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        p4 = CartesianIndex(0, 0)</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        done .= false</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        while true ## 3.3</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">            p4 = move(p3, image, moved, dir_delta)</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">            if p4[1] != 0</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                break</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">            end</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">            done[moved] = true</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">            moved = rot_counterclockwise(moved)</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        end</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        push!(border, p3) ## 3.4</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        if p3[1] == size(image, 1) || done[3]</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">            image[p3] = -nbd</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        elseif image[p3] == 1</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">            image[p3] = nbd</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        if (p4 == p0 &amp;&amp; p3 == p1) ## 3.5</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">            break</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        end</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        p2 = p3</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        p3 = p4</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    end</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&quot;&quot;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">   get_contours</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(A</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractMatrix</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Returns contours </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> vectors of </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`CartesianIndex\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&quot;&quot;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">function get_contours(image::AbstractMatrix)</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    nbd = 1</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    lnbd = 1</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    image = Float64.(image)</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    contour_list = Vector{typeof(CartesianIndex[])}()</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    done = [false, false, false, false, false, false, false, false]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    # Clockwise Moore neighborhood.</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    dir_delta = (CartesianIndex(-1, 0), CartesianIndex(-1, 1), CartesianIndex(0, 1), CartesianIndex(1, 1),</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                 CartesianIndex(1, 0), CartesianIndex(1, -1), CartesianIndex(0, -1), CartesianIndex(-1, -1))</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    height, width = size(image)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    for i = 1:height</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        lnbd = 1</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        for j = 1:width</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">            fji = image[i, j]</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">            is_outer = (image[i, j] == 1 &amp;&amp; (j == 1 || image[i, j-1] == 0)) ## 1 (a)</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">            is_hole = (image[i, j] &gt;= 1 &amp;&amp; (j == width || image[i, j+1] == 0))</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">            if is_outer || is_hole</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                # 2</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                border = CartesianIndex[]</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                from = CartesianIndex(i, j)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                if is_outer</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                    nbd += 1</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                    from -= CartesianIndex(0, 1)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                else</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                    nbd += 1</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                    if fji &gt; 1</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                        lnbd = fji</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                    end</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                    from += CartesianIndex(0, 1)</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                p0 = CartesianIndex(i, j)</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                detect_move(image, p0, from, nbd, border, done, dir_delta) ## 3</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                if isempty(border) ##TODO</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                    push!(border, p0)</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                    image[p0] = -nbd</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                end</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                push!(contour_list, border)</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">            end</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">            if fji != 0 &amp;&amp; fji != 1</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                lnbd = abs(fji)</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">            end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        end</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    return contour_list</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">end</span></span></code></pre></div><hr><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl" target="_blank" rel="noreferrer">Literate.jl</a>.</em></p>`,27),h=[o];function k(F,r,d,g,c,y){return a(),i("div",null,h)}const C=s(p,[["render",k]]);export{B as __pageData,C as default};
